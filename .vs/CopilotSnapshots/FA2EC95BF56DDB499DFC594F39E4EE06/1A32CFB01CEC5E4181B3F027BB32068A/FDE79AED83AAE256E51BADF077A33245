//using Microsoft.AspNetCore.Mvc;
//using Microsoft.Extensions.Configuration;
//using Npgsql;
//using System;
//using System.Collections.Generic;
//using System.Linq;
//using System.Threading.Tasks;

//namespace Timetablegenerator.Controllers
//{
//    [ApiController]
//    [Route("api/[controller]")]
//    public class TimetableController : ControllerBase
//    {
//        private readonly IConfiguration _configuration;
//        public TimetableController(IConfiguration configuration)
//        {
//            _configuration = configuration;
//        }

//        // DTO Classes
//        public class TimetableRequest
//        {
//            public string Department { get; set; }
//            public string Year { get; set; }
//            public string Semester { get; set; }
//            public string Section { get; set; }
//            public int TotalHoursPerDay { get; set; } = 7;
//            public List<SubjectDto> Subjects { get; set; }
//        }

//        public class SubjectDto
//        {
//            public string SubjectCode { get; set; }
//            public string SubjectName { get; set; }
//            public string SubjectType { get; set; }
//            public int Credit { get; set; }
//            public string StaffAssigned { get; set; }
//            public string LabId { get; set; }
//        }

//        // Helper class for per-task scheduling
//        public class TaskUnit
//        {
//            public string SubjectCode;
//            public string SubjectName;
//            public string StaffAssigned;
//            public string LabId;
//            public bool IsLab;
//            public int Duration;
//            public string Kind;
//            public string Day;
//            public int StartHour;
//            public List<(string day, int hour)> Tried = new();
//        }

//        [HttpPost("generateCrossDepartmentTimetableBacktracking")]
//        public async Task<IActionResult> GenerateCrossDepartmentTimetableBacktracking([FromBody] TimetableRequest request)
//        {
//            var cs = _configuration.GetConnectionString("DefaultConnection");
//            try
//            {
//                string[] DAYS = new[] { "Mon", "Tue", "Wed", "Thu", "Fri" };
//                int HOURS = Math.Max(1, request.TotalHoursPerDay);

//                // Staff code parsing helper
//                (string staffName, string staffCode) SplitStaff(string staffAssigned)
//                {
//                    if (string.IsNullOrWhiteSpace(staffAssigned)) return ("---", "---");
//                    var name = staffAssigned;
//                    var code = staffAssigned;
//                    if (staffAssigned.Contains("("))
//                    {
//                        var parts = staffAssigned.Split('(', StringSplitOptions.TrimEntries);
//                        name = parts[0].Trim();
//                        code = parts.Length > 1 ? parts[1].Replace(")", "").Trim() : "---";
//                    }
//                    return (name, code);
//                }

//                // Build subjects from request, ignore those without staff assigned
//                var subjects = new List<(string code, string name, string type, int credit, string staff, string labId)>();
//                foreach (var s in request.Subjects ?? Enumerable.Empty<SubjectDto>())
//                {
//                    if (string.IsNullOrWhiteSpace(s.StaffAssigned)) continue;
//                    var type = (s.SubjectType ?? "theory").Trim().ToLower();
//                    subjects.Add((
//                        s.SubjectCode ?? "---",
//                        s.SubjectName ?? "---",
//                        type,
//                        s.Credit,
//                        s.StaffAssigned,
//                        (type == "lab" || type == "embedded") ? (s.LabId?.Trim()) : null
//                    ));
//                }
//                if (subjects.Count == 0)
//                    return BadRequest(new { message = "❌ No valid subjects found (missing staff)." });

//                // Load existing DB occupancy maps for staff and labs
//                var staffOcc = new Dictionary<string, Dictionary<string, HashSet<int>>>();
//                var labOcc = new Dictionary<string, Dictionary<string, HashSet<int>>>();

//                using var conn = new NpgsqlConnection(cs);
//                await conn.OpenAsync();

//                void EnsureDayMap<TKey>(Dictionary<TKey, Dictionary<string, HashSet<int>>> map, TKey key)
//                {
//                    if (!map.ContainsKey(key))
//                        map[key] = DAYS.ToDictionary(d => d, d => new HashSet<int>());
//                }

//                // Load staff occupancy from DB
//                using (var cmd = new NpgsqlCommand("SELECT staff_code, day, hour FROM classtimetable", conn))
//                using (var rd = await cmd.ExecuteReaderAsync())
//                {
//                    while (await rd.ReadAsync())
//                    {
//                        var sc = rd["staff_code"]?.ToString() ?? "---";
//                        var day = rd["day"]?.ToString() ?? "Mon";
//                        var hr = Convert.ToInt32(rd["hour"]);
//                        EnsureDayMap(staffOcc, sc);
//                        if (!staffOcc[sc].ContainsKey(day)) staffOcc[sc][day] = new HashSet<int>();
//                        staffOcc[sc][day].Add(hr);
//                    }
//                }

//                // Load lab occupancy from DB
//                using (var cmd = new NpgsqlCommand("SELECT lab_id, day, hour FROM labtimetable", conn))
//                using (var rd = await cmd.ExecuteReaderAsync())
//                {
//                    while (await rd.ReadAsync())
//                    {
//                        var lab = rd["lab_id"]?.ToString() ?? "---";
//                        var day = rd["day"]?.ToString() ?? "Mon";
//                        var hr = Convert.ToInt32(rd["hour"]);
//                        EnsureDayMap(labOcc, lab);
//                        if (!labOcc[lab].ContainsKey(day)) labOcc[lab][day] = new HashSet<int>();
//                        labOcc[lab][day].Add(hr);
//                    }
//                }

//                // Ensure days map for all staff and labs
//                foreach (var s in subjects)
//                {
//                    var (_, staffCode) = SplitStaff(s.staff);
//                    EnsureDayMap(staffOcc, staffCode);
//                    if (!string.IsNullOrEmpty(s.labId)) EnsureDayMap(labOcc, s.labId);
//                }

//                // Translate subject info into schedule-able tasks with special constraints:
//                var tasks = new List<TaskUnit>();

//                // Allowed continuous blocks for labs
//                var labAllowedBlocks = new List<int[]> { new[] { 1, 2, 3, 4 }, new[] { 4, 5, 6, 7 } };

//                // Allowed continuous 2-hour blocks for embedded labs
//                var embeddedLabAllowedBlocks = new List<int[]> {
//                    new[] { 1, 2 },
//                    new[] { 2, 3 },
//                    new[] { 3, 4 },
//                    new[] { 5, 6 },
//                    new[] { 6, 7 }
//                };

//                // For embedded theory sessions - non-adjacent single hours (to be randomized in placement)

//                foreach (var s in subjects)
//                {
//                    switch (s.type)
//                    {
//                        case "lab":
//                            // One 4-hour continuous block task representing the lab
//                            tasks.Add(new TaskUnit
//                            {
//                                SubjectCode = s.code,
//                                SubjectName = s.name,
//                                StaffAssigned = s.staff,
//                                LabId = s.labId,
//                                IsLab = true,
//                                Duration = 4,
//                                Kind = "LAB4"
//                            });
//                            break;

//                        case "embedded":
//                            // Embedded lab 2-hour continuous block task
//                            tasks.Add(new TaskUnit
//                            {
//                                SubjectCode = s.code,
//                                SubjectName = s.name,
//                                StaffAssigned = s.staff,
//                                LabId = s.labId,
//                                IsLab = true,
//                                Duration = 2,
//                                Kind = "EMB_LAB2"
//                            });

//                            // Two embedded theory 1-hour tasks non-adjacent, randomized placement
//                            tasks.Add(new TaskUnit
//                            {
//                                SubjectCode = s.code,
//                                SubjectName = s.name,
//                                StaffAssigned = s.staff,
//                                LabId = null,
//                                IsLab = false,
//                                Duration = 1,
//                                Kind = "EMB_TH1"
//                            });
//                            tasks.Add(new TaskUnit
//                            {
//                                SubjectCode = s.code,
//                                SubjectName = s.name,
//                                StaffAssigned = s.staff,
//                                LabId = null,
//                                IsLab = false,
//                                Duration = 1,
//                                Kind = "EMB_TH1"
//                            });
//                            break;

//                        default: // theory and any other
//                            // Credit count equals number of 1-hour theory tasks
//                            int count = Math.Max(0, s.credit);
//                            for (int i = 0; i < count; i++)
//                            {
//                                tasks.Add(new TaskUnit
//                                {
//                                    SubjectCode = s.code,
//                                    SubjectName = s.name,
//                                    StaffAssigned = s.staff,
//                                    LabId = null,
//                                    IsLab = false,
//                                    Duration = 1,
//                                    Kind = "TH1"
//                                });
//                            }
//                            break;
//                    }
//                }

//                // Initialize timetable grid: Dictionary of {Day -> {Hour -> slot string}}
//                var timetable = DAYS.Select(d => new
//                {
//                    Day = d,
//                    Slots = Enumerable.Range(1, HOURS).ToDictionary(h => h, _ => "---")
//                }).ToList();

//                // Helpers for grid access and checking

//                bool IsFreeInGrid(string day, int start, int duration)
//                {
//                    var row = timetable.First(t => t.Day == day).Slots;
//                    for (int h = start; h < start + duration; h++)
//                        if (h < 1 || h > HOURS || row[h] != "---") return false;
//                    return true;
//                }

//                void PlaceInGrid(string subjectCode, string staffAssigned, string day, int start, int duration)
//                {
//                    var row = timetable.First(t => t.Day == day).Slots;
//                    for (int h = start; h < start + duration; h++)
//                        row[h] = $"{subjectCode} ({staffAssigned})";
//                }

//                void RemoveFromGrid(string day, int start, int duration)
//                {
//                    var row = timetable.First(t => t.Day == day).Slots;
//                    for (int h = start; h < start + duration; h++)
//                        row[h] = "---";
//                }

//                // Order tasks: labs first (long continuous blocks), then embedded labs, embedded theory, theory
//                tasks = tasks
//                    .OrderByDescending(t => t.Kind == "LAB4" ? 3 :
//                                           t.Kind == "EMB_LAB2" ? 2 :
//                                           t.Kind == "EMB_TH1" ? 1 :
//                                           0)
//                    .ThenByDescending(t => t.Duration)
//                    .ToList();

//                // State to ensure embedded theory non-adjacency for same subject
//                var embTheoryPlaced = new Dictionary<string, List<(string day, int hour)>>();

//                bool CanPlaceEmbeddedTheory(TaskUnit t, string day, int hour)
//                {
//                    if (!embTheoryPlaced.ContainsKey(t.SubjectCode)) return true;
//                    foreach (var (d, h) in embTheoryPlaced[t.SubjectCode])
//                    {
//                        // Must not place at same day adjacent hours (hour-1, hour, hour+1)
//                        if (d == day && (h == hour || h == hour - 1 || h == hour + 1))
//                            return false;
//                    }
//                    return true;
//                }

//                // Custom Fits function enforcing all constraints, continuous blocks, and lab/lab use exclusion
//                bool Fits(TaskUnit t, string day, int start)
//                {
//                    // Check grid free
//                    if (!IsFreeInGrid(day, start, t.Duration)) return false;

//                    var (_, staffCode) = SplitStaff(t.StaffAssigned);

//                    // Check staff occupancy
//                    for (int h = start; h < start + t.Duration; h++)
//                    {
//                        if (staffOcc.TryGetValue(staffCode, out var dm) && dm.TryGetValue(day, out var set) && set.Contains(h))
//                            return false;
//                    }

//                    // Labs: lab occupancy + continuous block allowed only for specific hour ranges
//                    if (t.IsLab)
//                    {
//                        if (!string.IsNullOrEmpty(t.LabId))
//                        {
//                            for (int h = start; h < start + t.Duration; h++)
//                            {
//                                if (labOcc.TryGetValue(t.LabId, out var dm) && dm.TryGetValue(day, out var set) && set.Contains(h))
//                                    return false;
//                            }
//                        }

//                        // Continuous block constraints:
//                        if (t.Kind == "LAB4")
//                        {
//                            // Only allow 4-contiguous blocks in allowed sets
//                            if (!labAllowedBlocks.Any(block => block[0] == start && block.Length == t.Duration))
//                                return false;
//                        }
//                        if (t.Kind == "EMB_LAB2")
//                        {
//                            // Only allow 2-contiguous blocks in embedded allowed sets
//                            if (!embeddedLabAllowedBlocks.Any(block => block[0] == start && block.Length == t.Duration))
//                                return false;
//                        }
//                    }

//                    // Embedded theory: non-adjacent check
//                    if (t.Kind == "EMB_TH1" && !CanPlaceEmbeddedTheory(t, day, start))
//                        return false;

//                    return true;
//                }

//                void Commit(TaskUnit t, string day, int start)
//                {
//                    t.Day = day;
//                    t.StartHour = start;
//                    var (_, staffCode) = SplitStaff(t.StaffAssigned);

//                    PlaceInGrid(t.SubjectCode, t.StaffAssigned, day, start, t.Duration);

//                    for (int h = start; h < start + t.Duration; h++)
//                        staffOcc[staffCode][day].Add(h);

//                    if (t.IsLab && !string.IsNullOrEmpty(t.LabId))
//                    {
//                        for (int h = start; h < start + t.Duration; h++)
//                            labOcc[t.LabId][day].Add(h);
//                    }

//                    if (t.Kind == "EMB_TH1")
//                    {
//                        if (!embTheoryPlaced.ContainsKey(t.SubjectCode))
//                            embTheoryPlaced[t.SubjectCode] = new List<(string, int)>();
//                        embTheoryPlaced[t.SubjectCode].Add((day, start));
//                    }
//                }

//                void Revert(TaskUnit t)
//                {
//                    var (_, staffCode) = SplitStaff(t.StaffAssigned);

//                    RemoveFromGrid(t.Day, t.StartHour, t.Duration);

//                    for (int h = t.StartHour; h < t.StartHour + t.Duration; h++)
//                        staffOcc[staffCode][t.Day].Remove(h);

//                    if (t.IsLab && !string.IsNullOrEmpty(t.LabId))
//                    {
//                        for (int h = t.StartHour; h < t.StartHour + t.Duration; h++)
//                            labOcc[t.LabId][t.Day].Remove(h);
//                    }

//                    if (t.Kind == "EMB_TH1" && embTheoryPlaced.ContainsKey(t.SubjectCode))
//                    {
//                        embTheoryPlaced[t.SubjectCode].RemoveAll(x => x.day == t.Day && x.hour == t.StartHour);
//                    }

//                    t.Tried.Add((t.Day, t.StartHour));
//                    t.Day = null;
//                    t.StartHour = 0;
//                }

//                // Candidate slots generator with randomization for theory and embedded theory to spread random selections
//                IEnumerable<(string day, int start)> Candidates(TaskUnit t)
//                {
//                    var daysShuffled = DAYS.OrderBy(_ => Guid.NewGuid()).ToArray();
//                    var hours = Enumerable.Range(1, HOURS - t.Duration + 1).OrderBy(_ => Guid.NewGuid()).ToArray();

//                    foreach (var d in daysShuffled)
//                        foreach (var h in hours)
//                            if (!t.Tried.Contains((d, h)))
//                                yield return (d, h);
//                }

//                // Backtracking solver with conflict popping and retrying, stops and suggests manual fix if stuck
//                bool Solve(int idx)
//                {
//                    if (idx == tasks.Count) return true;

//                    var t = tasks[idx];

//                    foreach (var (day, start) in Candidates(t))
//                    {
//                        if (!Fits(t, day, start)) continue;

//                        Commit(t, day, start);

//                        if (Solve(idx + 1)) return true;

//                        Revert(t);
//                    }

//                    // No valid position found for this task -> must stop and ask user correction
//                    return false;
//                }

//                var ok = Solve(0);

//                if (!ok)
//                {
//                    // Return partial timetable with message to manually fix conflicts before retry
//                    return Ok(new
//                    {
//                        message = "⚠ Backtracking failed to place all tasks under given constraints due to conflicts with existing timetable. Please adjust inputs manually.",
//                        timetable,
//                        usedLabIds = tasks.Where(x => x.IsLab && !string.IsNullOrEmpty(x.LabId)).Select(x => x.LabId).Distinct().ToList(),
//                        receivedPayload = request
//                    });
//                }

//                // Write final timetable to DB
//                foreach (var t in tasks)
//                {
//                    var (staffName, staffCode) = SplitStaff(t.StaffAssigned);

//                    // Insert all hours into classtimetable
//                    for (int h = t.StartHour; h < t.StartHour + t.Duration; h++)
//                    {
//                        using (var icClass = new NpgsqlCommand(@"
//            INSERT INTO classtimetable
//            (staff_name, staff_code, department_id, year, semester, section, day, hour, subject_code, subject_name)
//            VALUES
//            (@staff_name, @staff_code, @department, @year, @semester, @section, @day, @hour, @subject_code, @subject_name);", conn))
//                        {
//                            icClass.Parameters.AddWithValue("@staff_name", staffName ?? "---");
//                            icClass.Parameters.AddWithValue("@staff_code", staffCode ?? "---");
//                            icClass.Parameters.AddWithValue("@department", request.Department ?? "---");
//                            icClass.Parameters.AddWithValue("@year", request.Year ?? "---");
//                            icClass.Parameters.AddWithValue("@semester", request.Semester ?? "---");
//                            icClass.Parameters.AddWithValue("@section", request.Section ?? "---");
//                            icClass.Parameters.AddWithValue("@day", t.Day ?? "---");
//                            icClass.Parameters.AddWithValue("@hour", h);
//                            icClass.Parameters.AddWithValue("@subject_code", t.SubjectCode ?? "---");
//                            icClass.Parameters.AddWithValue("@subject_name", t.SubjectName ?? "---");
//                            await icClass.ExecuteNonQueryAsync();
//                        }
//                    }

//                    // Insert lab timetable data with special logic
//                    if (t.IsLab && !string.IsNullOrEmpty(t.LabId))
//                    {
//                        // If lab starts at 4th hour, skip hour 4 for labtimetable
//                        if (t.StartHour == 4)
//                        {
//                            for (int h = 5; h < 4 + t.Duration; h++) // hours 5,6,7 only
//                            {
//                                using (var icLab = new NpgsqlCommand(@"
//                    INSERT INTO labtimetable
//                    (lab_id, subject_code, subject_name, staff_name, department, year, semester, section, day, hour)
//                    VALUES
//                    (@lab_id, @subject_code, @subject_name, @staff_name, @department, @year, @semester, @section, @day, @hour);", conn))
//                                {
//                                    icLab.Parameters.AddWithValue("@lab_id", t.LabId ?? (object)DBNull.Value);
//                                    icLab.Parameters.AddWithValue("@subject_code", t.SubjectCode ?? "---");
//                                    icLab.Parameters.AddWithValue("@subject_name", t.SubjectName ?? "---");
//                                    icLab.Parameters.AddWithValue("@staff_name", staffName ?? "---");
//                                    icLab.Parameters.AddWithValue("@department", request.Department ?? "---");
//                                    icLab.Parameters.AddWithValue("@year", request.Year ?? "---");
//                                    icLab.Parameters.AddWithValue("@semester", request.Semester ?? "---");
//                                    icLab.Parameters.AddWithValue("@section", request.Section ?? "---");
//                                    icLab.Parameters.AddWithValue("@day", t.Day ?? "---");
//                                    icLab.Parameters.AddWithValue("@hour", h);
//                                    await icLab.ExecuteNonQueryAsync();
//                                }
//                            }
//                        }
//                        else
//                        {
//                            // Normal insertion for all lab hours
//                            for (int h = t.StartHour; h < t.StartHour + t.Duration; h++)
//                            {
//                                using (var icLab = new NpgsqlCommand(@"
//                    INSERT INTO labtimetable
//                    (lab_id, subject_code, subject_name, staff_name, department, year, semester, section, day, hour)
//                    VALUES
//                    (@lab_id, @subject_code, @subject_name, @staff_name, @department, @year, @semester, @section, @day, @hour);", conn))
//                                {
//                                    icLab.Parameters.AddWithValue("@lab_id", t.LabId ?? (object)DBNull.Value);
//                                    icLab.Parameters.AddWithValue("@subject_code", t.SubjectCode ?? "---");
//                                    icLab.Parameters.AddWithValue("@subject_name", t.SubjectName ?? "---");
//                                    icLab.Parameters.AddWithValue("@staff_name", staffName ?? "---");
//                                    icLab.Parameters.AddWithValue("@department", request.Department ?? "---");
//                                    icLab.Parameters.AddWithValue("@year", request.Year ?? "---");
//                                    icLab.Parameters.AddWithValue("@semester", request.Semester ?? "---");
//                                    icLab.Parameters.AddWithValue("@section", request.Section ?? "---");
//                                    icLab.Parameters.AddWithValue("@day", t.Day ?? "---");
//                                    icLab.Parameters.AddWithValue("@hour", h);
//                                    await icLab.ExecuteNonQueryAsync();
//                                }
//                            }
//                        }
//                    }
//                }

//                var responseTimetable = timetable.Select(row => new
//                {
//                    Day = row.Day,
//                    HourlySlots = row.Slots
//                }).ToList();

//                return Ok(new
//                {
//                    message = "✅ Timetable generated with constrained backtracking (Labs continuous 4h in fixed blocks, embedded 2h continuous + 2 random theory), respecting existing timetable conflicts.",
//                    timetable = responseTimetable,
//                    usedLabIds = tasks.Where(x => x.IsLab && !string.IsNullOrEmpty(x.LabId)).Select(x => x.LabId).Distinct().ToList(),
//                    receivedPayload = request
//                });
//            }
//            catch (Exception ex)
//            {
//                return StatusCode(500, new { message = "❌ Internal Server Error while generating timetable.", error = ex.Message });
//            }
//        }
//    }
//}


//bake cs alg:
//using Microsoft.AspNetCore.Mvc;
//using Microsoft.Extensions.Configuration;
//using Npgsql;
//using System;
//using System.Collections.Generic;
//using System.Linq;
//using System.Threading.Tasks;

//namespace Timetablegenerator.Controllers
//{
//    [ApiController]
//    [Route("api/[controller]")]
//    public class TimetableController : ControllerBase
//    {
//        private readonly IConfiguration _configuration;

//        // Static readonly fields for allowed blocks
//        private static readonly List<int[]> LabAllowedBlocks = new List<int[]> { new[] { 1, 2, 3, 4 }, new[] { 4, 5, 6, 7 } };
//        private static readonly List<int[]> EmbeddedLabAllowedBlocks = new List<int[]> {
//            new[] { 1, 2 }, new[] { 2, 3 }, new[] { 3, 4 }, new[] { 5, 6 }, new[] { 6, 7 }
//        };

//        public TimetableController(IConfiguration configuration)
//        {
//            _configuration = configuration;
//        }

//        // DTO Classes
//        public class TimetableRequest
//        {
//            public string Department { get; set; }
//            public string Year { get; set; }
//            public string Semester { get; set; }
//            public string Section { get; set; }
//            public int TotalHoursPerDay { get; set; } = 7;
//            public List<SubjectDto> Subjects { get; set; }
//        }
//        public class SubjectDto
//        {
//            public string SubjectCode { get; set; }
//            public string SubjectName { get; set; }
//            public string SubjectType { get; set; }
//            public int Credit { get; set; }
//            public string StaffAssigned { get; set; }
//            public string LabId { get; set; }
//        }

//        // Internal model
//        public class TaskUnit
//        {
//            public string SubjectCode;
//            public string SubjectName;
//            public string StaffAssigned;
//            public string LabId;
//            public bool IsLab;
//            public int Duration;
//            public string Kind;
//            public string Day;
//            public int StartHour;
//            public List<(string day, int hour)> Tried = new();
//        }

//        /// <summary>
//        /// Get DB tasks that conflict with a given slot
//        /// </summary>
//        private async Task<List<TaskUnit>> GetConflictingDbTasks(NpgsqlConnection conn, string reason, string conflictingId, string day, int hour, NpgsqlTransaction tx)
//        {
//            var result = new List<TaskUnit>();
//            string sql;
//            if (reason == "staff")
//            {
//                sql = @"SELECT staff_name, staff_code, subject_code, subject_name, department_id, year, semester, section, day, hour
//                        FROM classtimetable
//                        WHERE staff_code = @id AND day=@day AND hour=@hour
//                        FOR UPDATE;";
//            }
//            else if (reason == "lab")
//            {
//                sql = @"SELECT lab_id, subject_code, subject_name, staff_name, department, year, semester, section, day, hour
//                        FROM labtimetable
//                        WHERE lab_id = @id AND day=@day AND hour=@hour
//                        FOR UPDATE;";
//            }
//            else return result;
//            using (var cmd = new NpgsqlCommand(sql, conn, tx))
//            {
//                cmd.Parameters.AddWithValue("@id", conflictingId);
//                cmd.Parameters.AddWithValue("@day", day);
//                cmd.Parameters.AddWithValue("@hour", hour);
//                using var rd = await cmd.ExecuteReaderAsync();
//                var rows = new List<(string subj, string name, string staff, string lab, int hr, string d)>();
//                while (await rd.ReadAsync())
//                {
//                    rows.Add((
//                        rd["subject_code"].ToString(),
//                        rd["subject_name"].ToString(),
//                        reason == "staff" ? rd["staff_code"].ToString() : rd["staff_name"].ToString(),
//                        reason == "lab" ? rd["lab_id"].ToString() : null,
//                        Convert.ToInt32(rd["hour"]),
//                        rd["day"].ToString()
//                    ));
//                }
//                rd.Close();
//                // Group contiguous rows into TaskUnits
//                foreach (var group in rows.GroupBy(x => (x.subj, x.name, x.staff, x.lab, x.d)))
//                {
//                    var ordered = group.OrderBy(x => x.hr).ToList();
//                    int start = ordered[0].hr;
//                    int last = start;
//                    foreach (var r in ordered.Skip(1))
//                    {
//                        if (r.hr != last + 1)
//                        {
//                            // end segment
//                            result.Add(new TaskUnit
//                            {
//                                SubjectCode = group.Key.subj,
//                                SubjectName = group.Key.name,
//                                StaffAssigned = group.Key.staff,
//                                LabId = group.Key.lab,
//                                IsLab = !string.IsNullOrEmpty(group.Key.lab),
//                                Duration = last - start + 1,
//                                Kind = !string.IsNullOrEmpty(group.Key.lab) ? "LAB" : "TH1",
//                                Day = group.Key.d,
//                                StartHour = start
//                            });
//                            start = r.hr;
//                        }
//                        last = r.hr;
//                    }
//                    // Add last segment
//                    result.Add(new TaskUnit
//                    {
//                        SubjectCode = group.Key.subj,
//                        SubjectName = group.Key.name,
//                        StaffAssigned = group.Key.staff,
//                        LabId = group.Key.lab,
//                        IsLab = !string.IsNullOrEmpty(group.Key.lab),
//                        Duration = last - start + 1,
//                        Kind = !string.IsNullOrEmpty(group.Key.lab) ? "LAB" : "TH1",
//                        Day = group.Key.d,
//                        StartHour = start
//                    });
//                }
//            }
//            return result;
//        }

//        /// <summary>
//        /// Attempt to repair a conflict locally by rescheduling conflicting DB tasks
//        /// </summary>
//        private async Task<bool> RepairConflictingDbTasks(
//            NpgsqlConnection conn,
//            NpgsqlTransaction tx,
//            Dictionary<string, Dictionary<string, HashSet<int>>> staffOcc,
//            Dictionary<string, Dictionary<string, HashSet<int>>> labOcc,
//            List<dynamic> timetable,
//            string reason,
//            string conflictingId,
//            string day,
//            int hour,
//            Func<TaskUnit, string, int, bool> Fits,
//            Action<TaskUnit, string, int> Commit,
//            Action<TaskUnit> Revert)
//        {
//            var conflicts = await GetConflictingDbTasks(conn, reason, conflictingId, day, hour, tx);
//            if (!conflicts.Any() || conflicts.Count > 6) return false;

//            // Temporarily remove them from occupancy + grid
//            foreach (var t in conflicts)
//            {
//                for (int h = t.StartHour; h < t.StartHour + t.Duration; h++)
//                    staffOcc[t.StaffAssigned][t.Day].Remove(h);
//                if (t.IsLab)
//                {
//                    for (int h = t.StartHour; h < t.StartHour + t.Duration; h++)
//                        labOcc[t.LabId][t.Day].Remove(h);
//                }
//                var row = timetable.First(x => x.Day == t.Day).Slots;
//                for (int h = t.StartHour; h < t.StartHour + t.Duration; h++)
//                    row[h] = "---";
//                t.Day = null;
//                t.StartHour = 0;
//            }

//            int attempts = 0;
//            bool backtrack(int idx)
//            {
//                if (idx == conflicts.Count) return true;
//                var t = conflicts[idx];
//                foreach (var (d, s) in CandidatesLocal(timetable, t))
//                {
//                    if (attempts++ > 1000) // Cap attempts to avoid runaway CPU
//                        return false;
//                    if (!Fits(t, d, s)) { t.Tried.Add((d, s)); continue; }
//                    Commit(t, d, s);
//                    if (backtrack(idx + 1)) return true;
//                    Revert(t);
//                }
//                return false;
//            }

//            bool ok = backtrack(0);

//            if (!ok)
//            {
//                // Restore occupancy/grid for conflicts (rollback in-memory changes)
//                foreach (var t in conflicts)
//                {
//                    if (string.IsNullOrEmpty(t.Day) || t.StartHour == 0) continue; // Not placed
//                    for (int h = t.StartHour; h < t.StartHour + t.Duration; h++)
//                        staffOcc[t.StaffAssigned][t.Day].Add(h);
//                    if (t.IsLab)
//                    {
//                        for (int h = t.StartHour; h < t.StartHour + t.Duration; h++)
//                            labOcc[t.LabId][t.Day].Add(h);
//                    }
//                    var row = timetable.First(x => x.Day == t.Day).Slots;
//                    for (int h = t.StartHour; h < t.StartHour + t.Duration; h++)
//                        row[h] = $"{t.SubjectCode} ({t.StaffAssigned})";
//                }
//                return false;
//            }

//            // If success, backup & update DB
//            foreach (var t in conflicts)
//            {
//                // Backup relevant rows before deletion
//                if (t.IsLab)
//                {
//                    using var b = new NpgsqlCommand(@"INSERT INTO labtimetable_backup SELECT * FROM labtimetable 
//                                                      WHERE lab_id=@id AND day=@day AND hour BETWEEN @s AND @e;", conn, tx);
//                    b.Parameters.AddWithValue("@id", t.LabId);
//                    b.Parameters.AddWithValue("@day", t.Day);
//                    b.Parameters.AddWithValue("@s", t.StartHour);
//                    b.Parameters.AddWithValue("@e", t.StartHour + t.Duration - 1);
//                    await b.ExecuteNonQueryAsync();

//                    using var d = new NpgsqlCommand(@"DELETE FROM labtimetable WHERE lab_id=@id AND day=@day AND hour BETWEEN @s AND @e;", conn, tx);
//                    d.Parameters.AddWithValue("@id", t.LabId);
//                    d.Parameters.AddWithValue("@day", t.Day);
//                    d.Parameters.AddWithValue("@s", t.StartHour);
//                    d.Parameters.AddWithValue("@e", t.StartHour + t.Duration - 1);
//                    await d.ExecuteNonQueryAsync();
//                }
//                else
//                {
//                    using var b = new NpgsqlCommand(@"INSERT INTO classtimetable_backup SELECT * FROM classtimetable 
//                                                      WHERE staff_code=@id AND day=@day AND hour BETWEEN @s AND @e;", conn, tx);
//                    b.Parameters.AddWithValue("@id", t.StaffAssigned);
//                    b.Parameters.AddWithValue("@day", t.Day);
//                    b.Parameters.AddWithValue("@s", t.StartHour);
//                    b.Parameters.AddWithValue("@e", t.StartHour + t.Duration - 1);
//                    await b.ExecuteNonQueryAsync();

//                    using var d = new NpgsqlCommand(@"DELETE FROM classtimetable WHERE staff_code=@id AND day=@day AND hour BETWEEN @s AND @e;", conn, tx);
//                    d.Parameters.AddWithValue("@id", t.StaffAssigned);
//                    d.Parameters.AddWithValue("@day", t.Day);
//                    d.Parameters.AddWithValue("@s", t.StartHour);
//                    d.Parameters.AddWithValue("@e", t.StartHour + t.Duration - 1);
//                    await d.ExecuteNonQueryAsync();
//                }
//                // Insert updated placement (new reschedule)
//                for (int h = t.StartHour; h < t.StartHour + t.Duration; h++)
//                {
//                    if (t.IsLab)
//                    {
//                        using var ins = new NpgsqlCommand(@"INSERT INTO labtimetable (lab_id, subject_code, subject_name, staff_name, department, year, semester, section, day, hour)
//                                                            VALUES (@lab,@sc,@sn,@st,'---','---','---','---',@day,@hr);", conn, tx);
//                        ins.Parameters.AddWithValue("@lab", t.LabId);
//                        ins.Parameters.AddWithValue("@sc", t.SubjectCode);
//                        ins.Parameters.AddWithValue("@sn", t.SubjectName);
//                        ins.Parameters.AddWithValue("@st", t.StaffAssigned);
//                        ins.Parameters.AddWithValue("@day", t.Day);
//                        ins.Parameters.AddWithValue("@hr", h);
//                        await ins.ExecuteNonQueryAsync();
//                    }
//                    else
//                    {
//                        using var ins = new NpgsqlCommand(@"INSERT INTO classtimetable (staff_name, staff_code, department_id, year, semester, section, day, hour, subject_code, subject_name)
//                                                            VALUES (@st,'---','---','---','---','---',@day,@hr,@sc,@sn);", conn, tx);
//                        ins.Parameters.AddWithValue("@st", t.StaffAssigned);
//                        ins.Parameters.AddWithValue("@day", t.Day);
//                        ins.Parameters.AddWithValue("@hr", h);
//                        ins.Parameters.AddWithValue("@sc", t.SubjectCode);
//                        ins.Parameters.AddWithValue("@sn", t.SubjectName);
//                        await ins.ExecuteNonQueryAsync();
//                    }
//                }
//            }

//            return true;
//        }

//        // Candidate generator for local repair
//        private IEnumerable<(string day, int start)> CandidatesLocal(List<dynamic> timetable, TaskUnit t)
//        {
//            string[] DAYS = new[] { "Mon", "Tue", "Wed", "Thu", "Fri" };
//            int HOURS = 7;
//            var daysShuffled = DAYS.OrderBy(_ => Guid.NewGuid()).ToArray();
//            var hours = Enumerable.Range(1, HOURS - t.Duration + 1).OrderBy(_ => Guid.NewGuid()).ToArray();
//            foreach (var d in daysShuffled)
//                foreach (var h in hours)
//                    if (!t.Tried.Contains((d, h)))
//                        yield return (d, h);
//        }

//        [HttpPost("generateCrossDepartmentTimetableBacktracking")]
//        public async Task<IActionResult> GenerateCrossDepartmentTimetableBacktracking([FromBody] TimetableRequest request)
//        {
//            var cs = _configuration.GetConnectionString("DefaultConnection");
//            await using var conn = new NpgsqlConnection(cs);
//            await conn.OpenAsync();
//            await using var tx = await conn.BeginTransactionAsync();

//            try
//            {
//                string[] DAYS = new[] { "Mon", "Tue", "Wed", "Thu", "Fri" };
//                int HOURS = Math.Max(1, request.TotalHoursPerDay);

//                (string staffName, string staffCode) SplitStaff(string staffAssigned)
//                {
//                    if (string.IsNullOrWhiteSpace(staffAssigned)) return ("---", "---");
//                    var name = staffAssigned;
//                    var code = staffAssigned;
//                    if (staffAssigned.Contains("("))
//                    {
//                        var parts = staffAssigned.Split('(', StringSplitOptions.TrimEntries);
//                        name = parts[0].Trim();
//                        code = parts.Length > 1 ? parts[1].Replace(")", "").Trim() : "---";
//                    }
//                    return (name, code);
//                }

//                // Prepare subjects ignoring those without staff assigned
//                var subjects = new List<(string code, string name, string type, int credit, string staff, string labId)>();
//                foreach (var s in request.Subjects ?? Enumerable.Empty<SubjectDto>())
//                {
//                    if (string.IsNullOrWhiteSpace(s.StaffAssigned)) continue;
//                    var type = (s.SubjectType ?? "theory").Trim().ToLower();
//                    subjects.Add((
//                        s.SubjectCode ?? "---",
//                        s.SubjectName ?? "---",
//                        type,
//                        s.Credit,
//                        s.StaffAssigned,
//                        (type == "lab" || type == "embedded") ? (s.LabId?.Trim()) : null
//                    ));
//                }
//                if (subjects.Count == 0)
//                    return BadRequest(new { message = "❌ No valid subjects found (missing staff)." });

//                var staffOcc = new Dictionary<string, Dictionary<string, HashSet<int>>>();
//                var labOcc = new Dictionary<string, Dictionary<string, HashSet<int>>>();

//                void EnsureDayMap<TKey>(Dictionary<TKey, Dictionary<string, HashSet<int>>> map, TKey key)
//                {
//                    if (!map.ContainsKey(key))
//                        map[key] = DAYS.ToDictionary(d => d, d => new HashSet<int>());
//                }

//                // Load staff occupancy
//                using (var cmd = new NpgsqlCommand("SELECT staff_code, day, hour FROM classtimetable", conn, tx))
//                using (var rd = await cmd.ExecuteReaderAsync())
//                {
//                    while (await rd.ReadAsync())
//                    {
//                        var sc = rd["staff_code"]?.ToString() ?? "---";
//                        var day = rd["day"]?.ToString() ?? "Mon";
//                        var hr = Convert.ToInt32(rd["hour"]);
//                        EnsureDayMap(staffOcc, sc);
//                        if (!staffOcc[sc].ContainsKey(day)) staffOcc[sc][day] = new HashSet<int>();
//                        staffOcc[sc][day].Add(hr);
//                    }
//                }
//                // Load lab occupancy
//                using (var cmd = new NpgsqlCommand("SELECT lab_id, day, hour FROM labtimetable", conn, tx))
//                using (var rd = await cmd.ExecuteReaderAsync())
//                {
//                    while (await rd.ReadAsync())
//                    {
//                        var lab = rd["lab_id"]?.ToString() ?? "---";
//                        var day = rd["day"]?.ToString() ?? "Mon";
//                        var hr = Convert.ToInt32(rd["hour"]);
//                        EnsureDayMap(labOcc, lab);
//                        if (!labOcc[lab].ContainsKey(day)) labOcc[lab][day] = new HashSet<int>();
//                        labOcc[lab][day].Add(hr);
//                    }
//                }

//                // Ensure all days map for staff and labs from subjects
//                foreach (var s in subjects)
//                {
//                    var (_, staffCode) = SplitStaff(s.staff);
//                    EnsureDayMap(staffOcc, staffCode);
//                    if (!string.IsNullOrEmpty(s.labId)) EnsureDayMap(labOcc, s.labId);
//                }

//                // Translate subjects into TaskUnits with constraints
//                var tasks = new List<TaskUnit>();
//                var labAllowedBlocks = new List<int[]> { new[] { 1, 2, 3, 4 }, new[] { 4, 5, 6, 7 } };
//                var embeddedLabAllowedBlocks = new List<int[]> {
//                    new[] { 1, 2 }, new[] { 2, 3 }, new[] { 3, 4 }, new[] { 5, 6 }, new[] { 6, 7 }
//                };

//                foreach (var s in subjects)
//                {
//                    switch (s.type)
//                    {
//                        case "lab":
//                            tasks.Add(new TaskUnit
//                            {
//                                SubjectCode = s.code,
//                                SubjectName = s.name,
//                                StaffAssigned = s.staff,
//                                LabId = s.labId,
//                                IsLab = true,
//                                Duration = 4,
//                                Kind = "LAB4"
//                            });
//                            break;
//                        case "embedded":
//                            tasks.Add(new TaskUnit
//                            {
//                                SubjectCode = s.code,
//                                SubjectName = s.name,
//                                StaffAssigned = s.staff,
//                                LabId = s.labId,
//                                IsLab = true,
//                                Duration = 2,
//                                Kind = "EMB_LAB2"
//                            });
//                            tasks.Add(new TaskUnit
//                            {
//                                SubjectCode = s.code,
//                                SubjectName = s.name,
//                                StaffAssigned = s.staff,
//                                LabId = null,
//                                IsLab = false,
//                                Duration = 1,
//                                Kind = "EMB_TH1"
//                            });
//                            tasks.Add(new TaskUnit
//                            {
//                                SubjectCode = s.code,
//                                SubjectName = s.name,
//                                StaffAssigned = s.staff,
//                                LabId = null,
//                                IsLab = false,
//                                Duration = 1,
//                                Kind = "EMB_TH1"
//                            });
//                            break;
//                        default:
//                            int count = Math.Max(0, s.credit);
//                            for (int i = 0; i < count; i++)
//                            {
//                                tasks.Add(new TaskUnit
//                                {
//                                    SubjectCode = s.code,
//                                    SubjectName = s.name,
//                                    StaffAssigned = s.staff,
//                                    LabId = null,
//                                    IsLab = false,
//                                    Duration = 1,
//                                    Kind = "TH1"
//                                });
//                            }
//                            break;
//                    }
//                }

//                // Initialize timetable grid: Dictionary {Day -> {Hour -> slot string}}
//                var timetable = DAYS.Select(d => new
//                {
//                    Day = d,
//                    Slots = Enumerable.Range(1, HOURS).ToDictionary(h => h, _ => "---")
//                }).ToList<dynamic>();

//                bool IsFreeInGrid(string day, int start, int duration)
//                {
//                    var row = timetable.First(t => t.Day == day).Slots;
//                    for (int h = start; h < start + duration; h++)
//                        if (h < 1 || h > HOURS || row[h] != "---") return false;
//                    return true;
//                }

//                void PlaceInGrid(string subjectCode, string staffAssigned, string day, int start, int duration)
//                {
//                    var row = timetable.First(t => t.Day == day).Slots;
//                    for (int h = start; h < start + duration; h++)
//                        row[h] = $"{subjectCode} ({staffAssigned})";
//                }

//                void RemoveFromGrid(string day, int start, int duration)
//                {
//                    var row = timetable.First(t => t.Day == day).Slots;
//                    for (int h = start; h < start + duration; h++)
//                        row[h] = "---";
//                }

//                // For embedded theory tasks: Keep track for non-adjacency
//                var embTheoryPlaced = new Dictionary<string, List<(string day, int hour)>>();

//                bool CanPlaceEmbeddedTheory(TaskUnit t, string day, int hour)
//                {
//                    if (!embTheoryPlaced.ContainsKey(t.SubjectCode)) return true;
//                    foreach (var (d, h) in embTheoryPlaced[t.SubjectCode])
//                    {
//                        if (d == day && (h == hour || h == hour - 1 || h == hour + 1))
//                            return false;
//                    }
//                    return true;
//                }

//                // Modified Fits with DB conflict detection and triggering Repair
//                bool Fits(TaskUnit t, string day, int start)
//                {
//                    if (!IsFreeInGrid(day, start, t.Duration)) return false;

//                    var (_, staffCode) = SplitStaff(t.StaffAssigned);

//                    // Check staff occupancy
//                    for (int h = start; h < start + t.Duration; h++)
//                    {
//                        if (staffOcc.TryGetValue(staffCode, out var dm) && dm.TryGetValue(day, out var set) && set.Contains(h))
//                        {
//                            // Try repairing conflicting DB tasks blocking staff at this slot
//                            if (!_repairAttempted)
//                            {
//                                _repairAttempted = true;
//                                var repaired = RepairConflictingDbTasks(conn, tx, staffOcc, labOcc, timetable, "staff", staffCode, day, h, Fits, Commit, Revert).GetAwaiter().GetResult(); // sync wait inside async method for simplicity
//                                if (!repaired)
//                                {
//                                    _conflictInfo = ("staff", staffCode, day, h);
//                                    throw new RepairFailedException();
//                                }
//                            }
//                            return false; // if repaired, occupancy map is updated, next calls will see free slot
//                        }
//                    }

//                    // Labs occupancy & block constraints
//                    if (t.IsLab)
//                    {
//                        if (!string.IsNullOrEmpty(t.LabId))
//                        {
//                            for (int h = start; h < start + t.Duration; h++)
//                            {
//                                if (labOcc.TryGetValue(t.LabId, out var dm) && dm.TryGetValue(day, out var set) && set.Contains(h))
//                                {
//                                    if (!_repairAttempted)
//                                    {
//                                        _repairAttempted = true;
//                                        var repaired = RepairConflictingDbTasks(conn, tx, staffOcc, labOcc, timetable, "lab", t.LabId, day, h, Fits, Commit, Revert).GetAwaiter().GetResult();
//                                        if (!repaired)
//                                        {
//                                            _conflictInfo = ("lab", t.LabId, day, h);
//                                            throw new RepairFailedException();
//                                        }
//                                    }
//                                    return false;
//                                }
//                            }
//                        }
//                        if (t.Kind == "LAB4")
//                        {
//                            if (!labAllowedBlocks.Any(block => block[0] == start && block.Length == t.Duration))
//                                return false;
//                        }
//                        if (t.Kind == "EMB_LAB2")
//                        {
//                            if (!embeddedLabAllowedBlocks.Any(block => block[0] == start && block.Length == t.Duration))
//                                return false;
//                        }
//                    }

//                    if (t.Kind == "EMB_TH1" && !CanPlaceEmbeddedTheory(t, day, start))
//                        return false;

//                    return true;
//                }

//                // Commit and Revert methods for placing/removing tasks
//                void Commit(TaskUnit t, string day, int start)
//                {
//                    t.Day = day;
//                    t.StartHour = start;
//                    var (_, staffCode) = SplitStaff(t.StaffAssigned);
//                    PlaceInGrid(t.SubjectCode, t.StaffAssigned, day, start, t.Duration);

//                    for (int h = start; h < start + t.Duration; h++)
//                        staffOcc[staffCode][day].Add(h);

//                    if (t.IsLab && !string.IsNullOrEmpty(t.LabId))
//                    {
//                        for (int h = start; h < start + t.Duration; h++)
//                            labOcc[t.LabId][day].Add(h);
//                    }
//                    if (t.Kind == "EMB_TH1")
//                    {
//                        if (!embTheoryPlaced.ContainsKey(t.SubjectCode))
//                            embTheoryPlaced[t.SubjectCode] = new List<(string, int)>();
//                        embTheoryPlaced[t.SubjectCode].Add((day, start));
//                    }
//                }

//                void Revert(TaskUnit t)
//                {
//                    var (_, staffCode) = SplitStaff(t.StaffAssigned);
//                    RemoveFromGrid(t.Day, t.StartHour, t.Duration);

//                    for (int h = t.StartHour; h < t.StartHour + t.Duration; h++)
//                        staffOcc[staffCode][t.Day].Remove(h);

//                    if (t.IsLab && !string.IsNullOrEmpty(t.LabId))
//                    {
//                        for (int h = t.StartHour; h < t.StartHour + t.Duration; h++)
//                            labOcc[t.LabId][t.Day].Remove(h);
//                    }

//                    if (t.Kind == "EMB_TH1" && embTheoryPlaced.ContainsKey(t.SubjectCode))
//                    {
//                        embTheoryPlaced[t.SubjectCode].RemoveAll(x => x.day == t.Day && x.hour == t.StartHour);
//                    }

//                    t.Tried.Add((t.Day, t.StartHour));
//                    t.Day = null;
//                    t.StartHour = 0;
//                }

//                // Candidate slots generators with randomization
//                IEnumerable<(string day, int start)> Candidates(TaskUnit t)
//                {
//                    var daysShuffled = DAYS.OrderBy(_ => Guid.NewGuid()).ToArray();
//                    var hours = Enumerable.Range(1, HOURS - t.Duration + 1).OrderBy(_ => Guid.NewGuid()).ToArray();
//                    foreach (var d in daysShuffled)
//                        foreach (var h in hours)
//                            if (!t.Tried.Contains((d, h)))
//                                yield return (d, h);
//                }

//                // State helpers for flow control of repair attempts & failure info
//                _repairAttempted = false;
//                _conflictInfo = null;

//                // Backtracking solver with integrated repair and failure abort
//                bool Solve(int idx)
//                {
//                    if (idx == tasks.Count) return true;
//                    var t = tasks[idx];

//                    foreach (var (day, start) in Candidates(t))
//                    {
//                        try
//                        {
//                            if (!Fits(t, day, start)) continue;
//                        }
//                        catch (RepairFailedException)
//                        {
//                            return false; // Repair failed - abort generation
//                        }

//                        Commit(t, day, start);
//                        if (Solve(idx + 1)) return true;
//                        Revert(t);
//                    }
//                    return false;
//                }

//                // Allowed lab blocks definitions for constraint checks used globally
//                var labAllowedBlocks1 = new List<int[]> { new[] { 1, 2, 3, 4 }, new[] { 4, 5, 6, 7 } };
//                var embeddedLabAllowedBlocks1 = new List<int[]> {
//                    new[] { 1, 2 }, new[] { 2, 3 }, new[] { 3, 4 }, new[] { 5, 6 }, new[] { 6, 7 }
//                };

//                // Run solver
//                var ok = Solve(0);
//                if (!ok)
//                {
//                    await tx.RollbackAsync();

//                    if (_conflictInfo != null)
//                    {
//                        var (conflictReason, conflictingId, conflictDay, conflictHour) = _conflictInfo.Value;
//                        return Ok(new
//                        {
//                            message = "❌ Timetable generation failed due to unsolvable conflicts after repair attempts.",
//                            conflictReason = conflictReason,
//                            conflictingId = conflictingId,
//                            day = conflictDay,
//                            hour = conflictHour,
//                            suggestion = "Please reassign staff or adjust hours manually."
//                        });
//                    }
//                    else
//                    {
//                        return Ok(new
//                        {
//                            message = "❌ Timetable generation failed - unable to place all tasks without conflicts."
//                        });
//                    }
//                }

//                // Commit all tasks to DB inside one transaction, backing up all original rows first
//                foreach (var t in tasks)
//                {
//                    var (staffName, staffCode) = SplitStaff(t.StaffAssigned);

//                    for (int h = t.StartHour; h < t.StartHour + t.Duration; h++)
//                    {
//                        using (var icClass = new NpgsqlCommand(@"
//                        INSERT INTO classtimetable
//                        (staff_name, staff_code, department_id, year, semester, section, day, hour, subject_code, subject_name)
//                        VALUES
//                        (@staff_name, @staff_code, @department, @year, @semester, @section, @day, @hour, @subject_code, @subject_name);", conn, tx))
//                        {
//                            icClass.Parameters.AddWithValue("@staff_name", staffName ?? "---");
//                            icClass.Parameters.AddWithValue("@staff_code", staffCode ?? "---");
//                            icClass.Parameters.AddWithValue("@department", request.Department ?? "---");
//                            icClass.Parameters.AddWithValue("@year", request.Year ?? "---");
//                            icClass.Parameters.AddWithValue("@semester", request.Semester ?? "---");
//                            icClass.Parameters.AddWithValue("@section", request.Section ?? "---");
//                            icClass.Parameters.AddWithValue("@day", t.Day ?? "---");
//                            icClass.Parameters.AddWithValue("@hour", h);
//                            icClass.Parameters.AddWithValue("@subject_code", t.SubjectCode ?? "---");
//                            icClass.Parameters.AddWithValue("@subject_name", t.SubjectName ?? "---");
//                            await icClass.ExecuteNonQueryAsync();
//                        }
//                    }

//                    if (t.IsLab && !string.IsNullOrEmpty(t.LabId))
//                    {
//                        // Back up original lab rows before insertion
//                        using var backupLab = new NpgsqlCommand(@"
//                            INSERT INTO labtimetable_backup SELECT * FROM labtimetable
//                            WHERE lab_id = @lab AND day = @day AND hour BETWEEN @start AND @end;", conn, tx);
//                        backupLab.Parameters.AddWithValue("@lab", t.LabId);
//                        backupLab.Parameters.AddWithValue("@day", t.Day);
//                        backupLab.Parameters.AddWithValue("@start", t.StartHour);
//                        backupLab.Parameters.AddWithValue("@end", t.StartHour + t.Duration - 1);
//                        await backupLab.ExecuteNonQueryAsync();

//                        // Delete original lab hours if any
//                        using var deleteLab = new NpgsqlCommand(@"
//                            DELETE FROM labtimetable
//                            WHERE lab_id = @lab AND day = @day AND hour BETWEEN @start AND @end;", conn, tx);
//                        deleteLab.Parameters.AddWithValue("@lab", t.LabId);
//                        deleteLab.Parameters.AddWithValue("@day", t.Day);
//                        deleteLab.Parameters.AddWithValue("@start", t.StartHour);
//                        deleteLab.Parameters.AddWithValue("@end", t.StartHour + t.Duration - 1);
//                        await deleteLab.ExecuteNonQueryAsync();

//                        // Insert new lab hours
//                        for (int h = t.StartHour; h < t.StartHour + t.Duration; h++)
//                        {
//                            // If lab starts at hour 4, only insert for hours 5, 6, 7
//                            if (t.StartHour == 4 && h == 4)
//                                continue; // Skip hour 4 in lab timetable

//                            using var icLab = new NpgsqlCommand(@"
//        INSERT INTO labtimetable
//        (lab_id, subject_code, subject_name, staff_name, department, year, semester, section, day, hour)
//        VALUES
//        (@lab_id, @subject_code, @subject_name, @staff_name, @department, @year, @semester, @section, @day, @hour);", conn, tx);

//                            icLab.Parameters.AddWithValue("@lab_id", t.LabId ?? (object)DBNull.Value);
//                            icLab.Parameters.AddWithValue("@subject_code", t.SubjectCode ?? "---");
//                            icLab.Parameters.AddWithValue("@subject_name", t.SubjectName ?? "---");
//                            icLab.Parameters.AddWithValue("@staff_name", staffName ?? "---");
//                            icLab.Parameters.AddWithValue("@department", request.Department ?? "---");
//                            icLab.Parameters.AddWithValue("@year", request.Year ?? "---");
//                            icLab.Parameters.AddWithValue("@semester", request.Semester ?? "---");
//                            icLab.Parameters.AddWithValue("@section", request.Section ?? "---");
//                            icLab.Parameters.AddWithValue("@day", t.Day ?? "---");
//                            icLab.Parameters.AddWithValue("@hour", h);
//                            await icLab.ExecuteNonQueryAsync();
//                        }

//                    }
//                }

//                await tx.CommitAsync();

//                var responseTimetable = timetable.Select(row => new
//                {
//                    Day = row.Day,
//                    HourlySlots = row.Slots
//                }).ToList();

//                return Ok(new
//                {
//                    message = "✅ Timetable generated with local repair and transaction rollback on failure, respecting all constraints.",
//                    timetable = responseTimetable,
//                    usedLabIds = tasks.Where(x => x.IsLab && !string.IsNullOrEmpty(x.LabId)).Select(x => x.LabId).Distinct().ToList(),
//                    receivedPayload = request
//                });
//            }
//            catch (RepairFailedException)
//            {
//                await tx.RollbackAsync();

//                if (_conflictInfo != null)
//                {
//                    var (conflictReason, conflictingId, conflictDay, conflictHour) = _conflictInfo.Value;
//                    return Ok(new
//                    {
//                        message = "❌ Timetable generation failed due to unrecoverable conflicts after repair attempts.",
//                        conflictReason = conflictReason,
//                        conflictingId = conflictingId,
//                        day = conflictDay,
//                        hour = conflictHour,
//                        suggestion = "Please reassign staff or adjust hours manually."
//                    });
//                }

//                return Ok(new { message = "❌ Timetable generation failed after repair attempts." });
//            }
//            catch (Exception ex)
//            {
//                await tx.RollbackAsync();
//                return StatusCode(500, new { message = "❌ Internal Server Error while generating timetable.", error = ex.Message });
//            }
//        }

//        // Exception to signal that repair failed and generation must stop
//        private class RepairFailedException : Exception { }

//        // Tracker flags for repair attempt and failure info
//        private bool _repairAttempted = false;
//        private (string reason, string conflictingId, string day, int hour)? _conflictInfo = null;

//        // Allowed continuous blocks helpers for constraints used inside Fits
//        private static readonly List<int[]> labAllowedBlocks = new List<int[]> { new[] { 1, 2, 3, 4 }, new[] { 4, 5, 6, 7 } };
//        private static readonly List<int[]> embeddedLabAllowedBlocks = new List<int[]> {
//            new[] { 1, 2 }, new[] { 2, 3 }, new[] { 3, 4 }, new[] { 5, 6 }, new[] { 6, 7 }
//        };
//    }
//}

//tabu search
//using Microsoft.AspNetCore.Mvc;
//using Microsoft.Extensions.Configuration;
//using Npgsql;
//using System;
//using System.Collections.Generic;
//using System.Linq;
//using System.Threading.Tasks;

//namespace Timetablegenerator.Controllers
//{
//    [ApiController]
//    [Route("api/[controller]")]
//    public class TimetableController : ControllerBase
//    {
//        private readonly IConfiguration _configuration;
//        public TimetableController(IConfiguration configuration)
//        {
//            _configuration = configuration;
//        }

//        // DTO Classes
//        public class TimetableRequest
//        {
//            public string Department { get; set; }
//            public string Year { get; set; }
//            public string Semester { get; set; }
//            public string Section { get; set; }
//            public int TotalHoursPerDay { get; set; } = 7;
//            public List<SubjectDto> Subjects { get; set; }
//        }

//        public class SubjectDto
//        {
//            public string SubjectCode { get; set; }
//            public string SubjectName { get; set; }
//            public string SubjectType { get; set; }
//            public int Credit { get; set; }
//            public string StaffAssigned { get; set; }
//            public string LabId { get; set; }
//        }

//        public class TaskUnit
//        {
//            public string SubjectCode;
//            public string SubjectName;
//            public string StaffAssigned;
//            public string LabId;
//            public bool IsLab;
//            public int Duration;
//            public string Kind;
//            public string Day;
//            public int StartHour;
//            public bool IsPlaced = false;
//        }

//        [HttpPost("generateCrossDepartmentTimetableBacktracking")]
//        public async Task<IActionResult> GenerateCrossDepartmentTimetableTabuSearch([FromBody] TimetableRequest request)
//        {
//            var cs = _configuration.GetConnectionString("DefaultConnection");

//            try
//            {
//                string[] DAYS = new[] { "Mon", "Tue", "Wed", "Thu", "Fri" };
//                int HOURS = Math.Max(1, request.TotalHoursPerDay);

//                (string staffName, string staffCode) SplitStaff(string staffAssigned)
//                {
//                    if (string.IsNullOrWhiteSpace(staffAssigned)) return ("---", "---");
//                    var name = staffAssigned;
//                    var code = staffAssigned;
//                    if (staffAssigned.Contains("("))
//                    {
//                        var parts = staffAssigned.Split('(', StringSplitOptions.TrimEntries);
//                        name = parts[0].Trim();
//                        code = parts.Length > 1 ? parts[1].Replace(")", "").Trim() : "---";
//                    }
//                    return (name, code);
//                }

//                var subjects = new List<(string code, string name, string type, int credit, string staff, string labId)>();
//                foreach (var s in request.Subjects ?? Enumerable.Empty<SubjectDto>())
//                {
//                    if (string.IsNullOrWhiteSpace(s.StaffAssigned)) continue;
//                    var type = (s.SubjectType ?? "theory").Trim().ToLower();
//                    subjects.Add((
//                        s.SubjectCode ?? "---",
//                        s.SubjectName ?? "---",
//                        type,
//                        s.Credit,
//                        s.StaffAssigned,
//                        (type == "lab" || type == "embedded") ? (s.LabId?.Trim()) : null
//                    ));
//                }
//                if (subjects.Count == 0)
//                    return BadRequest(new { message = "❌ No valid subjects found (missing staff)." });

//                var staffOcc = new Dictionary<string, Dictionary<string, HashSet<int>>>();
//                var labOcc = new Dictionary<string, Dictionary<string, HashSet<int>>>();
//                using var conn = new NpgsqlConnection(cs);
//                await conn.OpenAsync();

//                void EnsureDayMap<TKey>(Dictionary<TKey, Dictionary<string, HashSet<int>>> map, TKey key)
//                {
//                    if (!map.ContainsKey(key))
//                        map[key] = DAYS.ToDictionary(d => d, d => new HashSet<int>());
//                }

//                // Load existing occupancy
//                using (var cmd = new NpgsqlCommand("SELECT staff_code, day, hour FROM classtimetable", conn))
//                using (var rd = await cmd.ExecuteReaderAsync())
//                {
//                    while (await rd.ReadAsync())
//                    {
//                        var sc = rd["staff_code"]?.ToString() ?? "---";
//                        var day = rd["day"]?.ToString() ?? "Mon";
//                        var hr = Convert.ToInt32(rd["hour"]);
//                        EnsureDayMap(staffOcc, sc);
//                        if (!staffOcc[sc].ContainsKey(day)) staffOcc[sc][day] = new HashSet<int>();
//                        staffOcc[sc][day].Add(hr);
//                    }
//                }
//                using (var cmd = new NpgsqlCommand("SELECT lab_id, day, hour FROM labtimetable", conn))
//                using (var rd = await cmd.ExecuteReaderAsync())
//                {
//                    while (await rd.ReadAsync())
//                    {
//                        var lab = rd["lab_id"]?.ToString() ?? "---";
//                        var day = rd["day"]?.ToString() ?? "Mon";
//                        var hr = Convert.ToInt32(rd["hour"]);
//                        EnsureDayMap(labOcc, lab);
//                        if (!labOcc[lab].ContainsKey(day)) labOcc[lab][day] = new HashSet<int>();
//                        labOcc[lab][day].Add(hr);
//                    }
//                }
//                foreach (var s in subjects)
//                {
//                    var (_, staffCode) = SplitStaff(s.staff);
//                    EnsureDayMap(staffOcc, staffCode);
//                    if (!string.IsNullOrEmpty(s.labId)) EnsureDayMap(labOcc, s.labId);
//                }

//                // Translate subjects to tasks similarly as before
//                var tasks = new List<TaskUnit>();
//                var labAllowedBlocks = new List<int[]> { new[] { 1, 2, 3, 4 }, new[] { 4, 5, 6, 7 } };
//                var embeddedLabAllowedBlocks = new List<int[]> {
//                    new[] { 1, 2 },
//                    new[] { 2, 3 },
//                    new[] { 3, 4 },
//                    new[] { 5, 6 },
//                    new[] { 6, 7 }
//                };
//                foreach (var s in subjects)
//                {
//                    switch (s.type)
//                    {
//                        case "lab":
//                            tasks.Add(new TaskUnit
//                            {
//                                SubjectCode = s.code,
//                                SubjectName = s.name,
//                                StaffAssigned = s.staff,
//                                LabId = s.labId,
//                                IsLab = true,
//                                Duration = 4,
//                                Kind = "LAB4"
//                            });
//                            break;
//                        case "embedded":
//                            tasks.Add(new TaskUnit
//                            {
//                                SubjectCode = s.code,
//                                SubjectName = s.name,
//                                StaffAssigned = s.staff,
//                                LabId = s.labId,
//                                IsLab = true,
//                                Duration = 2,
//                                Kind = "EMB_LAB2"
//                            });
//                            tasks.Add(new TaskUnit
//                            {
//                                SubjectCode = s.code,
//                                SubjectName = s.name,
//                                StaffAssigned = s.staff,
//                                IsLab = false,
//                                Duration = 1,
//                                Kind = "EMB_TH1"
//                            });
//                            tasks.Add(new TaskUnit
//                            {
//                                SubjectCode = s.code,
//                                SubjectName = s.name,
//                                StaffAssigned = s.staff,
//                                IsLab = false,
//                                Duration = 1,
//                                Kind = "EMB_TH1"
//                            });
//                            break;
//                        default:
//                            int count = Math.Max(0, s.credit);
//                            for (int i = 0; i < count; i++)
//                            {
//                                tasks.Add(new TaskUnit
//                                {
//                                    SubjectCode = s.code,
//                                    SubjectName = s.name,
//                                    StaffAssigned = s.staff,
//                                    IsLab = false,
//                                    Duration = 1,
//                                    Kind = "TH1"
//                                });
//                            }
//                            break;
//                    }
//                }

//                // Initialize timetable grid from DB snapshot to preserve existing schedule
//                var timetable = DAYS.ToDictionary(d => d,
//                    d => Enumerable.Range(1, HOURS).ToDictionary(h => h, _ => "---"));

//                // Helper functions similar to before
//                bool IsFreeInGrid(string day, int start, int duration)
//                {
//                    var row = timetable[day];
//                    for (int h = start; h < start + duration; h++)
//                        if (h < 1 || h > HOURS || row[h] != "---") return false;
//                    return true;
//                }

//                bool CanPlace(TaskUnit t, string day, int start)
//                {
//                    if (!IsFreeInGrid(day, start, t.Duration)) return false;

//                    var (_, staffCode) = SplitStaff(t.StaffAssigned);

//                    for (int h = start; h < start + t.Duration; h++)
//                    {
//                        if (staffOcc.TryGetValue(staffCode, out var dm) && dm.TryGetValue(day, out var set) && set.Contains(h))
//                            return false;
//                        if (t.IsLab && !string.IsNullOrEmpty(t.LabId)
//                            && labOcc.TryGetValue(t.LabId, out var ldm) && ldm.TryGetValue(day, out var lset) && lset.Contains(h))
//                            return false;
//                    }

//                    if (t.IsLab)
//                    {
//                        if (t.Kind == "LAB4")
//                        {
//                            if (!labAllowedBlocks.Any(block => block[0] == start && block.Length == t.Duration))
//                                return false;
//                        }
//                        else if (t.Kind == "EMB_LAB2")
//                        {
//                            if (!embeddedLabAllowedBlocks.Any(block => block[0] == start && block.Length == t.Duration))
//                                return false;
//                        }
//                    }

//                    return true;
//                }

//                // Place and Remove functions update timetable and occupancy
//                void Place(TaskUnit t, string day, int start)
//                {
//                    var row = timetable[day];
//                    var (_, staffCode) = SplitStaff(t.StaffAssigned);

//                    for (int h = start; h < start + t.Duration; h++)
//                    {
//                        row[h] = $"{t.SubjectCode} ({t.StaffAssigned})";
//                        staffOcc[staffCode][day].Add(h);
//                        if (t.IsLab && !string.IsNullOrEmpty(t.LabId))
//                            labOcc[t.LabId][day].Add(h);
//                    }

//                    t.Day = day;
//                    t.StartHour = start;
//                    t.IsPlaced = true;
//                }

//                void Remove(TaskUnit t)
//                {
//                    if (!t.IsPlaced) return;
//                    var row = timetable[t.Day];
//                    var (_, staffCode) = SplitStaff(t.StaffAssigned);

//                    for (int h = t.StartHour; h < t.StartHour + t.Duration; h++)
//                    {
//                        row[h] = "---";
//                        staffOcc[staffCode][t.Day].Remove(h);
//                        if (t.IsLab && !string.IsNullOrEmpty(t.LabId))
//                            labOcc[t.LabId][t.Day].Remove(h);
//                    }

//                    t.IsPlaced = false;
//                    t.Day = null;
//                    t.StartHour = 0;
//                }

//                Random rnd = new Random();

//                // Tabu List to temporarily forbid recent moves to avoid cycling
//                var tabuList = new Queue<(TaskUnit task, string day, int start)>();
//                int tabuTenure = 7; // Number of iterations a move remains tabu

//                // For iterative improvement: assign random initial placements where possible
//                foreach (var task in tasks)
//                {
//                    var possibleSlots = new List<(string day, int start)>();
//                    foreach (var day in DAYS)
//                    {
//                        for (int hour = 1; hour <= HOURS - task.Duration + 1; hour++)
//                        {
//                            if (CanPlace(task, day, hour))
//                                possibleSlots.Add((day, hour));
//                        }
//                    }
//                    if (possibleSlots.Count == 0)
//                    {
//                        // No feasible slot for this task => fail generation, inform user
//                        return Ok(new
//                        {
//                            message = $"⚠ Cannot place task {task.SubjectCode} {task.SubjectName} without conflicts. Please adjust inputs.",
//                            receivedPayload = request
//                        });
//                    }
//                    // Place randomly initially
//                    var choice = possibleSlots[rnd.Next(possibleSlots.Count)];
//                    Place(task, choice.day, choice.start);
//                }

//                // Now attempt to improve by trying to fix conflicts and remove tabu moves
//                int maxIterations = 1000;
//                bool improvement;
//                for (int iter = 0; iter < maxIterations; iter++)
//                {
//                    improvement = false;

//                    foreach (var task in tasks)
//                    {
//                        // Try to find a better slot if any conflicts appear (rare here since placed validly)
//                        // Here we simulate local search by trying to move task to another feasible slot with tabu check

//                        var candidates = new List<(string day, int start)>();
//                        foreach (var day in DAYS)
//                        {
//                            for (int hour = 1; hour <= HOURS - task.Duration + 1; hour++)
//                            {
//                                if (CanPlace(task, day, hour) && !tabuList.Contains((task, day, hour)))
//                                    candidates.Add((day, hour));
//                            }
//                        }

//                        if (candidates.Count > 0)
//                        {
//                            var currentPos = (task.Day, task.StartHour);
//                            var newPos = candidates[rnd.Next(candidates.Count)];

//                            // Move to new position
//                            Remove(task);
//                            Place(task, newPos.day, newPos.start);
//                            tabuList.Enqueue((task, currentPos.Item1, currentPos.Item2));
//                            if (tabuList.Count > tabuTenure) tabuList.Dequeue();

//                            improvement = true;
//                        }
//                    }

//                    if (!improvement)
//                        break;
//                }

//                // After iterations, check feasibility of entire timetable (no conflicts)
//                foreach (var task in tasks)
//                {
//                    if (!task.IsPlaced)
//                    {
//                        return Ok(new
//                        {
//                            message = "⚠ Could not resolve scheduling conflicts after local search.",
//                            receivedPayload = request
//                        });
//                    }
//                }

//                // Write timetable data to DB inside a transaction; if any error, rollback without changes
//                using (var tran = conn.BeginTransaction())
//                {
//                    // Delete previous timetable data for this department+year+semester+section to avoid duplication
//                    using (var delClass = new NpgsqlCommand(@"
//                        DELETE FROM classtimetable 
//                        WHERE department_id=@department AND year=@year AND semester=@semester AND section=@section;", conn, tran))
//                    {
//                        delClass.Parameters.AddWithValue("@department", request.Department ?? "---");
//                        delClass.Parameters.AddWithValue("@year", request.Year ?? "---");
//                        delClass.Parameters.AddWithValue("@semester", request.Semester ?? "---");
//                        delClass.Parameters.AddWithValue("@section", request.Section ?? "---");
//                        await delClass.ExecuteNonQueryAsync();
//                    }
//                    using (var delLab = new NpgsqlCommand(@"
//                        DELETE FROM labtimetable
//                        WHERE department=@department AND year=@year AND semester=@semester AND section=@section;", conn, tran))
//                    {
//                        delLab.Parameters.AddWithValue("@department", request.Department ?? "---");
//                        delLab.Parameters.AddWithValue("@year", request.Year ?? "---");
//                        delLab.Parameters.AddWithValue("@semester", request.Semester ?? "---");
//                        delLab.Parameters.AddWithValue("@section", request.Section ?? "---");
//                        await delLab.ExecuteNonQueryAsync();
//                    }

//                    foreach (var t in tasks)
//                    {
//                        var (staffName, staffCode) = SplitStaff(t.StaffAssigned);

//                        for (int h = t.StartHour; h < t.StartHour + t.Duration; h++)
//                        {
//                            using (var icClass = new NpgsqlCommand(@"
//                                INSERT INTO classtimetable
//                                (staff_name, staff_code, department_id, year, semester, section, day, hour, subject_code, subject_name)
//                                VALUES
//                                (@staff_name, @staff_code, @department, @year, @semester, @section, @day, @hour, @subject_code, @subject_name);", conn, tran))
//                            {
//                                icClass.Parameters.AddWithValue("@staff_name", staffName ?? "---");
//                                icClass.Parameters.AddWithValue("@staff_code", staffCode ?? "---");
//                                icClass.Parameters.AddWithValue("@department", request.Department ?? "---");
//                                icClass.Parameters.AddWithValue("@year", request.Year ?? "---");
//                                icClass.Parameters.AddWithValue("@semester", request.Semester ?? "---");
//                                icClass.Parameters.AddWithValue("@section", request.Section ?? "---");
//                                icClass.Parameters.AddWithValue("@day", t.Day ?? "---");
//                                icClass.Parameters.AddWithValue("@hour", h);
//                                icClass.Parameters.AddWithValue("@subject_code", t.SubjectCode ?? "---");
//                                icClass.Parameters.AddWithValue("@subject_name", t.SubjectName ?? "---");
//                                await icClass.ExecuteNonQueryAsync();
//                            }
//                        }
//                        if (t.IsLab && !string.IsNullOrEmpty(t.LabId))
//                        {
//                            int labStart = t.StartHour;
//                            if (labStart == 4)
//                            {
//                                labStart = 5; // Adjust as per your logic
//                            }
//                            for (int h = labStart; h < t.StartHour + t.Duration; h++)
//                            {
//                                using (var icLab = new NpgsqlCommand(@"
//                                    INSERT INTO labtimetable
//                                    (lab_id, subject_code, subject_name, staff_name, department, year, semester, section, day, hour)
//                                    VALUES
//                                    (@lab_id, @subject_code, @subject_name, @staff_name, @department, @year, @semester, @section, @day, @hour);", conn, tran))
//                                {
//                                    icLab.Parameters.AddWithValue("@lab_id", t.LabId ?? (object)DBNull.Value);
//                                    icLab.Parameters.AddWithValue("@subject_code", t.SubjectCode ?? "---");
//                                    icLab.Parameters.AddWithValue("@subject_name", t.SubjectName ?? "---");
//                                    icLab.Parameters.AddWithValue("@staff_name", staffName ?? "---");
//                                    icLab.Parameters.AddWithValue("@department", request.Department ?? "---");
//                                    icLab.Parameters.AddWithValue("@year", request.Year ?? "---");
//                                    icLab.Parameters.AddWithValue("@semester", request.Semester ?? "---");
//                                    icLab.Parameters.AddWithValue("@section", request.Section ?? "---");
//                                    icLab.Parameters.AddWithValue("@day", t.Day ?? "---");
//                                    icLab.Parameters.AddWithValue("@hour", h);
//                                    await icLab.ExecuteNonQueryAsync();
//                                }
//                            }
//                        }
//                    }
//                    await tran.CommitAsync();
//                }

//                // Prepare response schedule view
//                var responseTimetable = timetable.Select(row => new
//                {
//                    Day = row.Key,
//                    HourlySlots = row.Value
//                }).ToList();

//                return Ok(new
//                {
//                    message = "✅ Timetable generated successfully with Tabu Search local search optimization.",
//                    timetable = responseTimetable,
//                    usedLabIds = tasks.Where(x => x.IsLab && !string.IsNullOrEmpty(x.LabId)).Select(x => x.LabId).Distinct().ToList(),
//                    receivedPayload = request
//                });
//            }
//            catch (Exception ex)
//            {
//                return StatusCode(500, new { message = "❌ Internal Server Error while generating timetable.", error = ex.Message });
//            }
//        }
//    }
//}











//perfect without shuffle
//using Microsoft.AspNetCore.Mvc;
//using Microsoft.Extensions.Configuration;
//using Npgsql;
//using System;
//using System.Collections.Generic;
//using System.Linq;
//using System.Threading.Tasks;

//namespace Timetablegenerator.Controllers
//{
//    [ApiController]
//    [Route("api/[controller]")]
//    public class TimetableController : ControllerBase
//    {
//        private readonly IConfiguration _configuration;
//        public TimetableController(IConfiguration configuration)
//        {
//            _configuration = configuration;
//        }

//        // DTO Classes
//        public class TimetableRequest
//        {
//            public string Department { get; set; }
//            public string Year { get; set; }
//            public string Semester { get; set; }
//            public string Section { get; set; }
//            public int TotalHoursPerDay { get; set; } = 7;
//            public List<SubjectDto> Subjects { get; set; }
//        }
//        public class SubjectDto
//        {
//            public string SubjectCode { get; set; }
//            public string SubjectName { get; set; }
//            public string SubjectType { get; set; }
//            public int Credit { get; set; }
//            public string StaffAssigned { get; set; }
//            public string LabId { get; set; }
//        }
//        public class TaskUnit
//        {
//            public string SubjectCode;
//            public string SubjectName;
//            public string StaffAssigned;
//            public string LabId;
//            public bool IsLab;
//            public int Duration;
//            public string Kind;
//            public string Day;      // Assigned day
//            public int StartHour;   // Assigned start hour
//            public bool IsPlaced = false;

//            // Domain holds all possible (day, start) positions this task can be assigned for constraint propagation
//            public List<(string day, int start)> Domain = new();
//        }

//        [HttpPost("generateCrossDepartmentTimetableBacktracking")]
//        public async Task<IActionResult> GenerateCrossDepartmentTimetableBacktracking([FromBody] TimetableRequest request)
//        {
//            var cs = _configuration.GetConnectionString("DefaultConnection");
//            try
//            {
//                string[] DAYS = new[] { "Mon", "Tue", "Wed", "Thu", "Fri" };
//                int HOURS = Math.Max(1, request.TotalHoursPerDay);

//                (string staffName, string staffCode) SplitStaff(string staffAssigned)
//                {
//                    if (string.IsNullOrWhiteSpace(staffAssigned)) return ("---", "---");
//                    var name = staffAssigned;
//                    var code = staffAssigned;
//                    if (staffAssigned.Contains("("))
//                    {
//                        var parts = staffAssigned.Split('(', StringSplitOptions.TrimEntries);
//                        name = parts[0].Trim();
//                        code = parts.Length > 1 ? parts[1].Replace(")", "").Trim() : "---";
//                    }
//                    return (name, code);
//                }

//                var subjects = new List<(string code, string name, string type, int credit, string staff, string labId)>();
//                foreach (var s in request.Subjects ?? Enumerable.Empty<SubjectDto>())
//                {
//                    if (string.IsNullOrWhiteSpace(s.StaffAssigned)) continue;
//                    var type = (s.SubjectType ?? "theory").Trim().ToLower();
//                    subjects.Add((
//                        s.SubjectCode ?? "---",
//                        s.SubjectName ?? "---",
//                        type,
//                        s.Credit,
//                        s.StaffAssigned,
//                        (type == "lab" || type == "embedded") ? (s.LabId?.Trim()) : null
//                    ));
//                }

//                if (subjects.Count == 0)
//                    return BadRequest(new { message = "❌ No valid subjects found (missing staff)." });

//                using var conn = new NpgsqlConnection(cs);
//                await conn.OpenAsync();

//                // Load existing occupancy from DB - staff and lab occupancy to consider pre-existing timetable blocks
//                var staffOcc = new Dictionary<string, Dictionary<string, HashSet<int>>>();
//                var labOcc = new Dictionary<string, Dictionary<string, HashSet<int>>>();
//                void EnsureDayMap<TKey>(Dictionary<TKey, Dictionary<string, HashSet<int>>> map, TKey key)
//                {
//                    if (!map.ContainsKey(key))
//                        map[key] = DAYS.ToDictionary(d => d, d => new HashSet<int>());
//                }

//                // Load existing staff occupancy
//                using (var cmd = new NpgsqlCommand("SELECT staff_code, day, hour FROM classtimetable", conn))
//                using (var rd = await cmd.ExecuteReaderAsync())
//                {
//                    while (await rd.ReadAsync())
//                    {
//                        var sc = rd["staff_code"]?.ToString() ?? "---";
//                        var day = rd["day"]?.ToString() ?? "Mon";
//                        var hr = Convert.ToInt32(rd["hour"]);
//                        EnsureDayMap(staffOcc, sc);
//                        if (!staffOcc[sc].ContainsKey(day)) staffOcc[sc][day] = new HashSet<int>();
//                        staffOcc[sc][day].Add(hr);
//                    }
//                }

//                // Load existing lab occupancy
//                using (var cmd = new NpgsqlCommand("SELECT lab_id, day, hour FROM labtimetable", conn))
//                using (var rd = await cmd.ExecuteReaderAsync())
//                {
//                    while (await rd.ReadAsync())
//                    {
//                        var lab = rd["lab_id"]?.ToString() ?? "---";
//                        var day = rd["day"]?.ToString() ?? "Mon";
//                        var hr = Convert.ToInt32(rd["hour"]);
//                        EnsureDayMap(labOcc, lab);
//                        if (!labOcc[lab].ContainsKey(day)) labOcc[lab][day] = new HashSet<int>();
//                        labOcc[lab][day].Add(hr);
//                    }
//                }

//                // Ensure all relevant keys in occupancy dictionaries
//                foreach (var s in subjects)
//                {
//                    var (_, staffCode) = SplitStaff(s.staff);
//                    EnsureDayMap(staffOcc, staffCode);
//                    if (!string.IsNullOrEmpty(s.labId)) EnsureDayMap(labOcc, s.labId);
//                }

//                // Translate subjects to TaskUnits to be scheduled
//                var tasks = new List<TaskUnit>();
//                var labAllowedBlocks = new List<int[]> { new[] { 1, 2, 3, 4 }, new[] { 4, 5, 6, 7 } };
//                var embeddedLabAllowedBlocks = new List<int[]> {
//                    new[] { 1, 2 },
//                    new[] { 2, 3 },
//                    new[] { 3, 4 },
//                    new[] { 5, 6 },
//                    new[] { 6, 7 }
//                };
//                foreach (var s in subjects)
//                {
//                    switch (s.type)
//                    {
//                        case "lab":
//                            tasks.Add(new TaskUnit
//                            {
//                                SubjectCode = s.code,
//                                SubjectName = s.name,
//                                StaffAssigned = s.staff,
//                                LabId = s.labId,
//                                IsLab = true,
//                                Duration = 4,
//                                Kind = "LAB4"
//                            });
//                            break;
//                        case "embedded":
//                            tasks.Add(new TaskUnit
//                            {
//                                SubjectCode = s.code,
//                                SubjectName = s.name,
//                                StaffAssigned = s.staff,
//                                LabId = s.labId,
//                                IsLab = true,
//                                Duration = 2,
//                                Kind = "EMB_LAB2"
//                            });
//                            tasks.Add(new TaskUnit
//                            {
//                                SubjectCode = s.code,
//                                SubjectName = s.name,
//                                StaffAssigned = s.staff,
//                                IsLab = false,
//                                Duration = 1,
//                                Kind = "EMB_TH1"
//                            });
//                            tasks.Add(new TaskUnit
//                            {
//                                SubjectCode = s.code,
//                                SubjectName = s.name,
//                                StaffAssigned = s.staff,
//                                IsLab = false,
//                                Duration = 1,
//                                Kind = "EMB_TH1"
//                            });
//                            break;
//                        default:
//                            int count = Math.Max(0, s.credit);
//                            for (int i = 0; i < count; i++)
//                            {
//                                tasks.Add(new TaskUnit
//                                {
//                                    SubjectCode = s.code,
//                                    SubjectName = s.name,
//                                    StaffAssigned = s.staff,
//                                    IsLab = false,
//                                    Duration = 1,
//                                    Kind = "TH1"
//                                });
//                            }
//                            break;
//                    }
//                }

//                // Initialize timetable grid as dictionary for return formatting
//                var timetable = DAYS.ToDictionary(d => d,
//                    d => Enumerable.Range(1, HOURS).ToDictionary(h => h, _ => "---"));

//                // Check if start hour fits duration and allowed lab blocks for lab tasks
//                bool IsValidStartForLab(TaskUnit t, int start)
//                {
//                    if (t.Kind == "LAB4")
//                        return labAllowedBlocks.Any(b => b[0] == start && b.Length == t.Duration);
//                    if (t.Kind == "EMB_LAB2")
//                        return embeddedLabAllowedBlocks.Any(b => b[0] == start && b.Length == t.Duration);
//                    return true;
//                }

//                // Return true if time slots are free in timetable grid and no conflicts exist for staff and lab
//                bool IsFreeAndNoConflict(TaskUnit t, string day, int start,
//                    Dictionary<string, Dictionary<string, HashSet<int>>> staffOccMap,
//                    Dictionary<string, Dictionary<string, HashSet<int>>> labOccMap)
//                {
//                    // Check timetable grid free
//                    for (int h = start; h < start + t.Duration; h++)
//                    {
//                        if (h < 1 || h > HOURS) return false;
//                        if (timetable[day][h] != "---") return false;
//                    }
//                    var (_, staffCode) = SplitStaff(t.StaffAssigned);

//                    // Check staff is free at all hours
//                    for (int h = start; h < start + t.Duration; h++)
//                    {
//                        if (staffOccMap.TryGetValue(staffCode, out var dayMap) && dayMap.TryGetValue(day, out var hoursSet) && hoursSet.Contains(h))
//                            return false;
//                    }

//                    // If lab, also check lab availability
//                    if (t.IsLab && !string.IsNullOrEmpty(t.LabId))
//                    {
//                        for (int h = start; h < start + t.Duration; h++)
//                        {
//                            if (labOccMap.TryGetValue(t.LabId, out var labDayMap) && labDayMap.TryGetValue(day, out var hoursSet) && hoursSet.Contains(h))
//                                return false;
//                        }
//                        // Check allowed lab start blocks
//                        if (!IsValidStartForLab(t, start))
//                            return false;
//                    }

//                    return true;
//                }

//                // Constraint Propagation using AC-3-style filtering of domains
//                // We maintain domain of each task as allowed (day, start) pairs
//                // At each assignment, domains of other tasks are reduced to discard conflicting slots
//                // This early pruning helps avoid hopeless paths.

//                // Build initial domains for each task (all feasible slots)
//                foreach (var t in tasks)
//                {
//                    t.Domain.Clear();
//                    foreach (var day in DAYS)
//                    {
//                        for (int h = 1; h <= HOURS - t.Duration + 1; h++)
//                        {
//                            if (IsFreeAndNoConflict(t, day, h, staffOcc, labOcc))
//                            {
//                                t.Domain.Add((day, h));
//                            }
//                        }
//                    }

//                    if (t.Domain.Count == 0)
//                    {
//                        // If any task has empty domain initially, fail now.
//                        return Ok(new
//                        {
//                            message = $"⚠ No feasible slot initially for task {t.SubjectCode} {t.SubjectName}. Cannot generate timetable.",
//                            receivedPayload = request
//                        });
//                    }
//                }

//                // Updates timetable & occupancy on assignment
//                void AssignTask(TaskUnit t, (string day, int start) slot)
//                {
//                    var (day, start) = slot;
//                    var (_, staffCode) = SplitStaff(t.StaffAssigned);

//                    for (int h = start; h < start + t.Duration; h++)
//                    {
//                        timetable[day][h] = $"{t.SubjectCode} ({t.StaffAssigned})";
//                        if (!staffOcc.ContainsKey(staffCode)) staffOcc[staffCode] = new Dictionary<string, HashSet<int>>();
//                        if (!staffOcc[staffCode].ContainsKey(day)) staffOcc[staffCode][day] = new HashSet<int>();
//                        staffOcc[staffCode][day].Add(h);

//                        if (t.IsLab && !string.IsNullOrEmpty(t.LabId))
//                        {
//                            if (!labOcc.ContainsKey(t.LabId)) labOcc[t.LabId] = new Dictionary<string, HashSet<int>>();
//                            if (!labOcc[t.LabId].ContainsKey(day)) labOcc[t.LabId][day] = new HashSet<int>();
//                            labOcc[t.LabId][day].Add(h);
//                        }
//                    }
//                    t.Day = day;
//                    t.StartHour = start;
//                    t.IsPlaced = true;
//                }

//                // Removes timetable & occupancy on unassignment
//                void UnassignTask(TaskUnit t)
//                {
//                    if (!t.IsPlaced) return;
//                    var day = t.Day;
//                    var start = t.StartHour;
//                    var (_, staffCode) = SplitStaff(t.StaffAssigned);

//                    for (int h = start; h < start + t.Duration; h++)
//                    {
//                        timetable[day][h] = "---";
//                        staffOcc[staffCode][day].Remove(h);

//                        if (t.IsLab && !string.IsNullOrEmpty(t.LabId))
//                        {
//                            labOcc[t.LabId][day].Remove(h);
//                        }
//                    }
//                    t.IsPlaced = false;
//                    t.Day = null;
//                    t.StartHour = 0;
//                }

//                // Forward checking / domain filtering after assigning task t with slot assignedSlot
//                // This implements constraint propagation to remove impossible options for other tasks
//                bool PropagateConstraints(List<TaskUnit> tasksList, TaskUnit assignedTask, (string day, int start) assignedSlot)
//                {
//                    // We create a copy of domains to roll back if needed
//                    var snapshotDomains = tasksList.ToDictionary(t => t, t => t.Domain.ToList());

//                    // Assign the domain of the assigned task to a single choice
//                    assignedTask.Domain = new List<(string, int)> { assignedSlot };

//                    // For each unassigned task, remove all domain values conflicting with this assignment
//                    foreach (var other in tasksList)
//                    {
//                        if (other == assignedTask || other.IsPlaced)
//                            continue;

//                        var filteredDomain = new List<(string day, int start)>();
//                        foreach (var pos in other.Domain)
//                        {
//                            // Check if pos conflicts with assignedSlot on resources: staff, lab, timetable slots, max consecutive hours could also be checked here
//                            bool conflict = false;
//                            // Overlap check: if same day and overlapping hour intervals
//                            if (pos.day == assignedSlot.day)
//                            {
//                                int start1 = pos.start;
//                                int end1 = pos.start + other.Duration - 1;
//                                int start2 = assignedSlot.start;
//                                int end2 = assignedSlot.start + assignedTask.Duration - 1;
//                                bool hoursOverlap = end1 >= start2 && end2 >= start1;

//                                if (hoursOverlap)
//                                {
//                                    // Check if same staff assigned conflicts
//                                    var (_, staffCode1) = SplitStaff(other.StaffAssigned);
//                                    var (_, staffCode2) = SplitStaff(assignedTask.StaffAssigned);
//                                    if (staffCode1 == staffCode2) conflict = true;

//                                    // Check if labs conflict (if lab tasks)
//                                    if (!conflict && other.IsLab && assignedTask.IsLab && !string.IsNullOrEmpty(other.LabId) && !string.IsNullOrEmpty(assignedTask.LabId))
//                                    {
//                                        if (other.LabId == assignedTask.LabId) conflict = true;
//                                    }

//                                    // Additional constraints can be added here, e.g., max consecutive hours per staff or special room usage rules.
//                                }
//                            }

//                            if (!conflict)
//                            {
//                                filteredDomain.Add(pos);
//                            }
//                        }

//                        other.Domain = filteredDomain;

//                        // If domain wiped out, propagation fails
//                        if (other.Domain.Count == 0)
//                        {
//                            // rollback domains before returning false
//                            foreach (var kvp in snapshotDomains)
//                            {
//                                kvp.Key.Domain = kvp.Value;
//                            }
//                            return false;
//                        }
//                    }
//                    return true;
//                }

//                // Backtracking search with constraint propagation
//                // Tries to assign each unassigned task one by one, applying constraint propagation after each assignment
//                bool Backtrack(List<TaskUnit> tasksList)
//                {
//                    // All tasks assigned? return true success
//                    if (tasksList.All(t => t.IsPlaced)) return true;

//                    // Select next unassigned task using MRV (Minimum Remaining Values) heuristic for better pruning
//                    var unassignedTasks = tasksList.Where(t => !t.IsPlaced).ToList();
//                    var nextTask = unassignedTasks.OrderBy(t => t.Domain.Count).First();

//                    // Try each domain value for next task
//                    foreach (var slot in nextTask.Domain.OrderBy(s => s.day).ThenBy(s => s.start))
//                    {
//                        if (IsFreeAndNoConflict(nextTask, slot.day, slot.start, staffOcc, labOcc))
//                        {
//                            AssignTask(nextTask, slot);

//                            // Propagate constraints after this assignment, prune infeasible future assignments
//                            bool consistent = PropagateConstraints(tasksList, nextTask, slot);

//                            if (consistent)
//                            {
//                                if (Backtrack(tasksList))
//                                    return true; // success propagated
//                            }

//                            // Backtrack: unassign current task and restore states
//                            UnassignTask(nextTask);
//                        }
//                    }
//                    // No valid assignment for this task found => backtrack further
//                    return false;
//                }

//                // Begin backtracking with Constraint Propagation
//                bool solved = Backtrack(tasks);

//                if (!solved)
//                {
//                    return Ok(new
//                    {
//                        message = "⚠ No solution found with constraint propagation and backtracking, timetable generation failed.",
//                        receivedPayload = request
//                    });
//                }

//                // Store final solution in DB inside a transaction; rollback if any error

//                using (var tran = conn.BeginTransaction())
//                {
//                    // Delete previous timetable data for this dept/year/sem/section to avoid duplication
//                    using (var delClass = new NpgsqlCommand(@"
//                        DELETE FROM classtimetable 
//                        WHERE department_id=@department AND year=@year AND semester=@semester AND section=@section;", conn, tran))
//                    {
//                        delClass.Parameters.AddWithValue("@department", request.Department ?? "---");
//                        delClass.Parameters.AddWithValue("@year", request.Year ?? "---");
//                        delClass.Parameters.AddWithValue("@semester", request.Semester ?? "---");
//                        delClass.Parameters.AddWithValue("@section", request.Section ?? "---");
//                        await delClass.ExecuteNonQueryAsync();
//                    }
//                    using (var delLab = new NpgsqlCommand(@"
//                        DELETE FROM labtimetable
//                        WHERE department=@department AND year=@year AND semester=@semester AND section=@section;", conn, tran))
//                    {
//                        delLab.Parameters.AddWithValue("@department", request.Department ?? "---");
//                        delLab.Parameters.AddWithValue("@year", request.Year ?? "---");
//                        delLab.Parameters.AddWithValue("@semester", request.Semester ?? "---");
//                        delLab.Parameters.AddWithValue("@section", request.Section ?? "---");
//                        await delLab.ExecuteNonQueryAsync();
//                    }

//                    // Insert new assignments into DB
//                    foreach (var t in tasks)
//                    {
//                        var (staffName, staffCode) = SplitStaff(t.StaffAssigned);
//                        for (int h = t.StartHour; h < t.StartHour + t.Duration; h++)
//                        {
//                            using (var icClass = new NpgsqlCommand(@"
//                                INSERT INTO classtimetable
//                                (staff_name, staff_code, department_id, year, semester, section, day, hour, subject_code, subject_name)
//                                VALUES
//                                (@staff_name, @staff_code, @department, @year, @semester, @section, @day, @hour, @subject_code, @subject_name);", conn, tran))
//                            {
//                                icClass.Parameters.AddWithValue("@staff_name", staffName ?? "---");
//                                icClass.Parameters.AddWithValue("@staff_code", staffCode ?? "---");
//                                icClass.Parameters.AddWithValue("@department", request.Department ?? "---");
//                                icClass.Parameters.AddWithValue("@year", request.Year ?? "---");
//                                icClass.Parameters.AddWithValue("@semester", request.Semester ?? "---");
//                                icClass.Parameters.AddWithValue("@section", request.Section ?? "---");
//                                icClass.Parameters.AddWithValue("@day", t.Day ?? "---");
//                                icClass.Parameters.AddWithValue("@hour", h);
//                                icClass.Parameters.AddWithValue("@subject_code", t.SubjectCode ?? "---");
//                                icClass.Parameters.AddWithValue("@subject_name", t.SubjectName ?? "---");
//                                await icClass.ExecuteNonQueryAsync();
//                            }
//                        }
//                        if (t.IsLab && !string.IsNullOrEmpty(t.LabId))
//                        {
//                            int labStart = t.StartHour;
//                            if (labStart == 4)
//                            {
//                                labStart = 5; // Previous logic - adjust as needed
//                            }
//                            for (int h = labStart; h < t.StartHour + t.Duration; h++)
//                            {
//                                using (var icLab = new NpgsqlCommand(@"
//                                    INSERT INTO labtimetable
//                                    (lab_id, subject_code, subject_name, staff_name, department, year, semester, section, day, hour)
//                                    VALUES
//                                    (@lab_id, @subject_code, @subject_name, @staff_name, @department, @year, @semester, @section, @day, @hour);", conn, tran))
//                                {
//                                    icLab.Parameters.AddWithValue("@lab_id", t.LabId ?? (object)DBNull.Value);
//                                    icLab.Parameters.AddWithValue("@subject_code", t.SubjectCode ?? "---");
//                                    icLab.Parameters.AddWithValue("@subject_name", t.SubjectName ?? "---");
//                                    icLab.Parameters.AddWithValue("@staff_name", staffName ?? "---");
//                                    icLab.Parameters.AddWithValue("@department", request.Department ?? "---");
//                                    icLab.Parameters.AddWithValue("@year", request.Year ?? "---");
//                                    icLab.Parameters.AddWithValue("@semester", request.Semester ?? "---");
//                                    icLab.Parameters.AddWithValue("@section", request.Section ?? "---");
//                                    icLab.Parameters.AddWithValue("@day", t.Day ?? "---");
//                                    icLab.Parameters.AddWithValue("@hour", h);
//                                    await icLab.ExecuteNonQueryAsync();
//                                }
//                            }
//                        }
//                    }
//                    await tran.CommitAsync();
//                }

//                // Prepare response schedule view for client
//                var responseTimetable = timetable
//                    .Select(row => new
//                    {
//                        Day = row.Key,
//                        HourlySlots = row.Value
//                    }).ToList();

//                return Ok(new
//                {
//                    message = "✅ Timetable generated perfectly with deterministic Backtracking + Constraint Propagation (AC-3).",
//                    timetable = responseTimetable,
//                    usedLabIds = tasks.Where(x => x.IsLab && !string.IsNullOrEmpty(x.LabId)).Select(x => x.LabId).Distinct().ToList(),
//                    receivedPayload = request
//                });
//            }
//            catch (Exception ex)
//            {
//                return StatusCode(500, new { message = "❌ Internal Server Error while generating timetable.", error = ex.Message });
//            }
//        }
//    }
//}







//non perfect with shuffle
//using Microsoft.AspNetCore.Mvc;
//using Microsoft.Extensions.Configuration;
//using Npgsql;
//using System;
//using System.Collections.Generic;
//using System.Linq;
//using System.Threading.Tasks;

//namespace Timetablegenerator.Controllers
//{
//    [ApiController]
//    [Route("api/[controller]")]
//    public class TimetableController : ControllerBase
//    {
//        private readonly IConfiguration _configuration;
//        public TimetableController(IConfiguration configuration)
//        {
//            _configuration = configuration;
//        }

//        // DTO Classes
//        public class TimetableRequest
//        {
//            public string Department { get; set; }
//            public string Year { get; set; }
//            public string Semester { get; set; }
//            public string Section { get; set; }
//            public int TotalHoursPerDay { get; set; } = 7;
//            public List<SubjectDto> Subjects { get; set; }
//        }

//        public class SubjectDto
//        {
//            public string SubjectCode { get; set; }
//            public string SubjectName { get; set; }
//            public string SubjectType { get; set; }
//            public int Credit { get; set; }
//            public string StaffAssigned { get; set; }
//            public string LabId { get; set; }
//        }

//        public class TaskUnit
//        {
//            public string SubjectCode;
//            public string SubjectName;
//            public string StaffAssigned;
//            public string LabId;
//            public bool IsLab;
//            public int Duration;
//            public string Kind;
//            public string Day;
//            public int StartHour;
//            public bool IsPlaced = false;
//            public List<(string day, int start)> Domain = new();
//        }

//        // Random helper extension for shuffling lists
//        private static readonly Random rng = new Random();

//        private void Shuffle<T>(IList<T> list)
//        {
//            int n = list.Count;
//            while (n > 1)
//            {
//                n--;
//                int k = rng.Next(n + 1);
//                (list[k], list[n]) = (list[n], list[k]);
//            }
//        }

//        [HttpPost("generateCrossDepartmentTimetableBacktracking")]
//        public async Task<IActionResult> GenerateCrossDepartmentTimetableBacktracking([FromBody] TimetableRequest request)
//        {
//            var cs = _configuration.GetConnectionString("DefaultConnection");
//            try
//            {
//                string[] DAYS = new[] { "Mon", "Tue", "Wed", "Thu", "Fri" };
//                int HOURS = Math.Max(1, request.TotalHoursPerDay);

//                (string staffName, string staffCode) SplitStaff(string staffAssigned)
//                {
//                    if (string.IsNullOrWhiteSpace(staffAssigned)) return ("---", "---");
//                    var name = staffAssigned;
//                    var code = staffAssigned;
//                    if (staffAssigned.Contains("("))
//                    {
//                        var parts = staffAssigned.Split('(', StringSplitOptions.TrimEntries);
//                        name = parts[0].Trim();
//                        code = parts.Length > 1 ? parts[1].Replace(")", "").Trim() : "---";
//                    }
//                    return (name, code);
//                }

//                var subjects = new List<(string code, string name, string type, int credit, string staff, string labId)>();
//                foreach (var s in request.Subjects ?? Enumerable.Empty<SubjectDto>())
//                {
//                    if (string.IsNullOrWhiteSpace(s.StaffAssigned)) continue;
//                    var type = (s.SubjectType ?? "theory").Trim().ToLower();
//                    subjects.Add((
//                        s.SubjectCode ?? "---",
//                        s.SubjectName ?? "---",
//                        type,
//                        s.Credit,
//                        s.StaffAssigned,
//                        (type == "lab" || type == "embedded") ? (s.LabId?.Trim()) : null
//                    ));
//                }

//                if (subjects.Count == 0)
//                    return BadRequest(new { message = "❌ No valid subjects found (missing staff)." });

//                using var conn = new NpgsqlConnection(cs);
//                await conn.OpenAsync();

//                var staffOcc = new Dictionary<string, Dictionary<string, HashSet<int>>>();
//                var labOcc = new Dictionary<string, Dictionary<string, HashSet<int>>>();

//                void EnsureDayMap<TKey>(Dictionary<TKey, Dictionary<string, HashSet<int>>> map, TKey key)
//                {
//                    if (!map.ContainsKey(key))
//                        map[key] = DAYS.ToDictionary(d => d, d => new HashSet<int>());
//                }

//                // Load existing staff occupancy
//                using (var cmd = new NpgsqlCommand("SELECT staff_code, day, hour FROM classtimetable", conn))
//                using (var rd = await cmd.ExecuteReaderAsync())
//                {
//                    while (await rd.ReadAsync())
//                    {
//                        var sc = rd["staff_code"]?.ToString() ?? "---";
//                        var day = rd["day"]?.ToString() ?? "Mon";
//                        var hr = Convert.ToInt32(rd["hour"]);
//                        EnsureDayMap(staffOcc, sc);
//                        if (!staffOcc[sc].ContainsKey(day)) staffOcc[sc][day] = new HashSet<int>();
//                        staffOcc[sc][day].Add(hr);
//                    }
//                }

//                // Load existing lab occupancy
//                using (var cmd = new NpgsqlCommand("SELECT lab_id, day, hour FROM labtimetable", conn))
//                using (var rd = await cmd.ExecuteReaderAsync())
//                {
//                    while (await rd.ReadAsync())
//                    {
//                        var lab = rd["lab_id"]?.ToString() ?? "---";
//                        var day = rd["day"]?.ToString() ?? "Mon";
//                        var hr = Convert.ToInt32(rd["hour"]);
//                        EnsureDayMap(labOcc, lab);
//                        if (!labOcc[lab].ContainsKey(day)) labOcc[lab][day] = new HashSet<int>();
//                        labOcc[lab][day].Add(hr);
//                    }
//                }

//                foreach (var s in subjects)
//                {
//                    var (_, staffCode) = SplitStaff(s.staff);
//                    EnsureDayMap(staffOcc, staffCode);
//                    if (!string.IsNullOrEmpty(s.labId)) EnsureDayMap(labOcc, s.labId);
//                }

//                var tasks = new List<TaskUnit>();
//                var labAllowedBlocks = new List<int[]> { new[] { 1, 2, 3, 4 }, new[] { 4, 5, 6, 7 } };
//                var embeddedLabAllowedBlocks = new List<int[]> {
//                    new[] { 1, 2 },
//                    new[] { 2, 3 },
//                    new[] { 3, 4 },
//                    new[] { 5, 6 },
//                    new[] { 6, 7 }
//                };

//                foreach (var s in subjects)
//                {
//                    switch (s.type)
//                    {
//                        case "lab":
//                            tasks.Add(new TaskUnit
//                            {
//                                SubjectCode = s.code,
//                                SubjectName = s.name,
//                                StaffAssigned = s.staff,
//                                LabId = s.labId,
//                                IsLab = true,
//                                Duration = 4,
//                                Kind = "LAB4"
//                            });
//                            break;
//                        case "embedded":
//                            tasks.Add(new TaskUnit
//                            {
//                                SubjectCode = s.code,
//                                SubjectName = s.name,
//                                StaffAssigned = s.staff,
//                                LabId = s.labId,
//                                IsLab = true,
//                                Duration = 2,
//                                Kind = "EMB_LAB2"
//                            });
//                            tasks.Add(new TaskUnit
//                            {
//                                SubjectCode = s.code,
//                                SubjectName = s.name,
//                                StaffAssigned = s.staff,
//                                IsLab = false,
//                                Duration = 1,
//                                Kind = "EMB_TH1"
//                            });
//                            tasks.Add(new TaskUnit
//                            {
//                                SubjectCode = s.code,
//                                SubjectName = s.name,
//                                StaffAssigned = s.staff,
//                                IsLab = false,
//                                Duration = 1,
//                                Kind = "EMB_TH1"
//                            });
//                            break;
//                        default:
//                            int count = Math.Max(0, s.credit);
//                            for (int i = 0; i < count; i++)
//                            {
//                                tasks.Add(new TaskUnit
//                                {
//                                    SubjectCode = s.code,
//                                    SubjectName = s.name,
//                                    StaffAssigned = s.staff,
//                                    IsLab = false,
//                                    Duration = 1,
//                                    Kind = "TH1"
//                                });
//                            }
//                            break;
//                    }
//                }

//                var timetable = DAYS.ToDictionary(d => d,
//                    d => Enumerable.Range(1, HOURS).ToDictionary(h => h, _ => "---"));

//                bool IsValidStartForLab(TaskUnit t, int start)
//                {
//                    if (t.Kind == "LAB4")
//                        return labAllowedBlocks.Any(b => b[0] == start && b.Length == t.Duration);
//                    if (t.Kind == "EMB_LAB2")
//                        return embeddedLabAllowedBlocks.Any(b => b[0] == start && b.Length == t.Duration);
//                    return true;
//                }

//                bool IsFreeAndNoConflict(TaskUnit t, string day, int start,
//                    Dictionary<string, Dictionary<string, HashSet<int>>> staffOccMap,
//                    Dictionary<string, Dictionary<string, HashSet<int>>> labOccMap)
//                {
//                    for (int h = start; h < start + t.Duration; h++)
//                    {
//                        if (h < 1 || h > HOURS) return false;
//                        if (timetable[day][h] != "---") return false;
//                    }
//                    var (_, staffCode) = SplitStaff(t.StaffAssigned);
//                    for (int h = start; h < start + t.Duration; h++)
//                    {
//                        if (staffOccMap.TryGetValue(staffCode, out var dayMap) && dayMap.TryGetValue(day, out var hoursSet) && hoursSet.Contains(h))
//                            return false;
//                    }
//                    if (t.IsLab && !string.IsNullOrEmpty(t.LabId))
//                    {
//                        for (int h = start; h < start + t.Duration; h++)
//                        {
//                            if (labOccMap.TryGetValue(t.LabId, out var labDayMap) && labDayMap.TryGetValue(day, out var hoursSet) && hoursSet.Contains(h))
//                                return false;
//                        }
//                        if (!IsValidStartForLab(t, start))
//                            return false;
//                    }
//                    return true;
//                }

//                // SHUFFLE: Randomize task order before domain initialization for varied schedules
//                Shuffle(tasks);

//                // Initialize domains and shuffle each to add randomness
//                foreach (var t in tasks)
//                {
//                    t.Domain.Clear();
//                    foreach (var day in DAYS)
//                    {
//                        for (int h = 1; h <= HOURS - t.Duration + 1; h++)
//                        {
//                            if (IsFreeAndNoConflict(t, day, h, staffOcc, labOcc))
//                            {
//                                t.Domain.Add((day, h));
//                            }
//                        }
//                    }
//                    if (t.Domain.Count == 0)
//                    {
//                        return Ok(new
//                        {
//                            message = $"⚠ No feasible slot initially for task {t.SubjectCode} {t.SubjectName}. Cannot generate timetable.",
//                            receivedPayload = request
//                        });
//                    }
//                    Shuffle(t.Domain); // SHUFFLE domain before assignment attempts
//                }

//                void AssignTask(TaskUnit t, (string day, int start) slot)
//                {
//                    var (day, start) = slot;
//                    var (_, staffCode) = SplitStaff(t.StaffAssigned);
//                    for (int h = start; h < start + t.Duration; h++)
//                    {
//                        timetable[day][h] = $"{t.SubjectCode} ({t.StaffAssigned})";
//                        if (!staffOcc.ContainsKey(staffCode)) staffOcc[staffCode] = new Dictionary<string, HashSet<int>>();
//                        if (!staffOcc[staffCode].ContainsKey(day)) staffOcc[staffCode][day] = new HashSet<int>();
//                        staffOcc[staffCode][day].Add(h);
//                        if (t.IsLab && !string.IsNullOrEmpty(t.LabId))
//                        {
//                            if (!labOcc.ContainsKey(t.LabId)) labOcc[t.LabId] = new Dictionary<string, HashSet<int>>();
//                            if (!labOcc[t.LabId].ContainsKey(day)) labOcc[t.LabId][day] = new HashSet<int>();
//                            labOcc[t.LabId][day].Add(h);
//                        }
//                    }
//                    t.Day = day;
//                    t.StartHour = start;
//                    t.IsPlaced = true;
//                }

//                void UnassignTask(TaskUnit t)
//                {
//                    if (!t.IsPlaced) return;
//                    var day = t.Day;
//                    var start = t.StartHour;
//                    var (_, staffCode) = SplitStaff(t.StaffAssigned);
//                    for (int h = start; h < start + t.Duration; h++)
//                    {
//                        timetable[day][h] = "---";
//                        staffOcc[staffCode][day].Remove(h);
//                        if (t.IsLab && !string.IsNullOrEmpty(t.LabId))
//                        {
//                            labOcc[t.LabId][day].Remove(h);
//                        }
//                    }
//                    t.IsPlaced = false;
//                    t.Day = null;
//                    t.StartHour = 0;
//                }

//                bool PropagateConstraints(List<TaskUnit> tasksList, TaskUnit assignedTask, (string day, int start) assignedSlot)
//                {
//                    var snapshotDomains = tasksList.ToDictionary(t => t, t => t.Domain.ToList());
//                    assignedTask.Domain = new List<(string, int)> { assignedSlot };
//                    foreach (var other in tasksList)
//                    {
//                        if (other == assignedTask || other.IsPlaced)
//                            continue;
//                        var filteredDomain = new List<(string day, int start)>();
//                        foreach (var pos in other.Domain)
//                        {
//                            bool conflict = false;
//                            if (pos.day == assignedSlot.day)
//                            {
//                                int start1 = pos.start;
//                                int end1 = pos.start + other.Duration - 1;
//                                int start2 = assignedSlot.start;
//                                int end2 = assignedSlot.start + assignedTask.Duration - 1;
//                                bool hoursOverlap = end1 >= start2 && end2 >= start1;
//                                if (hoursOverlap)
//                                {
//                                    var (_, staffCode1) = SplitStaff(other.StaffAssigned);
//                                    var (_, staffCode2) = SplitStaff(assignedTask.StaffAssigned);
//                                    if (staffCode1 == staffCode2) conflict = true;
//                                    if (!conflict && other.IsLab && assignedTask.IsLab && !string.IsNullOrEmpty(other.LabId) && !string.IsNullOrEmpty(assignedTask.LabId))
//                                    {
//                                        if (other.LabId == assignedTask.LabId) conflict = true;
//                                    }
//                                }
//                            }
//                            if (!conflict)
//                            {
//                                filteredDomain.Add(pos);
//                            }
//                        }
//                        other.Domain = filteredDomain;
//                        if (other.Domain.Count == 0)
//                        {
//                            foreach (var kvp in snapshotDomains)
//                            {
//                                kvp.Key.Domain = kvp.Value;
//                            }
//                            return false;
//                        }
//                    }
//                    return true;
//                }

//                bool Backtrack(List<TaskUnit> tasksList)
//                {
//                    if (tasksList.All(t => t.IsPlaced)) return true;
//                    var unassignedTasks = tasksList.Where(t => !t.IsPlaced).OrderBy(t => t.Domain.Count).ToList();
//                    if (unassignedTasks.Count == 0) return true;
//                    var nextTask = unassignedTasks.First();

//                    // Optional: shuffle domain again here for extra randomness
//                    Shuffle(nextTask.Domain);

//                    foreach (var slot in nextTask.Domain)
//                    {
//                        if (IsFreeAndNoConflict(nextTask, slot.day, slot.start, staffOcc, labOcc))
//                        {
//                            AssignTask(nextTask, slot);
//                            bool consistent = PropagateConstraints(tasksList, nextTask, slot);
//                            if (consistent)
//                            {
//                                if (Backtrack(tasksList))
//                                    return true;
//                            }
//                            UnassignTask(nextTask);
//                        }
//                    }
//                    return false;
//                }

//                bool solved = Backtrack(tasks);
//                if (!solved)
//                {
//                    return Ok(new
//                    {
//                        message = "⚠ No solution found with constraint propagation and backtracking, timetable generation failed.",
//                        receivedPayload = request
//                    });
//                }

//                using (var tran = conn.BeginTransaction())
//                {
//                    using (var delClass = new NpgsqlCommand(@"
//                        DELETE FROM classtimetable 
//                        WHERE department_id=@department AND year=@year AND semester=@semester AND section=@section;", conn, tran))
//                    {
//                        delClass.Parameters.AddWithValue("@department", request.Department ?? "---");
//                        delClass.Parameters.AddWithValue("@year", request.Year ?? "---");
//                        delClass.Parameters.AddWithValue("@semester", request.Semester ?? "---");
//                        delClass.Parameters.AddWithValue("@section", request.Section ?? "---");
//                        await delClass.ExecuteNonQueryAsync();
//                    }
//                    using (var delLab = new NpgsqlCommand(@"
//                        DELETE FROM labtimetable
//                        WHERE department=@department AND year=@year AND semester=@semester AND section=@section;", conn, tran))
//                    {
//                        delLab.Parameters.AddWithValue("@department", request.Department ?? "---");
//                        delLab.Parameters.AddWithValue("@year", request.Year ?? "---");
//                        delLab.Parameters.AddWithValue("@semester", request.Semester ?? "---");
//                        delLab.Parameters.AddWithValue("@section", request.Section ?? "---");
//                        await delLab.ExecuteNonQueryAsync();
//                    }

//                    foreach (var t in tasks)
//                    {
//                        var (staffName, staffCode) = SplitStaff(t.StaffAssigned);
//                        for (int h = t.StartHour; h < t.StartHour + t.Duration; h++)
//                        {
//                            using (var icClass = new NpgsqlCommand(@"
//                                INSERT INTO classtimetable
//                                (staff_name, staff_code, department_id, year, semester, section, day, hour, subject_code, subject_name)
//                                VALUES
//                                (@staff_name, @staff_code, @department, @year, @semester, @section, @day, @hour, @subject_code, @subject_name);", conn, tran))
//                            {
//                                icClass.Parameters.AddWithValue("@staff_name", staffName ?? "---");
//                                icClass.Parameters.AddWithValue("@staff_code", staffCode ?? "---");
//                                icClass.Parameters.AddWithValue("@department", request.Department ?? "---");
//                                icClass.Parameters.AddWithValue("@year", request.Year ?? "---");
//                                icClass.Parameters.AddWithValue("@semester", request.Semester ?? "---");
//                                icClass.Parameters.AddWithValue("@section", request.Section ?? "---");
//                                icClass.Parameters.AddWithValue("@day", t.Day ?? "---");
//                                icClass.Parameters.AddWithValue("@hour", h);
//                                icClass.Parameters.AddWithValue("@subject_code", t.SubjectCode ?? "---");
//                                icClass.Parameters.AddWithValue("@subject_name", t.SubjectName ?? "---");
//                                await icClass.ExecuteNonQueryAsync();
//                            }
//                        }
//                        if (t.IsLab && !string.IsNullOrEmpty(t.LabId))
//                        {
//                            int labStart = t.StartHour;
//                            if (labStart == 4)
//                                labStart = 5;
//                            for (int h = labStart; h < t.StartHour + t.Duration; h++)
//                            {
//                                using (var icLab = new NpgsqlCommand(@"
//                                    INSERT INTO labtimetable
//                                    (lab_id, subject_code, subject_name, staff_name, department, year, semester, section, day, hour)
//                                    VALUES
//                                    (@lab_id, @subject_code, @subject_name, @staff_name, @department, @year, @semester, @section, @day, @hour);", conn, tran))
//                                {
//                                    icLab.Parameters.AddWithValue("@lab_id", t.LabId ?? (object)DBNull.Value);
//                                    icLab.Parameters.AddWithValue("@subject_code", t.SubjectCode ?? "---");
//                                    icLab.Parameters.AddWithValue("@subject_name", t.SubjectName ?? "---");
//                                    icLab.Parameters.AddWithValue("@staff_name", staffName ?? "---");
//                                    icLab.Parameters.AddWithValue("@department", request.Department ?? "---");
//                                    icLab.Parameters.AddWithValue("@year", request.Year ?? "---");
//                                    icLab.Parameters.AddWithValue("@semester", request.Semester ?? "---");
//                                    icLab.Parameters.AddWithValue("@section", request.Section ?? "---");
//                                    icLab.Parameters.AddWithValue("@day", t.Day ?? "---");
//                                    icLab.Parameters.AddWithValue("@hour", h);
//                                    await icLab.ExecuteNonQueryAsync();
//                                }
//                            }
//                        }
//                    }
//                    await tran.CommitAsync();
//                }

//                var responseTimetable = timetable.Select(row => new
//                {
//                    Day = row.Key,
//                    HourlySlots = row.Value
//                }).ToList();

//                return Ok(new
//                {
//                    message = "✅ Timetable generated with constraint propagation + randomized backtracking successfully.",
//                    timetable = responseTimetable,
//                    usedLabIds = tasks.Where(x => x.IsLab && !string.IsNullOrEmpty(x.LabId)).Select(x => x.LabId).Distinct().ToList(),
//                    receivedPayload = request
//                });
//            }
//            catch (Exception ex)
//            {
//                return StatusCode(500, new { message = "❌ Error generating timetable.", error = ex.Message });
//            }
//        }
//    }
//}










//i think perfect achieved but disappointed

//using Microsoft.AspNetCore.Mvc;
//using Microsoft.Extensions.Configuration;
//using Npgsql;
//using System;
//using System.Collections.Generic;
//using System.Linq;
//using System.Threading.Tasks;

//namespace Timetablegenerator.Controllers
//{
//    [ApiController]
//    [Route("api/[controller]")]
//    public class TimetableController : ControllerBase
//    {
//        private readonly IConfiguration _configuration;
//        public TimetableController(IConfiguration configuration)
//        {
//            _configuration = configuration;
//        }

//        public class TimetableRequest
//        {
//            public string Department { get; set; }
//            public string Year { get; set; }
//            public string Semester { get; set; }
//            public string Section { get; set; }
//            public int TotalHoursPerDay { get; set; } = 7;
//            public List<SubjectDto> Subjects { get; set; }
//        }

//        public class SubjectDto
//        {
//            public string SubjectCode { get; set; }
//            public string SubjectName { get; set; }
//            public string SubjectType { get; set; }
//            public int Credit { get; set; }
//            public string StaffAssigned { get; set; }
//            public string LabId { get; set; }
//        }

//        public class TaskUnit
//        {
//            public string SubjectCode;
//            public string SubjectName;
//            public string StaffAssigned;
//            public string LabId;
//            public bool IsLab;
//            public int Duration;
//            public string Kind;
//            public string Day;
//            public int StartHour;
//            public bool IsPlaced = false;
//            public List<(string day, int start)> Domain = new();
//        }

//        private static readonly Random rng = new Random();
//        private void Shuffle<T>(IList<T> list)
//        {
//            int n = list.Count;
//            while (n > 1)
//            {
//                n--;
//                int k = rng.Next(n + 1);
//                (list[k], list[n]) = (list[n], list[k]);
//            }
//        }

//        [HttpPost("generateCrossDepartmentTimetableBacktracking")]
//        public async Task<IActionResult> GenerateCrossDepartmentTimetableBacktracking([FromBody] TimetableRequest request)
//        {
//            var cs = _configuration.GetConnectionString("DefaultConnection");
//            try
//            {
//                string[] DAYS = new[] { "Mon", "Tue", "Wed", "Thu", "Fri" };
//                int HOURS = Math.Max(1, request.TotalHoursPerDay);

//                (string staffName, string staffCode) SplitStaff(string staffAssigned)
//                {
//                    if (string.IsNullOrWhiteSpace(staffAssigned)) return ("---", "---");
//                    var name = staffAssigned;
//                    var code = staffAssigned;
//                    if (staffAssigned.Contains("("))
//                    {
//                        var parts = staffAssigned.Split('(', StringSplitOptions.TrimEntries);
//                        name = parts[0].Trim();
//                        code = parts.Length > 1 ? parts[1].Replace(")", "").Trim() : "---";
//                    }
//                    return (name, code);
//                }

//                var subjects = new List<(string code, string name, string type, int credit, string staff, string labId)>();
//                foreach (var s in request.Subjects ?? Enumerable.Empty<SubjectDto>())
//                {
//                    if (string.IsNullOrWhiteSpace(s.StaffAssigned)) continue;
//                    var type = (s.SubjectType ?? "theory").Trim().ToLower();
//                    subjects.Add((
//                        s.SubjectCode ?? "---",
//                        s.SubjectName ?? "---",
//                        type,
//                        s.Credit,
//                        s.StaffAssigned,
//                        (type == "lab" || type == "embedded") ? (s.LabId?.Trim()) : null
//                    ));
//                }

//                if (subjects.Count == 0)
//                    return BadRequest(new { message = "❌ No valid subjects found (missing staff)." });

//                using var conn = new NpgsqlConnection(cs);
//                await conn.OpenAsync();

//                var staffOcc = new Dictionary<string, Dictionary<string, HashSet<int>>>();
//                var labOcc = new Dictionary<string, Dictionary<string, HashSet<int>>>();
//                var timetableGrid = DAYS.ToDictionary(
//                    d => d,
//                    d => Enumerable.Range(1, HOURS).ToDictionary(h => h, _ => "---"));

//                void EnsureDayMap<TKey>(Dictionary<TKey, Dictionary<string, HashSet<int>>> map, TKey key)
//                {
//                    if (!map.ContainsKey(key))
//                        map[key] = DAYS.ToDictionary(d => d, _ => new HashSet<int>());
//                }

//                // Load existing occupancy data
//                using (var cmd = new NpgsqlCommand("SELECT staff_code, day, hour FROM classtimetable", conn))
//                using (var rd = await cmd.ExecuteReaderAsync())
//                {
//                    while (await rd.ReadAsync())
//                    {
//                        var sc = rd["staff_code"]?.ToString() ?? "---";
//                        var day = rd["day"]?.ToString() ?? "Mon";
//                        var hr = Convert.ToInt32(rd["hour"]);
//                        EnsureDayMap(staffOcc, sc);
//                        if (!staffOcc[sc].ContainsKey(day)) staffOcc[sc][day] = new HashSet<int>();
//                        staffOcc[sc][day].Add(hr);
//                    }
//                }

//                using (var cmd = new NpgsqlCommand("SELECT lab_id, day, hour FROM labtimetable", conn))
//                using (var rd = await cmd.ExecuteReaderAsync())
//                {
//                    while (await rd.ReadAsync())
//                    {
//                        var lab = rd["lab_id"]?.ToString() ?? "---";
//                        var day = rd["day"]?.ToString() ?? "Mon";
//                        var hr = Convert.ToInt32(rd["hour"]);
//                        EnsureDayMap(labOcc, lab);
//                        if (!labOcc[lab].ContainsKey(day)) labOcc[lab][day] = new HashSet<int>();
//                        labOcc[lab][day].Add(hr);
//                    }
//                }

//                foreach (var s in subjects)
//                {
//                    var (_, staffCode) = SplitStaff(s.staff);
//                    EnsureDayMap(staffOcc, staffCode);
//                    if (!string.IsNullOrEmpty(s.labId)) EnsureDayMap(labOcc, s.labId);
//                }

//                var tasks = new List<TaskUnit>();
//                var labAllowedBlocks = new List<int[]> { new[] { 1, 2, 3, 4 }, new[] { 4, 5, 6, 7 } };
//                var embeddedLabAllowedBlocks = new List<int[]> {
//                    new[] { 1, 2 },
//                    new[] { 2, 3 },
//                    new[] { 3, 4 },
//                    new[] { 5, 6 },
//                    new[] { 6, 7 }
//                };

//                foreach (var s in subjects)
//                {
//                    switch (s.type)
//                    {
//                        case "lab":
//                            tasks.Add(new TaskUnit
//                            {
//                                SubjectCode = s.code,
//                                SubjectName = s.name,
//                                StaffAssigned = s.staff,
//                                LabId = s.labId,
//                                IsLab = true,
//                                Duration = 4,
//                                Kind = "LAB4"
//                            });
//                            break;
//                        case "embedded":
//                            tasks.Add(new TaskUnit
//                            {
//                                SubjectCode = s.code,
//                                SubjectName = s.name,
//                                StaffAssigned = s.staff,
//                                LabId = s.labId,
//                                IsLab = true,
//                                Duration = 2,
//                                Kind = "EMB_LAB2"
//                            });
//                            tasks.Add(new TaskUnit
//                            {
//                                SubjectCode = s.code,
//                                SubjectName = s.name,
//                                StaffAssigned = s.staff,
//                                IsLab = false,
//                                Duration = 1,
//                                Kind = "EMB_TH1"
//                            });
//                            tasks.Add(new TaskUnit
//                            {
//                                SubjectCode = s.code,
//                                SubjectName = s.name,
//                                StaffAssigned = s.staff,
//                                IsLab = false,
//                                Duration = 1,
//                                Kind = "EMB_TH1"
//                            });
//                            break;
//                        default:
//                            int count = Math.Max(0, s.credit);
//                            for (int i = 0; i < count; i++)
//                            {
//                                tasks.Add(new TaskUnit
//                                {
//                                    SubjectCode = s.code,
//                                    SubjectName = s.name,
//                                    StaffAssigned = s.staff,
//                                    IsLab = false,
//                                    Duration = 1,
//                                    Kind = "TH1"
//                                });
//                            }
//                            break;
//                    }
//                }

//                bool IsValidLabStart(TaskUnit t, int start)
//                {
//                    if (t.Kind == "LAB4")
//                        return labAllowedBlocks.Any(b => b[0] == start && b.Length == t.Duration);
//                    if (t.Kind == "EMB_LAB2")
//                        return embeddedLabAllowedBlocks.Any(b => b[0] == start && b.Length == t.Duration);
//                    return true;
//                }

//                bool IsFreeAndNoConflict(TaskUnit t, string day, int start,
//                    Dictionary<string, Dictionary<string, HashSet<int>>> staffOcc,
//                    Dictionary<string, Dictionary<string, HashSet<int>>> labOcc)
//                {
//                    for (int h = start; h < start + t.Duration; h++)
//                    {
//                        if (h < 1 || h > HOURS) return false;
//                        if (timetableGrid[day][h] != "---") return false;
//                    }
//                    var (_, staffCode) = SplitStaff(t.StaffAssigned);
//                    for (int h = start; h < start + t.Duration; h++)
//                    {
//                        if (staffOcc.TryGetValue(staffCode, out var dayHours) && dayHours.TryGetValue(day, out var hoursSet) && hoursSet.Contains(h))
//                            return false;
//                    }
//                    if (t.IsLab && !string.IsNullOrEmpty(t.LabId))
//                    {
//                        for (int h = start; h < start + t.Duration; h++)
//                        {
//                            if (labOcc.TryGetValue(t.LabId, out var dayHours) && dayHours.TryGetValue(day, out var hoursSet) && hoursSet.Contains(h))
//                                return false;
//                        }
//                        if (!IsValidLabStart(t, start))
//                            return false;
//                    }
//                    return true;
//                }

//                void AssignTask(TaskUnit t, (string day, int start) slot)
//                {
//                    var (day, start) = slot;
//                    var (_, staffCode) = SplitStaff(t.StaffAssigned);
//                    for (int h = start; h < start + t.Duration; h++)
//                    {
//                        timetableGrid[day][h] = $"{t.SubjectCode} ({t.StaffAssigned})";
//                        if (!staffOcc.ContainsKey(staffCode)) staffOcc[staffCode] = new Dictionary<string, HashSet<int>>();
//                        if (!staffOcc[staffCode].ContainsKey(day)) staffOcc[staffCode][day] = new HashSet<int>();
//                        staffOcc[staffCode][day].Add(h);
//                        if (t.IsLab && !string.IsNullOrEmpty(t.LabId))
//                        {
//                            if (!labOcc.ContainsKey(t.LabId)) labOcc[t.LabId] = new Dictionary<string, HashSet<int>>();
//                            if (!labOcc[t.LabId].ContainsKey(day)) labOcc[t.LabId][day] = new HashSet<int>();
//                            labOcc[t.LabId][day].Add(h);
//                        }
//                    }
//                    t.Day = day;
//                    t.StartHour = start;
//                    t.IsPlaced = true;
//                }

//                void UnassignTask(TaskUnit t)
//                {
//                    if (!t.IsPlaced) return;
//                    var day = t.Day;
//                    var start = t.StartHour;
//                    var (_, staffCode) = SplitStaff(t.StaffAssigned);
//                    for (int h = start; h < start + t.Duration; h++)
//                    {
//                        timetableGrid[day][h] = "---";
//                        staffOcc[staffCode][day].Remove(h);
//                        if (t.IsLab && !string.IsNullOrEmpty(t.LabId))
//                        {
//                            labOcc[t.LabId][day].Remove(h);
//                        }
//                    }
//                    t.IsPlaced = false;
//                    t.Day = null;
//                    t.StartHour = 0;
//                }

//                bool PropagateConstraints(List<TaskUnit> tasksList, TaskUnit assignedTask, (string day, int start) assignedSlot)
//                {
//                    var snapshotDomains = tasksList.ToDictionary(t => t, t => t.Domain.ToList());
//                    assignedTask.Domain = new List<(string, int)> { assignedSlot };
//                    foreach (var other in tasksList)
//                    {
//                        if (other == assignedTask || other.IsPlaced)
//                            continue;

//                        var filteredDomain = new List<(string day, int start)>();
//                        foreach (var pos in other.Domain)
//                        {
//                            bool conflict = false;
//                            if (pos.day == assignedSlot.day)
//                            {
//                                int start1 = pos.start;
//                                int end1 = pos.start + other.Duration - 1;
//                                int start2 = assignedSlot.start;
//                                int end2 = assignedSlot.start + assignedTask.Duration - 1;
//                                bool hoursOverlap = end1 >= start2 && end2 >= start1;
//                                if (hoursOverlap)
//                                {
//                                    var (_, staffCode1) = SplitStaff(other.StaffAssigned);
//                                    var (_, staffCode2) = SplitStaff(assignedTask.StaffAssigned);
//                                    if (staffCode1 == staffCode2) conflict = true;
//                                    if (!conflict && other.IsLab && assignedTask.IsLab && !string.IsNullOrEmpty(other.LabId) && !string.IsNullOrEmpty(assignedTask.LabId))
//                                    {
//                                        if (other.LabId == assignedTask.LabId) conflict = true;
//                                    }
//                                }
//                            }
//                            if (!conflict)
//                                filteredDomain.Add(pos);
//                        }
//                        other.Domain = filteredDomain;
//                        if (other.Domain.Count == 0)
//                        {
//                            foreach (var kvp in snapshotDomains)
//                                kvp.Key.Domain = kvp.Value;
//                            return false;
//                        }
//                    }
//                    return true;
//                }

//                // Shuffle tasks list before domain initialization for randomness
//                Shuffle(tasks);

//                // Initialize domains with shuffled domains for randomness
//                foreach (var t in tasks)
//                {
//                    t.Domain.Clear();
//                    foreach (var day in DAYS)
//                    {
//                        for (int h = 1; h <= HOURS - t.Duration + 1; h++)
//                        {
//                            if (IsFreeAndNoConflict(t, day, h, staffOcc, labOcc))
//                                t.Domain.Add((day, h));
//                        }
//                    }
//                    if (t.Domain.Count == 0)
//                        return Ok(new { message = $"⚠ No feasible slot initially for task {t.SubjectCode} {t.SubjectName}. Cannot generate timetable.", receivedPayload = request });
//                    Shuffle(t.Domain);
//                }

//                // Recursive backtracking with constraint propagation plus global conflict-aware rescheduling
//                async Task<bool> GlobalReschedule(List<TaskUnit> tasksList)
//                {
//                    if (tasksList.All(t => t.IsPlaced)) return true;
//                    var unassignedTasks = tasksList.Where(t => !t.IsPlaced).OrderBy(t => t.Domain.Count).ToList();
//                    if (!unassignedTasks.Any()) return true;
//                    var currentTask = unassignedTasks.First();
//                    Shuffle(currentTask.Domain);

//                    foreach (var slot in currentTask.Domain)
//                    {
//                        if (IsFreeAndNoConflict(currentTask, slot.day, slot.start, staffOcc, labOcc))
//                        {
//                            AssignTask(currentTask, slot);
//                            bool consistent = PropagateConstraints(tasksList, currentTask, slot);
//                            if (consistent)
//                            {
//                                if (await GlobalReschedule(tasksList))
//                                    return true;
//                            }
//                            // Conflict detected: global rescheduling triggered
//                            var conflictingTasks = CollectConflictingTasks(currentTask, tasksList);

//                            var tasksToReschedule = new List<TaskUnit> { currentTask };
//                            foreach (var ct in conflictingTasks)
//                                if (!tasksToReschedule.Contains(ct)) tasksToReschedule.Add(ct);

//                            // Unassign all conflicting tasks
//                            foreach (var t in tasksToReschedule)
//                                UnassignTask(t);

//                            // Rebuild domains for conflict group with shuffle
//                            foreach (var t in tasksToReschedule)
//                            {
//                                t.Domain.Clear();
//                                foreach (var day in DAYS)
//                                {
//                                    for (int h = 1; h <= HOURS - t.Duration + 1; h++)
//                                    {
//                                        if (IsFreeAndNoConflict(t, day, h, staffOcc, labOcc))
//                                            t.Domain.Add((day, h));
//                                    }
//                                }
//                                if (t.Domain.Count == 0)
//                                {
//                                    // Rollback assignments if no domain exists
//                                    foreach (var revertTask in tasksToReschedule)
//                                        if (!revertTask.IsPlaced && revertTask.Day != null)
//                                            AssignTask(revertTask, (revertTask.Day, revertTask.StartHour));
//                                    continue;
//                                }
//                                Shuffle(t.Domain);
//                            }

//                            if (await GlobalReschedule(tasksToReschedule))
//                                return true;
//                        }
//                    }
//                    return false;
//                }

//                List<TaskUnit> CollectConflictingTasks(TaskUnit task, List<TaskUnit> allTasks)
//                {
//                    var conflicts = new List<TaskUnit>();
//                    var (_, staffCode) = SplitStaff(task.StaffAssigned);

//                    foreach (var other in allTasks)
//                    {
//                        if (other == task || !other.IsPlaced) continue;
//                        bool overlap = other.Day == task.Day && !(other.StartHour + other.Duration <= task.StartHour || task.StartHour + task.Duration <= other.StartHour);
//                        if (overlap)
//                        {
//                            var (_, otherStaffCode) = SplitStaff(other.StaffAssigned);
//                            if (otherStaffCode == staffCode ||
//                                (!string.IsNullOrEmpty(task.LabId) && !string.IsNullOrEmpty(other.LabId) && task.LabId == other.LabId))
//                                conflicts.Add(other);
//                        }
//                    }
//                    return conflicts;
//                }

//                bool solved = await GlobalReschedule(tasks);
//                if (!solved)
//                {
//                    return Ok(new
//                    {
//                        message = "⚠ No solution found with global rescheduling, timetable generation failed.",
//                        receivedPayload = request
//                    });
//                }

//                // Transactionally write to DB
//                using (var tran = conn.BeginTransaction())
//                {
//                    using (var delClass = new NpgsqlCommand(@"
//                        DELETE FROM classtimetable 
//                        WHERE department_id=@department AND year=@year AND semester=@semester AND section=@section;", conn, tran))
//                    {
//                        delClass.Parameters.AddWithValue("@department", request.Department ?? "---");
//                        delClass.Parameters.AddWithValue("@year", request.Year ?? "---");
//                        delClass.Parameters.AddWithValue("@semester", request.Semester ?? "---");
//                        delClass.Parameters.AddWithValue("@section", request.Section ?? "---");
//                        await delClass.ExecuteNonQueryAsync();
//                    }
//                    using (var delLab = new NpgsqlCommand(@"
//                        DELETE FROM labtimetable
//                        WHERE department=@department AND year=@year AND semester=@semester AND section=@section;", conn, tran))
//                    {
//                        delLab.Parameters.AddWithValue("@department", request.Department ?? "---");
//                        delLab.Parameters.AddWithValue("@year", request.Year ?? "---");
//                        delLab.Parameters.AddWithValue("@semester", request.Semester ?? "---");
//                        delLab.Parameters.AddWithValue("@section", request.Section ?? "---");
//                        await delLab.ExecuteNonQueryAsync();
//                    }
//                    foreach (var t in tasks)
//                    {
//                        var (staffName, staffCode) = SplitStaff(t.StaffAssigned);
//                        for (int h = t.StartHour; h < t.StartHour + t.Duration; h++)
//                        {
//                            using (var icClass = new NpgsqlCommand(@"
//                                INSERT INTO classtimetable
//                                (staff_name, staff_code, department_id, year, semester, section, day, hour, subject_code, subject_name)
//                                VALUES
//                                (@staff_name, @staff_code, @department, @year, @semester, @section, @day, @hour, @subject_code, @subject_name);", conn, tran))
//                            {
//                                icClass.Parameters.AddWithValue("@staff_name", staffName ?? "---");
//                                icClass.Parameters.AddWithValue("@staff_code", staffCode ?? "---");
//                                icClass.Parameters.AddWithValue("@department", request.Department ?? "---");
//                                icClass.Parameters.AddWithValue("@year", request.Year ?? "---");
//                                icClass.Parameters.AddWithValue("@semester", request.Semester ?? "---");
//                                icClass.Parameters.AddWithValue("@section", request.Section ?? "---");
//                                icClass.Parameters.AddWithValue("@day", t.Day ?? "---");
//                                icClass.Parameters.AddWithValue("@hour", h);
//                                icClass.Parameters.AddWithValue("@subject_code", t.SubjectCode ?? "---");
//                                icClass.Parameters.AddWithValue("@subject_name", t.SubjectName ?? "---");
//                                await icClass.ExecuteNonQueryAsync();
//                            }
//                        }
//                        if (t.IsLab && !string.IsNullOrEmpty(t.LabId))
//                        {
//                            int labStart = t.StartHour == 4 ? 5 : t.StartHour;
//                            for (int h = labStart; h < t.StartHour + t.Duration; h++)
//                            {
//                                using (var icLab = new NpgsqlCommand(@"
//                                    INSERT INTO labtimetable
//                                    (lab_id, subject_code, subject_name, staff_name, department, year, semester, section, day, hour)
//                                    VALUES
//                                    (@lab_id, @subject_code, @subject_name, @staff_name, @department, @year, @semester, @section, @day, @hour);", conn, tran))
//                                {
//                                    icLab.Parameters.AddWithValue("@lab_id", t.LabId ?? (object)DBNull.Value);
//                                    icLab.Parameters.AddWithValue("@subject_code", t.SubjectCode ?? "---");
//                                    icLab.Parameters.AddWithValue("@subject_name", t.SubjectName ?? "---");
//                                    icLab.Parameters.AddWithValue("@staff_name", staffName ?? "---");
//                                    icLab.Parameters.AddWithValue("@department", request.Department ?? "---");
//                                    icLab.Parameters.AddWithValue("@year", request.Year ?? "---");
//                                    icLab.Parameters.AddWithValue("@semester", request.Semester ?? "---");
//                                    icLab.Parameters.AddWithValue("@section", request.Section ?? "---");
//                                    icLab.Parameters.AddWithValue("@day", t.Day ?? "---");
//                                    icLab.Parameters.AddWithValue("@hour", h);
//                                    await icLab.ExecuteNonQueryAsync();
//                                }
//                            }
//                        }
//                    }
//                    await tran.CommitAsync();
//                }

//                var responseTimetable = timetableGrid.Select(row => new
//                {
//                    Day = row.Key,
//                    HourlySlots = row.Value
//                }).ToList();

//                return Ok(new
//                {
//                    message = "✅ Timetable generated with global rescheduling and constraint propagation successfully.",
//                    timetable = responseTimetable,
//                    usedLabIds = tasks.Where(x => x.IsLab && !string.IsNullOrEmpty(x.LabId)).Select(x => x.LabId).Distinct().ToList(),
//                    receivedPayload = request
//                });
//            }
//            catch (Exception ex)
//            {
//                return StatusCode(500, new { message = "❌ Error generating timetable.", error = ex.Message });
//            }
//        }
//    }
//}





//first perfect backtrack
//using Microsoft.AspNetCore.Mvc;
//using Microsoft.Extensions.Configuration;
//using Npgsql;
//using System;
//using System.Collections.Generic;
//using System.Diagnostics;
//using System.Linq;
//using System.Threading.Tasks;

//namespace Timetablegenerator.Controllers
//{
//    [ApiController]
//    [Route("api/[controller]")]
//    public class TimetableController : ControllerBase
//    {
//        private readonly IConfiguration _configuration;
//        private static readonly Random rng = new Random();

//        public TimetableController(IConfiguration configuration)
//        {
//            _configuration = configuration;
//        }

//        // Collect all related tasks in conflict (sharing staff or lab with the current task) from the database
//        private async Task<List<TaskUnit>> CollectRelatedTasksAsync(
//        TaskUnit task,
//        NpgsqlConnection conn,
//        TimetableRequest request,
//        Dictionary<string, Dictionary<string, HashSet<int>>> staffOcc,
//        Dictionary<string, Dictionary<string, HashSet<int>>> labOcc)
//        {
//            var relatedTasks = new List<TaskUnit>();

//            var involvedStaffIds = new HashSet<string>();
//            var involvedLabIds = new HashSet<string>();

//            var (_, staffCode) = SplitStaff(task.StaffAssigned);
//            involvedStaffIds.Add(staffCode);
//            if (!string.IsNullOrEmpty(task.LabId)) involvedLabIds.Add(task.LabId);

//            // First, get all class timetable entries for involved staff
//            string classSql = @"
//        SELECT staff_code, subject_code, subject_name, day, hour
//        FROM classtimetable
//        WHERE staff_code = ANY(@staffIds)
//          AND year = @year AND semester = @sem AND department_id = @dept AND section = @section
//        ORDER BY day, hour";

//            // Second, get all lab timetable entries for involved labs and staff
//            string labSql = @"
//        SELECT staff_code, subject_code, subject_name, day, hour, lab_id
//        FROM labtimetable
//        WHERE (lab_id = ANY(@labIds) OR staff_code = ANY(@staffIds))
//          AND year = @year AND semester = @sem AND department = @dept AND section = @section
//        ORDER BY day, hour";

//            var entries = new List<(string staff_code, string subject_code, string subject_name, string day, int hour, string lab_id)>();

//            // Query classtable
//            using (var cmd = new NpgsqlCommand(classSql, conn))
//            {
//                cmd.Parameters.AddWithValue("staffIds", involvedStaffIds.ToArray());
//                cmd.Parameters.AddWithValue("year", request.Year);
//                cmd.Parameters.AddWithValue("sem", request.Semester);
//                cmd.Parameters.AddWithValue("dept", request.Department);
//                cmd.Parameters.AddWithValue("section", request.Section);

//                using var reader = await cmd.ExecuteReaderAsync();
//                while (await reader.ReadAsync())
//                {
//                    entries.Add((
//                        reader.GetString(0),
//                        reader.GetString(1),
//                        reader.GetString(2),
//                        reader.GetString(3),
//                        reader.GetInt32(4),
//                        null  // classtable has no lab_id
//                    ));
//                }
//                reader.Close();
//            }

//            // Query labtimetable
//            using (var cmd = new NpgsqlCommand(labSql, conn))
//            {
//                cmd.Parameters.AddWithValue("labIds", involvedLabIds.Count > 0 ? involvedLabIds.ToArray() : new string[] { "" });
//                cmd.Parameters.AddWithValue("staffIds", involvedStaffIds.ToArray());
//                cmd.Parameters.AddWithValue("year", request.Year);
//                cmd.Parameters.AddWithValue("sem", request.Semester);
//                cmd.Parameters.AddWithValue("dept", request.Department);
//                cmd.Parameters.AddWithValue("section", request.Section);

//                using var reader = await cmd.ExecuteReaderAsync();
//                while (await reader.ReadAsync())
//                {
//                    entries.Add((
//                        reader.GetString(0),
//                        reader.GetString(1),
//                        reader.GetString(2),
//                        reader.GetString(3),
//                        reader.GetInt32(4),
//                        reader.IsDBNull(5) ? null : reader.GetString(5)
//                    ));
//                }
//                reader.Close();
//            }

//            // Group entries by subject, staff, day, lab to form continuous task blocks
//            var grouped = entries.GroupBy(e => (e.subject_code, e.staff_code, e.lab_id, e.day));

//            foreach (var group in grouped)
//            {
//                var hours = group.Select(e => e.hour).OrderBy(h => h).ToList();
//                int start = hours.First();
//                int duration = hours.Count;

//                relatedTasks.Add(new TaskUnit
//                {
//                    SubjectCode = group.Key.subject_code,
//                    StaffAssigned = group.Key.staff_code,
//                    SubjectName = group.First().subject_name,
//                    LabId = group.Key.lab_id,
//                    IsLab = !string.IsNullOrEmpty(group.Key.lab_id),
//                    Duration = duration,
//                    Kind = !string.IsNullOrEmpty(group.Key.lab_id) ? "LAB" : "TH",
//                    Day = group.Key.day,
//                    StartHour = start,
//                    IsPlaced = true
//                });
//            }

//            return relatedTasks;
//        }

//        // DTO Classes
//        public class TimetableRequest
//        {
//            public string Department { get; set; }
//            public string Year { get; set; }
//            public string Semester { get; set; }
//            public string Section { get; set; }
//            public int TotalHoursPerDay { get; set; } = 7;
//            public List<SubjectDto> Subjects { get; set; }
//        }

//        public class SubjectDto
//        {
//            public string SubjectCode { get; set; }
//            public string SubjectName { get; set; }
//            public string SubjectType { get; set; }
//            public int Credit { get; set; }
//            public string StaffAssigned { get; set; }
//            public string LabId { get; set; }
//        }

//        public class TaskUnit
//        {
//            public string SubjectCode;
//            public string SubjectName;
//            public string StaffAssigned;
//            public string LabId;
//            public bool IsLab;
//            public int Duration;
//            public string Kind;
//            public string Day;
//            public int StartHour;
//            public bool IsPlaced = false;
//            public List<(string day, int start)> Domain = new();
//        }

//        // Shuffle helper
//        private void Shuffle<T>(IList<T> list)
//        {
//            int n = list.Count;
//            while (n > 1)
//            {
//                n--;
//                int k = rng.Next(n + 1);
//                (list[k], list[n]) = (list[n], list[k]);
//            }
//        }

//        // Staff assignment parser to get code
//        (string staffName, string staffCode) SplitStaff(string staffAssigned)
//        {
//            if (string.IsNullOrWhiteSpace(staffAssigned)) return ("---", "---");
//            var name = staffAssigned;
//            var code = staffAssigned;
//            if (staffAssigned.Contains("("))
//            {
//                var parts = staffAssigned.Split('(', StringSplitOptions.TrimEntries);
//                name = parts[0].Trim();
//                code = parts.Length > 1 ? parts[1].Replace(")", "").Trim() : "---";
//            }
//            return (name, code);
//        }

//        // Main API method
//        [HttpPost("generateCrossDepartmentTimetableBacktracking")]
//        public async Task<IActionResult> GenerateTimetableWithGARescheduling([FromBody] TimetableRequest request)
//        {
//            var cs = _configuration.GetConnectionString("DefaultConnection");
//            await using var conn = new NpgsqlConnection(cs);
//            await conn.OpenAsync();

//            string[] DAYS = new[] { "Mon", "Tue", "Wed", "Thu", "Fri" };
//            int HOURS = Math.Max(1, request.TotalHoursPerDay);
//            var timetableGrid = DAYS.ToDictionary(d => d, d => Enumerable.Range(1, HOURS).ToDictionary(h => h, _ => "---"));
//            var staffOcc = new Dictionary<string, Dictionary<string, HashSet<int>>>();
//            var labOcc = new Dictionary<string, Dictionary<string, HashSet<int>>>();

//            void EnsureDayMap<TKey>(Dictionary<TKey, Dictionary<string, HashSet<int>>> map, TKey key)
//            {
//                if (!map.ContainsKey(key))
//                    map[key] = DAYS.ToDictionary(d => d, _ => new HashSet<int>());
//            }

//            // Load existing staff occupancy
//            await using (var cmd = new NpgsqlCommand("SELECT staff_code, day, hour FROM classtimetable", conn))
//            await using (var rd = await cmd.ExecuteReaderAsync())
//            {
//                while (await rd.ReadAsync())
//                {
//                    var sc = rd["staff_code"] as string ?? "---";
//                    var day = rd["day"] as string ?? "Mon";
//                    var hr = (int)rd["hour"];
//                    EnsureDayMap(staffOcc, sc);
//                    staffOcc[sc][day].Add(hr);
//                }
//            }

//            // Load existing lab occupancy
//            await using (var cmd = new NpgsqlCommand("SELECT lab_id, day, hour FROM labtimetable", conn))
//            await using (var rd = await cmd.ExecuteReaderAsync())
//            {
//                while (await rd.ReadAsync())
//                {
//                    var lab = rd["lab_id"] as string ?? "---";
//                    var day = rd["day"] as string ?? "Mon";
//                    var hr = (int)rd["hour"];
//                    EnsureDayMap(labOcc, lab);
//                    labOcc[lab][day].Add(hr);
//                }
//            }

//            var subjects = request.Subjects?.Where(s => !string.IsNullOrWhiteSpace(s.StaffAssigned)).ToList();
//            if (subjects == null || subjects.Count == 0)
//                return BadRequest(new { message = "❌ No valid subjects with assigned staff found." });

//            var tasks = new List<TaskUnit>();

//            foreach (var s in subjects)
//            {
//                var type = (s.SubjectType ?? "theory").Trim().ToLower();
//                switch (type)
//                {
//                    case "lab":
//                        tasks.Add(new TaskUnit
//                        {
//                            SubjectCode = s.SubjectCode ?? "---",
//                            SubjectName = s.SubjectName ?? "---",
//                            StaffAssigned = s.StaffAssigned,
//                            LabId = s.LabId,
//                            IsLab = true,
//                            Duration = 4,
//                            Kind = "LAB4"
//                        });
//                        break;
//                    case "embedded":
//                        tasks.Add(new TaskUnit
//                        {
//                            SubjectCode = s.SubjectCode ?? "---",
//                            SubjectName = s.SubjectName ?? "---",
//                            StaffAssigned = s.StaffAssigned,
//                            LabId = s.LabId,
//                            IsLab = true,
//                            Duration = 2,
//                            Kind = "EMB_LAB2"
//                        });
//                        tasks.Add(new TaskUnit
//                        {
//                            SubjectCode = s.SubjectCode ?? "---",
//                            SubjectName = s.SubjectName ?? "---",
//                            StaffAssigned = s.StaffAssigned,
//                            IsLab = false,
//                            Duration = 1,
//                            Kind = "EMB_TH1"
//                        });
//                        tasks.Add(new TaskUnit
//                        {
//                            SubjectCode = s.SubjectCode ?? "---",
//                            SubjectName = s.SubjectName ?? "---",
//                            StaffAssigned = s.StaffAssigned,
//                            IsLab = false,
//                            Duration = 1,
//                            Kind = "EMB_TH1"
//                        });
//                        break;
//                    default:
//                        int count = Math.Max(0, s.Credit);
//                        for (int i = 0; i < count; i++)
//                        {
//                            tasks.Add(new TaskUnit
//                            {
//                                SubjectCode = s.SubjectCode ?? "---",
//                                SubjectName = s.SubjectName ?? "---",
//                                StaffAssigned = s.StaffAssigned,
//                                IsLab = false,
//                                Duration = 1,
//                                Kind = "TH1"
//                            });
//                        }
//                        break;
//                }
//            }

//            // Shuffle tasks for randomness
//            Shuffle(tasks);

//            // Initialize domain for each task
//            foreach (var t in tasks)
//            {
//                t.Domain.Clear();
//                foreach (var day in DAYS)
//                {
//                    for (int start = 1; start <= HOURS - t.Duration + 1; start++)
//                    {
//                        if (IsFreeAndNoConflict(t, day, start, staffOcc, labOcc, timetableGrid))
//                        {
//                            t.Domain.Add((day, start));
//                        }
//                    }
//                }
//                if (t.Domain.Count == 0)
//                {
//                    return Ok(new { message = $"No initial available slot for task {t.SubjectCode}.", receivedPayload = request });
//                }
//                Shuffle(t.Domain);
//            }

//            // Recursive backtracking with global conflict handling and GA fallback
//            async Task<bool> BacktrackWithGA(List<TaskUnit> taskList)
//            {
//                if (taskList.All(t => t.IsPlaced)) return true;

//                var currentTask = taskList.Where(t => !t.IsPlaced).OrderBy(t => t.Domain.Count).FirstOrDefault();
//                if (currentTask == null) return true;

//                Shuffle(currentTask.Domain);

//                foreach (var slot in currentTask.Domain)
//                {
//                    if (IsFreeAndNoConflict(currentTask, slot.day, slot.start, staffOcc, labOcc, timetableGrid))
//                    {
//                        AssignTask(currentTask, slot, staffOcc, labOcc, timetableGrid);
//                        if (PropagateConstraints(taskList, currentTask, slot))
//                        {
//                            if (await BacktrackWithGA(taskList)) return true;
//                        }

//                        // Conflict resolution with GA fallback
//                        var conflictTasks = await CollectRelatedTasksAsync(currentTask, conn, request, staffOcc, labOcc);

//                        var reassignmentTasks = new List<TaskUnit> { currentTask };
//                        foreach (var t in conflictTasks)
//                            if (!reassignmentTasks.Contains(t)) reassignmentTasks.Add(t);

//                        foreach (var t in reassignmentTasks)
//                            UnassignTask(t, staffOcc, labOcc, timetableGrid);

//                        var gaResult = await RunGeneticAlgorithmAsync(reassignmentTasks, DAYS, HOURS, staffOcc, labOcc);

//                        if (gaResult.Succeeded)
//                        {
//                            foreach (var t in reassignmentTasks)
//                            {
//                                t.Domain.Clear();
//                                t.Domain.Add((t.Day, t.StartHour));
//                                AssignTask(t, (t.Day, t.StartHour), staffOcc, labOcc, timetableGrid);
//                            }
//                            if (await BacktrackWithGA(taskList)) return true;
//                        }
//                        else
//                        {
//                            foreach (var t in reassignmentTasks)
//                                if (t.Day != null && !t.IsPlaced)
//                                    AssignTask(t, (t.Day, t.StartHour), staffOcc, labOcc, timetableGrid);
//                        }
//                        UnassignTask(currentTask, staffOcc, labOcc, timetableGrid);
//                    }
//                }
//                return false;
//            }

//            // Check if task fits at timeslot without conflicts
//            bool IsFreeAndNoConflict(TaskUnit t, string day, int start,
//                Dictionary<string, Dictionary<string, HashSet<int>>> staffOcc,
//                Dictionary<string, Dictionary<string, HashSet<int>>> labOcc,
//                Dictionary<string, Dictionary<int, string>> timetableGrid)
//            {
//                for (int h = start; h < start + t.Duration; h++)
//                {
//                    if (h < 1 || h > HOURS) return false;
//                    if (timetableGrid[day][h] != "---") return false;
//                }
//                var (_, staffCode) = SplitStaff(t.StaffAssigned);
//                for (int h = start; h < start + t.Duration; h++)
//                {
//                    if (staffOcc.TryGetValue(staffCode, out var dm) && dm.TryGetValue(day, out var set) && set.Contains(h))
//                        return false;
//                }
//                if (t.IsLab && !string.IsNullOrEmpty(t.LabId))
//                {
//                    for (int h = start; h < start + t.Duration; h++)
//                    {
//                        if (labOcc.TryGetValue(t.LabId, out var dm) && dm.TryGetValue(day, out var set) && set.Contains(h))
//                            return false;
//                    }

//                    // Example for lab schedule constraints (4 hour continuous block)
//                    if (t.Kind == "LAB4")
//                    {
//                        if (!(start == 1 || start == 4)) return false;
//                    }
//                }
//                return true;
//            }

//            // Assign task to slot updating data structures
//            void AssignTask(TaskUnit t, (string day, int start) slot,
//                Dictionary<string, Dictionary<string, HashSet<int>>> staffOcc,
//                Dictionary<string, Dictionary<string, HashSet<int>>> labOcc,
//                Dictionary<string, Dictionary<int, string>> timetableGrid)
//            {
//                var (day, start) = slot;
//                var (_, staffCode) = SplitStaff(t.StaffAssigned);
//                for (int h = start; h < start + t.Duration; h++)
//                {
//                    timetableGrid[day][h] = $"{t.SubjectCode} ({t.StaffAssigned})";
//                    if (!staffOcc.ContainsKey(staffCode)) staffOcc[staffCode] = new Dictionary<string, HashSet<int>>();
//                    if (!staffOcc[staffCode].ContainsKey(day)) staffOcc[staffCode][day] = new HashSet<int>();
//                    staffOcc[staffCode][day].Add(h);

//                    if (t.IsLab && !string.IsNullOrEmpty(t.LabId))
//                    {
//                        if (!labOcc.ContainsKey(t.LabId)) labOcc[t.LabId] = new Dictionary<string, HashSet<int>>();
//                        if (!labOcc[t.LabId].ContainsKey(day)) labOcc[t.LabId][day] = new HashSet<int>();
//                        labOcc[t.LabId][day].Add(h);
//                    }
//                }
//                t.Day = day;
//                t.StartHour = start;
//                t.IsPlaced = true;
//            }

//            // Unassign task removing from data structures
//            void UnassignTask(TaskUnit t,
//                Dictionary<string, Dictionary<string, HashSet<int>>> staffOcc,
//                Dictionary<string, Dictionary<string, HashSet<int>>> labOcc,
//                Dictionary<string, Dictionary<int, string>> timetableGrid)
//            {
//                if (!t.IsPlaced) return;
//                var day = t.Day;
//                var start = t.StartHour;
//                var (_, staffCode) = SplitStaff(t.StaffAssigned);
//                for (int h = start; h < start + t.Duration; h++)
//                {
//                    timetableGrid[day][h] = "---";
//                    staffOcc[staffCode][day].Remove(h);
//                    if (t.IsLab && !string.IsNullOrEmpty(t.LabId))
//                        labOcc[t.LabId][day].Remove(h);
//                }
//                t.IsPlaced = false;
//                t.Day = null;
//                t.StartHour = 0;
//            }

//            // Constraint propagation (simple forward checking)
//            bool PropagateConstraints(List<TaskUnit> tasksList, TaskUnit assignedTask, (string day, int start) assignedSlot)
//            {
//                var snapshotDomains = tasksList.ToDictionary(t => t, t => t.Domain.ToList());
//                assignedTask.Domain = new List<(string, int)> { assignedSlot };
//                foreach (var other in tasksList)
//                {
//                    if (other == assignedTask || other.IsPlaced) continue;
//                    var filtered = new List<(string day, int start)>();
//                    foreach (var pos in other.Domain)
//                    {
//                        bool conflict = false;
//                        if (pos.day == assignedSlot.day)
//                        {
//                            int start1 = pos.start;
//                            int end1 = pos.start + other.Duration - 1;
//                            int start2 = assignedSlot.start;
//                            int end2 = assignedSlot.start + assignedTask.Duration - 1;
//                            bool overlap = end1 >= start2 && end2 >= start1;
//                            if (overlap)
//                            {
//                                var (_, staff1) = SplitStaff(other.StaffAssigned);
//                                var (_, staff2) = SplitStaff(assignedTask.StaffAssigned);
//                                if (staff1 == staff2) conflict = true;
//                                if (!conflict && other.IsLab && assignedTask.IsLab &&
//                                    !string.IsNullOrEmpty(other.LabId) && !string.IsNullOrEmpty(assignedTask.LabId) && other.LabId == assignedTask.LabId)
//                                    conflict = true;
//                            }
//                        }
//                        if (!conflict) filtered.Add(pos);
//                    }
//                    other.Domain = filtered;
//                    if (other.Domain.Count == 0)
//                    {
//                        foreach (var kvp in snapshotDomains) kvp.Key.Domain = kvp.Value;
//                        return false;
//                    }
//                }
//                return true;
//            }

//            // Collect all conflicting tasks sharing staff or lab and overlapping times for global rescheduling
//            List<TaskUnit> CollectConflictingTasks(TaskUnit task, List<TaskUnit> allTasks)
//            {
//                var conflicts = new List<TaskUnit>();
//                var (_, staffCode) = SplitStaff(task.StaffAssigned);
//                foreach (var other in allTasks)
//                {
//                    if (other == task || !other.IsPlaced) continue;
//                    bool overlap = other.Day == task.Day && !(other.StartHour + other.Duration <= task.StartHour || task.StartHour + task.Duration <= other.StartHour);
//                    if (overlap)
//                    {
//                        var (_, otherStaffCode) = SplitStaff(other.StaffAssigned);
//                        if (otherStaffCode == staffCode ||
//                            (!string.IsNullOrEmpty(task.LabId) && !string.IsNullOrEmpty(other.LabId) && task.LabId == other.LabId))
//                            conflicts.Add(other);
//                    }
//                }
//                return conflicts;
//            }

//            // Placeholder GA method; replace with your optimizer to solve the subset of tasks conflict-free
//            async Task<(bool Succeeded, List<TaskUnit> Result)> RunGeneticAlgorithmAsync(List<TaskUnit> tasksToAssign,
//                string[] days, int hours,
//                Dictionary<string, Dictionary<string, HashSet<int>>> staffOcc,
//                Dictionary<string, Dictionary<string, HashSet<int>>> labOcc)
//            {
//                // TODO: Implement your GA or Simulated Annealing here to find a feasible schedule for tasksToAssign

//                await Task.Delay(1000); // simulate work

//                // Return failure by default
//                return (false, null);
//            }

//            bool solved = await BacktrackWithGA(tasks);
//            if (!solved)
//                return Ok(new { message = "❌ Could not generate a conflict-free timetable.", receivedPayload = request });

//            // Save to DB atomically
//            await using var transaction = await conn.BeginTransactionAsync();

//            await using (var delClass = new NpgsqlCommand(@"
//            DELETE FROM classtimetable WHERE department_id=@department AND year=@year AND semester=@sem AND section=@section;", conn, transaction))
//            {
//                delClass.Parameters.AddWithValue("department", request.Department ?? "---");
//                delClass.Parameters.AddWithValue("year", request.Year ?? "---");
//                delClass.Parameters.AddWithValue("sem", request.Semester ?? "---");
//                delClass.Parameters.AddWithValue("section", request.Section ?? "---");
//                await delClass.ExecuteNonQueryAsync();
//            }

//            await using (var delLab = new NpgsqlCommand(@"
//            DELETE FROM labtimetable WHERE department=@department AND year=@year AND semester=@sem AND section=@section;", conn, transaction))
//            {
//                delLab.Parameters.AddWithValue("department", request.Department ?? "---");
//                delLab.Parameters.AddWithValue("year", request.Year ?? "---");
//                delLab.Parameters.AddWithValue("sem", request.Semester ?? "---");
//                delLab.Parameters.AddWithValue("section", request.Section ?? "---");
//                await delLab.ExecuteNonQueryAsync();
//            }

//            foreach (var t in tasks)
//            {
//                var (staffName, staffCode) = SplitStaff(t.StaffAssigned);
//                for (int h = t.StartHour; h < t.StartHour + t.Duration; h++)
//                {
//                    await using var icClass = new NpgsqlCommand(@"
//                    INSERT INTO classtimetable
//                    (staff_name, staff_code, department_id, year, semester, section, day, hour, subject_code, subject_name)
//                    VALUES
//                    (@staff_name, @staff_code, @department, @year, @semester, @section, @day, @hour, @subject_code, @subject_name);", conn, transaction);

//                    icClass.Parameters.AddWithValue("@staff_name", staffName ?? "---");
//                    icClass.Parameters.AddWithValue("@staff_code", staffCode ?? "---");
//                    icClass.Parameters.AddWithValue("@department", request.Department ?? "---");
//                    icClass.Parameters.AddWithValue("@year", request.Year ?? "---");
//                    icClass.Parameters.AddWithValue("@semester", request.Semester ?? "---");
//                    icClass.Parameters.AddWithValue("@section", request.Section ?? "---");
//                    icClass.Parameters.AddWithValue("@day", t.Day ?? "---");
//                    icClass.Parameters.AddWithValue("@hour", h);
//                    icClass.Parameters.AddWithValue("@subject_code", t.SubjectCode ?? "---");
//                    icClass.Parameters.AddWithValue("@subject_name", t.SubjectName ?? "---");
//                    await icClass.ExecuteNonQueryAsync();
//                }
//                if (t.IsLab && !string.IsNullOrEmpty(t.LabId))
//                {
//                    int labStart = t.StartHour == 4 ? 5 : t.StartHour;
//                    for (int h = labStart; h < t.StartHour + t.Duration; h++)
//                    {
//                        await using var icLab = new NpgsqlCommand(@"
//                        INSERT INTO labtimetable
//                        (lab_id, subject_code, subject_name, staff_name, department, year, semester, section, day, hour)
//                        VALUES
//                        (@lab_id, @subject_code, @subject_name, @staff_name, @department, @year, @semester, @section, @day, @hour);", conn, transaction);

//                        icLab.Parameters.AddWithValue("@lab_id", t.LabId ?? (object)DBNull.Value);
//                        icLab.Parameters.AddWithValue("@subject_code", t.SubjectCode ?? "---");
//                        icLab.Parameters.AddWithValue("@subject_name", t.SubjectName ?? "---");
//                        icLab.Parameters.AddWithValue("@staff_name", staffName ?? "---");
//                        icLab.Parameters.AddWithValue("@department", request.Department ?? "---");
//                        icLab.Parameters.AddWithValue("@year", request.Year ?? "---");
//                        icLab.Parameters.AddWithValue("@semester", request.Semester ?? "---");
//                        icLab.Parameters.AddWithValue("@section", request.Section ?? "---");
//                        icLab.Parameters.AddWithValue("@day", t.Day ?? "---");
//                        icLab.Parameters.AddWithValue("@hour", h);
//                        await icLab.ExecuteNonQueryAsync();
//                    }
//                }
//            }
//            await transaction.CommitAsync();

//            return Ok(new
//            {
//                message = "✅ Timetable generated successfully with advanced global conflict resolution.",
//                timetable = timetableGrid.Select(t => new { Day = t.Key, Slots = t.Value }),
//                usedLabIds = tasks.Where(t => t.IsLab && !string.IsNullOrEmpty(t.LabId)).Select(t => t.LabId).Distinct(),
//                receivedPayload = request
//            });
//        }
//    }


//}








//deadlock version
//using Microsoft.AspNetCore.Mvc;
//using Microsoft.Extensions.Configuration;
//using Npgsql;
//using System;
//using System.Collections.Generic;
//using System.Diagnostics;
//using System.Linq;
//using System.Threading.Tasks;

//namespace Timetablegenerator.Controllers
//{
//    [ApiController]
//    [Route("api/[controller]")]
//    public class TimetableController : ControllerBase
//    {
//        private readonly IConfiguration _configuration;
//        private static readonly Random rng = new Random();

//        public TimetableController(IConfiguration configuration)
//        {
//            _configuration = configuration;
//        }

//        // ======= DTO CLASSES =======
//        public class TimetableRequest
//        {
//            public string Department { get; set; }
//            public string Year { get; set; }
//            public string Semester { get; set; }
//            public string Section { get; set; }
//            public int TotalHoursPerDay { get; set; } = 7;
//            public List<SubjectDto> Subjects { get; set; }
//        }

//        public class SubjectDto
//        {
//            public string SubjectCode { get; set; }
//            public string SubjectName { get; set; }
//            public string SubjectType { get; set; }
//            public int Credit { get; set; }
//            public string StaffAssigned { get; set; }
//            public string LabId { get; set; }
//        }

//        public class TaskUnit
//        {
//            public string SubjectCode;
//            public string SubjectName;
//            public string StaffAssigned;
//            public string LabId;
//            public bool IsLab;
//            public int Duration;
//            public string Kind;
//            public string Day;
//            public int StartHour;
//            public bool IsPlaced = false;
//            public List<(string day, int start)> Domain = new();
//        }

//        private void Shuffle<T>(IList<T> list)
//        {
//            int n = list.Count;
//            while (n > 1)
//            {
//                n--;
//                int k = rng.Next(n + 1);
//                (list[k], list[n]) = (list[n], list[k]);
//            }
//        }

//        (string staffName, string staffCode) SplitStaff(string staffAssigned)
//        {
//            if (string.IsNullOrWhiteSpace(staffAssigned)) return ("---", "---");
//            var name = staffAssigned;
//            var code = staffAssigned;
//            if (staffAssigned.Contains("("))
//            {
//                var parts = staffAssigned.Split('(', StringSplitOptions.TrimEntries);
//                name = parts[0].Trim();
//                code = parts.Length > 1 ? parts[1].Replace(")", "").Trim() : "---";
//            }
//            return (name, code);
//        }

//        // ======= DEEP CONFLICT GRAPH: Recursively collect all related (conflicting/interdependent) tasks =======
//        private async Task<List<TaskUnit>> CollectConnectedConflictGroupAsync(
//            TaskUnit rootTask, NpgsqlConnection conn, TimetableRequest request)
//        {
//            var vis = new HashSet<(string, string, string, string, int)>(); // (subject, staff, lab, day, hour)
//            var toVisit = new Queue<TaskUnit>();
//            var connected = new List<TaskUnit>();

//            toVisit.Enqueue(rootTask);

//            while (toVisit.Count > 0)
//            {
//                var task = toVisit.Dequeue();

//                // Unique task identity by subject, staff, day, hour
//                for (int dur = 0; dur < task.Duration; dur++)
//                {
//                    var stateKey = (
//                        task.SubjectCode,
//                        task.StaffAssigned,
//                        task.LabId ?? "",
//                        task.Day,
//                        task.StartHour + dur
//                    );
//                    if (vis.Contains(stateKey)) continue;
//                    vis.Add(stateKey);

//                    // Get all DB rows for this staff, lab, time slot
//                    var related = await CollectTasksByStaffLabDayHour(
//                        conn,
//                        request,
//                        task.StaffAssigned,
//                        task.LabId,
//                        task.Day,
//                        task.StartHour + dur
//                    );
//                    foreach (var subtask in related)
//                    {
//                        var k = (
//                            subtask.SubjectCode,
//                            subtask.StaffAssigned,
//                            subtask.LabId ?? "",
//                            subtask.Day,
//                            subtask.StartHour
//                        );
//                        // If not seen yet, add to group
//                        if (!vis.Contains(k))
//                        {
//                            connected.Add(subtask);
//                            toVisit.Enqueue(subtask);
//                        }
//                    }
//                }
//            }
//            // Remove duplicates
//            var distinct = connected
//                .GroupBy(x => (x.SubjectCode, x.StaffAssigned, x.LabId ?? "", x.Day, x.StartHour))
//                .Select(g => g.First()).ToList();

//            return distinct;
//        }

//        // Helper: Collect all TaskUnit at given (staff/lab/day/hour)
//        private async Task<List<TaskUnit>> CollectTasksByStaffLabDayHour(
//            NpgsqlConnection conn, TimetableRequest request, string staffAssigned, string labId, string day, int hour)
//        {
//            var units = new List<TaskUnit>();
//            // Class tasks (No lab_id column)
//            string classSql = @"
//                SELECT subject_code, subject_name, staff_code, day, hour
//                FROM classtimetable
//                WHERE staff_code = @staff AND day=@day AND hour=@hour
//                AND year = @year AND semester = @sem AND department_id = @dept AND section = @section";

//            using (var cmd = new NpgsqlCommand(classSql, conn))
//            {
//                cmd.Parameters.AddWithValue("staff", staffAssigned ?? "---");
//                cmd.Parameters.AddWithValue("day", day ?? "Mon");
//                cmd.Parameters.AddWithValue("hour", hour);
//                cmd.Parameters.AddWithValue("year", request.Year ?? "---");
//                cmd.Parameters.AddWithValue("sem", request.Semester ?? "---");
//                cmd.Parameters.AddWithValue("dept", request.Department ?? "---");
//                cmd.Parameters.AddWithValue("section", request.Section ?? "---");
//                using var rd = await cmd.ExecuteReaderAsync();
//                while (await rd.ReadAsync())
//                {
//                    units.Add(new TaskUnit
//                    {
//                        SubjectCode = rd["subject_code"]?.ToString() ?? "---",
//                        SubjectName = rd["subject_name"]?.ToString() ?? "---",
//                        StaffAssigned = rd["staff_code"]?.ToString() ?? "---",
//                        IsLab = false,
//                        Duration = 1, // Add duration-merging if needed
//                        Kind = "TH",
//                        Day = day,
//                        StartHour = hour,
//                        IsPlaced = true
//                    });
//                }
//                rd.Close();
//            }

//            // Lab tasks
//            string labSql = @"
//                SELECT subject_code, subject_name, staff_code, lab_id, day, hour
//                FROM labtimetable
//                WHERE (lab_id = @lab OR staff_code = @staff) AND day=@day AND hour=@hour
//                AND year = @year AND semester = @sem AND department = @dept AND section = @section";

//            using (var cmd = new NpgsqlCommand(labSql, conn))
//            {
//                cmd.Parameters.AddWithValue("lab", labId ?? "---");
//                cmd.Parameters.AddWithValue("staff", staffAssigned ?? "---");
//                cmd.Parameters.AddWithValue("day", day ?? "Mon");
//                cmd.Parameters.AddWithValue("hour", hour);
//                cmd.Parameters.AddWithValue("year", request.Year ?? "---");
//                cmd.Parameters.AddWithValue("sem", request.Semester ?? "---");
//                cmd.Parameters.AddWithValue("dept", request.Department ?? "---");
//                cmd.Parameters.AddWithValue("section", request.Section ?? "---");
//                using var rd = await cmd.ExecuteReaderAsync();
//                while (await rd.ReadAsync())
//                {
//                    units.Add(new TaskUnit
//                    {
//                        SubjectCode = rd["subject_code"]?.ToString() ?? "---",
//                        SubjectName = rd["subject_name"]?.ToString() ?? "---",
//                        StaffAssigned = rd["staff_code"]?.ToString() ?? "---",
//                        LabId = rd["lab_id"]?.ToString(),
//                        IsLab = true,
//                        Duration = 1,
//                        Kind = "LAB",
//                        Day = day,
//                        StartHour = hour,
//                        IsPlaced = true
//                    });
//                }
//                rd.Close();
//            }

//            return units;
//        }

//        // ======= PRODUCTION GENETIC ALGORITHM FOR TASK SCHEDULING (Conflict subgraph only) =======
//       private async Task<(bool Success, List<TaskUnit> Solution, int generations, string log)>
//    RunGeneticAlgorithmAsync(List<TaskUnit> conflictGroup, string[] DAYS, int HOURS, int maxGenerations = 30000, int maxMinutes = 5)
//{
//    var log = "GA: ";
//    int generations = 0;
//    var stopwatch = Stopwatch.StartNew();
//    int popSize = 80;
//    int eliteCount = 5;

//    var allStaff = conflictGroup.Select(t => t.StaffAssigned).ToHashSet();
//    var allLabs = conflictGroup.Where(t => !string.IsNullOrEmpty(t.LabId)).Select(t => t.LabId).ToHashSet();

//    // Build domain map: possible slots per task
//    Dictionary<TaskUnit, List<(string day, int start)>> domainMap = new();
//    foreach (var t in conflictGroup)
//    {
//        var dom = new List<(string day, int start)>();
//        foreach (var day in DAYS)
//            for (int start = 1; start <= HOURS - t.Duration + 1; start++)
//                dom.Add((day, start));
//        domainMap[t] = dom;
//    }

//    // Create random chromosome: list of (TaskUnit, Slot)
//    List<(TaskUnit Task, (string day, int start) Slot)> RandomChromosome()
//    {
//        var chrom = new List<(TaskUnit, (string, int))>();
//        foreach (var t in conflictGroup)
//        {
//            var possibles = domainMap[t];
//            chrom.Add((t, possibles[rng.Next(possibles.Count)]));
//        }
//        return chrom;
//    }

//    // Scoring: heavy penalty on conflicts, plus crowding penalty
//    int Score(List<(TaskUnit Task, (string day, int start) Slot)> chromosome)
//    {
//        var occ = new Dictionary<(string day, int hour), (string staff, string lab)>();
//        int score = 0;
//        for (int i = 0; i < chromosome.Count; i++)
//        {
//            var (t, slot) = chromosome[i];
//            int start = slot.start;
//            string day = slot.day;
//            for (int h = start; h < start + t.Duration; h++)
//            {
//                var key = (day, h);
//                if (occ.TryGetValue(key, out var assigned))
//                {
//                    if (assigned.staff == t.StaffAssigned)
//                        score += 1_000_000; // hard conflict for staff
//                    if (!string.IsNullOrEmpty(t.LabId) && assigned.lab == t.LabId)
//                        score += 1_000_000; // hard conflict for lab
//                }
//                else
//                {
//                    occ[key] = (t.StaffAssigned, t.LabId ?? "");
//                }
//            }
//        }
//        // Penalize crowded slots (soft penalty)
//        score += chromosome.GroupBy(x => (x.Slot.day, x.Slot.start)).Where(g => g.Count() > 1).Sum(g => (g.Count() - 1) * 100);
//        return score;
//    }

//    // Initialize population
//    List<List<(TaskUnit Task, (string day, int start) Slot)>> population = new();
//    for (int i = 0; i < popSize; i++)
//        population.Add(RandomChromosome());

//    int bestScore = int.MaxValue;
//    List<(TaskUnit Task, (string day, int start) Slot)> best = null;

//    while (generations < maxGenerations && stopwatch.Elapsed.TotalMinutes < maxMinutes)
//    {
//        // Evaluate scores
//        var scored = population.Select(ind => (ind, score: Score(ind))).OrderBy(x => x.score).ToList();

//        if (scored[0].score == 0)
//        {
//            best = scored[0].ind;
//            bestScore = 0;
//            log += $"[GEN {generations}] Perfect solution found.\n";
//            break;
//        }

//        if (scored[0].score < bestScore)
//        {
//            best = scored[0].ind;
//            bestScore = scored[0].score;
//        }

//        if (generations % 1000 == 0)
//            log += $"[GEN {generations}] Best score: {bestScore}\n";

//        // Elitism: preserve top solutions
//        var nextGen = scored.Take(eliteCount).Select(x => x.ind).ToList();

//        // Generate rest of population via crossover and mutation
//        while (nextGen.Count < popSize)
//        {
//            // Tournament selection
//            var parentA = population[rng.Next(popSize)];
//            var parentB = population[rng.Next(popSize)];
//            var winner = Score(parentA) < Score(parentB) ? parentA : parentB;

//            // Crossover: pick genes from winner
//            var child = new List<(TaskUnit, (string, int))>(winner);

//            // Mutation: randomize slot of a random task
//            if (rng.NextDouble() < 0.3)
//            {
//                int idx = rng.Next(child.Count);
//                        var (task, _) = child[idx];
//                        var domList = domainMap[task];
//                var randomSlot = domList[rng.Next(domList.Count)];
//                child[idx] = (task, randomSlot);
//            }

//            nextGen.Add(child);
//        }

//        population = nextGen;
//        generations++;
//    }

//    bool success = bestScore == 0;

//    log += $"Generations:, {generations}\n";
//    log += $"Success:, {success}\n";

//    // Convert best chromosome back to scheduled tasks
//    var solution = best?.Select(x =>
//    {
//        var (task, slot) = x;
//        task.Day = slot.day;
//        task.StartHour = slot.start;
//        task.IsPlaced = true;
//        return task;
//    }).ToList();

//    return (success, solution, generations, log);
//}

//        // ======= MAIN API ENDPOINT ===========
//        [HttpPost("generateCrossDepartmentTimetableBacktracking")]
//        public async Task<IActionResult> GeneratePerfectTimetable([FromBody] TimetableRequest request)
//        {
//            var logDetails = "";
//            var cs = _configuration.GetConnectionString("DefaultConnection");
//            await using var conn = new NpgsqlConnection(cs);
//            await conn.OpenAsync();

//            string[] DAYS = new[] { "Mon", "Tue", "Wed", "Thu", "Fri" };
//            int HOURS = Math.Max(1, request.TotalHoursPerDay);
//            var timetableGrid = DAYS.ToDictionary(d => d, d => Enumerable.Range(1, HOURS).ToDictionary(h => h, _ => "---"));
//            var staffOcc = new Dictionary<string, Dictionary<string, HashSet<int>>>();
//            var labOcc = new Dictionary<string, Dictionary<string, HashSet<int>>>();

//            void EnsureDayMap<TKey>(Dictionary<TKey, Dictionary<string, HashSet<int>>> map, TKey key)
//            {
//                if (!map.ContainsKey(key))
//                    map[key] = DAYS.ToDictionary(d => d, _ => new HashSet<int>());
//            }

//            // Load existing staff occupancy
//            await using (var cmd = new NpgsqlCommand("SELECT staff_code, day, hour FROM classtimetable", conn))
//            await using (var rd = await cmd.ExecuteReaderAsync())
//            {
//                while (await rd.ReadAsync())
//                {
//                    var sc = rd["staff_code"] as string ?? "---";
//                    var day = rd["day"] as string ?? "Mon";
//                    var hr = (int)rd["hour"];
//                    EnsureDayMap(staffOcc, sc);
//                    staffOcc[sc][day].Add(hr);
//                }
//            }
//            // Load existing lab occupancy
//            await using (var cmd = new NpgsqlCommand("SELECT lab_id, day, hour FROM labtimetable", conn))
//            await using (var rd = await cmd.ExecuteReaderAsync())
//            {
//                while (await rd.ReadAsync())
//                {
//                    var lab = rd["lab_id"] as string ?? "---";
//                    var day = rd["day"] as string ?? "Mon";
//                    var hr = (int)rd["hour"];
//                    EnsureDayMap(labOcc, lab);
//                    labOcc[lab][day].Add(hr);
//                }
//            }

//            var subjects = request.Subjects?.Where(s => !string.IsNullOrWhiteSpace(s.StaffAssigned)).ToList();
//            if (subjects == null || subjects.Count == 0)
//                return BadRequest(new { message = "❌ No valid subjects with assigned staff found." });

//            var tasks = new List<TaskUnit>();
//            foreach (var s in subjects)
//            {
//                var type = (s.SubjectType ?? "theory").Trim().ToLower();
//                switch (type)
//                {
//                    case "lab":
//                        tasks.Add(new TaskUnit
//                        {
//                            SubjectCode = s.SubjectCode ?? "---",
//                            SubjectName = s.SubjectName ?? "---",
//                            StaffAssigned = s.StaffAssigned,
//                            LabId = s.LabId,
//                            IsLab = true,
//                            Duration = 4,
//                            Kind = "LAB4"
//                        });
//                        break;
//                    case "embedded":
//                        tasks.Add(new TaskUnit
//                        {
//                            SubjectCode = s.SubjectCode ?? "---",
//                            SubjectName = s.SubjectName ?? "---",
//                            StaffAssigned = s.StaffAssigned,
//                            LabId = s.LabId,
//                            IsLab = true,
//                            Duration = 2,
//                            Kind = "EMB_LAB2"
//                        });
//                        tasks.Add(new TaskUnit
//                        {
//                            SubjectCode = s.SubjectCode ?? "---",
//                            SubjectName = s.SubjectName ?? "---",
//                            StaffAssigned = s.StaffAssigned,
//                            IsLab = false,
//                            Duration = 1,
//                            Kind = "EMB_TH1"
//                        });
//                        tasks.Add(new TaskUnit
//                        {
//                            SubjectCode = s.SubjectCode ?? "---",
//                            SubjectName = s.SubjectName ?? "---",
//                            StaffAssigned = s.StaffAssigned,
//                            IsLab = false,
//                            Duration = 1,
//                            Kind = "EMB_TH1"
//                        });
//                        break;
//                    default:
//                        int count = Math.Max(0, s.Credit);
//                        for (int i = 0; i < count; i++)
//                        {
//                            tasks.Add(new TaskUnit
//                            {
//                                SubjectCode = s.SubjectCode ?? "---",
//                                SubjectName = s.SubjectName ?? "---",
//                                StaffAssigned = s.StaffAssigned,
//                                IsLab = false,
//                                Duration = 1,
//                                Kind = "TH1"
//                            });
//                        }
//                        break;
//                }
//            }

//            Shuffle(tasks);
//            foreach (var t in tasks)
//            {
//                t.Domain.Clear();
//                foreach (var day in DAYS)
//                {
//                    for (int start = 1; start <= HOURS - t.Duration + 1; start++)
//                        t.Domain.Add((day, start));
//                }
//                Shuffle(t.Domain);
//            }

//            // ======= RECURSIVE BACKTRACKING + DEEP GA CONFLICT RESOLUTION =======
//            async Task<bool> SolveWithPerfectGA(List<TaskUnit> remainingTasks)
//            {
//                if (remainingTasks.All(t => t.IsPlaced)) return true;

//                var currentTask = remainingTasks.FirstOrDefault(t => !t.IsPlaced);
//                if (currentTask == null) return true;

//                // Try all possible domain positions
//                foreach (var slot in currentTask.Domain)
//                {
//                    if (IsFreeAndNoConflict(currentTask, slot.day, slot.start, staffOcc, labOcc, timetableGrid))
//                    {
//                        AssignTask(currentTask, slot, staffOcc, labOcc, timetableGrid);
//                        if (await SolveWithPerfectGA(remainingTasks)) return true;
//                        UnassignTask(currentTask, staffOcc, labOcc, timetableGrid);
//                    }
//                }

//                // If all fail, trigger DEEP-GA: connect conflict group and reschedule all as a unit
//                var connectedConflict = await CollectConnectedConflictGroupAsync(currentTask, conn, request);

//                logDetails += $"[DeepGA] Conflict detected for task: {currentTask.SubjectCode} @ {currentTask.Day ?? "?"}-{currentTask.StartHour} " +
//                        $"with {connectedConflict.Count} connected tasks. Starting GA.\n";

//                var (success, solution, generations, gaLog) =
//                    await RunGeneticAlgorithmAsync(connectedConflict, DAYS, HOURS, 30000, 5);

//                logDetails += $"[DeepGA] GA generations: {generations}\n{gaLog}";

//                if (success)
//                {
//                    // Place the found solution into current structures
//                    foreach (var c in connectedConflict)
//                        UnassignTask(c, staffOcc, labOcc, timetableGrid); // Unplace from state

//                    foreach (var t in solution)
//                        AssignTask(t, (t.Day, t.StartHour), staffOcc, labOcc, timetableGrid);

//                    if (await SolveWithPerfectGA(remainingTasks)) return true;
//                }
//                // No solution possible
//                return false;
//            }

//            // Helper checks/ops
//            bool IsFreeAndNoConflict(TaskUnit t, string day, int start,
//                Dictionary<string, Dictionary<string, HashSet<int>>> staffOcc,
//                Dictionary<string, Dictionary<string, HashSet<int>>> labOcc,
//                Dictionary<string, Dictionary<int, string>> timetableGrid)
//            {
//                for (int h = start; h < start + t.Duration; h++)
//                {
//                    if (h < 1 || h > HOURS) return false;
//                    if (timetableGrid[day][h] != "---") return false;
//                }
//                var (_, staffCode) = SplitStaff(t.StaffAssigned);
//                for (int h = start; h < start + t.Duration; h++)
//                {
//                    if (staffOcc.TryGetValue(staffCode, out var dm) && dm.TryGetValue(day, out var set) && set.Contains(h))
//                        return false;
//                }
//                if (t.IsLab && !string.IsNullOrEmpty(t.LabId))
//                {
//                    for (int h = start; h < start + t.Duration; h++)
//                    {
//                        if (labOcc.TryGetValue(t.LabId, out var dm) && dm.TryGetValue(day, out var set) && set.Contains(h))
//                            return false;
//                    }
//                    if (t.Kind == "LAB4")
//                    {
//                        if (!(start == 1 || start == 4)) return false;
//                    }
//                }
//                return true;
//            }

//            void AssignTask(TaskUnit t, (string day, int start) slot,
//                Dictionary<string, Dictionary<string, HashSet<int>>> staffOcc,
//                Dictionary<string, Dictionary<string, HashSet<int>>> labOcc,
//                Dictionary<string, Dictionary<int, string>> timetableGrid)
//            {
//                var (day, start) = slot;
//                var (_, staffCode) = SplitStaff(t.StaffAssigned);
//                for (int h = start; h < start + t.Duration; h++)
//                {
//                    timetableGrid[day][h] = $"{t.SubjectCode} ({t.StaffAssigned})";
//                    if (!staffOcc.ContainsKey(staffCode)) staffOcc[staffCode] = new Dictionary<string, HashSet<int>>();
//                    if (!staffOcc[staffCode].ContainsKey(day)) staffOcc[staffCode][day] = new HashSet<int>();
//                    staffOcc[staffCode][day].Add(h);
//                    if (t.IsLab && !string.IsNullOrEmpty(t.LabId))
//                    {
//                        if (!labOcc.ContainsKey(t.LabId)) labOcc[t.LabId] = new Dictionary<string, HashSet<int>>();
//                        if (!labOcc[t.LabId].ContainsKey(day)) labOcc[t.LabId][day] = new HashSet<int>();
//                        labOcc[t.LabId][day].Add(h);
//                    }
//                }
//                t.Day = day;
//                t.StartHour = start;
//                t.IsPlaced = true;
//            }

//            void UnassignTask(TaskUnit t,
//                Dictionary<string, Dictionary<string, HashSet<int>>> staffOcc,
//                Dictionary<string, Dictionary<string, HashSet<int>>> labOcc,
//                Dictionary<string, Dictionary<int, string>> timetableGrid)
//            {
//                if (!t.IsPlaced) return;
//                var day = t.Day;
//                var start = t.StartHour;
//                var (_, staffCode) = SplitStaff(t.StaffAssigned);
//                for (int h = start; h < start + t.Duration; h++)
//                {
//                    timetableGrid[day][h] = "---";
//                    staffOcc[staffCode][day].Remove(h);
//                    if (t.IsLab && !string.IsNullOrEmpty(t.LabId))
//                        labOcc[t.LabId][day].Remove(h);
//                }
//                t.IsPlaced = false;
//                t.Day = null;
//                t.StartHour = 0;
//            }

//            bool solved = await SolveWithPerfectGA(tasks);

//            if (!solved)
//            {
//                return Ok(new
//                {
//                    message = "❌ Could not generate a conflict-free timetable. Problem is unsatisfiable by both backtracking and GA (exhaustive).",
//                    log = logDetails,
//                    receivedPayload = request
//                });
//            }

//            // Transactionally write new timetable
//            await using var transaction = await conn.BeginTransactionAsync();
//            await using (var delClass = new NpgsqlCommand(@"
//                DELETE FROM classtimetable WHERE department_id=@department AND year=@year AND semester=@sem AND section=@section;", conn, transaction))
//            {
//                delClass.Parameters.AddWithValue("department", request.Department ?? "---");
//                delClass.Parameters.AddWithValue("year", request.Year ?? "---");
//                delClass.Parameters.AddWithValue("sem", request.Semester ?? "---");
//                delClass.Parameters.AddWithValue("section", request.Section ?? "---");
//                await delClass.ExecuteNonQueryAsync();
//            }
//            await using (var delLab = new NpgsqlCommand(@"
//                DELETE FROM labtimetable WHERE department=@department AND year=@year AND semester=@sem AND section=@section;", conn, transaction))
//            {
//                delLab.Parameters.AddWithValue("department", request.Department ?? "---");
//                delLab.Parameters.AddWithValue("year", request.Year ?? "---");
//                delLab.Parameters.AddWithValue("sem", request.Semester ?? "---");
//                delLab.Parameters.AddWithValue("section", request.Section ?? "---");
//                await delLab.ExecuteNonQueryAsync();
//            }
//            foreach (var t in tasks)
//            {
//                var (staffName, staffCode) = SplitStaff(t.StaffAssigned);
//                for (int h = t.StartHour; h < t.StartHour + t.Duration; h++)
//                {
//                    await using var icClass = new NpgsqlCommand(@"
//                        INSERT INTO classtimetable
//                        (staff_name, staff_code, department_id, year, semester, section, day, hour, subject_code, subject_name)
//                        VALUES
//                        (@staff_name, @staff_code, @department, @year, @semester, @section, @day, @hour, @subject_code, @subject_name);", conn, transaction);
//                    icClass.Parameters.AddWithValue("@staff_name", staffName ?? "---");
//                    icClass.Parameters.AddWithValue("@staff_code", staffCode ?? "---");
//                    icClass.Parameters.AddWithValue("@department", request.Department ?? "---");
//                    icClass.Parameters.AddWithValue("@year", request.Year ?? "---");
//                    icClass.Parameters.AddWithValue("@semester", request.Semester ?? "---");
//                    icClass.Parameters.AddWithValue("@section", request.Section ?? "---");
//                    icClass.Parameters.AddWithValue("@day", t.Day ?? "---");
//                    icClass.Parameters.AddWithValue("@hour", h);
//                    icClass.Parameters.AddWithValue("@subject_code", t.SubjectCode ?? "---");
//                    icClass.Parameters.AddWithValue("@subject_name", t.SubjectName ?? "---");
//                    await icClass.ExecuteNonQueryAsync();
//                }
//                if (t.IsLab && !string.IsNullOrEmpty(t.LabId))
//                {
//                    int labStart = t.StartHour == 4 ? 5 : t.StartHour;
//                    for (int h = labStart; h < t.StartHour + t.Duration; h++)
//                    {
//                        await using var icLab = new NpgsqlCommand(@"
//                            INSERT INTO labtimetable
//                            (lab_id, subject_code, subject_name, staff_name, department, year, semester, section, day, hour)
//                            VALUES
//                            (@lab_id, @subject_code, @subject_name, @staff_name, @department, @year, @semester, @section, @day, @hour);", conn, transaction);
//                        icLab.Parameters.AddWithValue("@lab_id", t.LabId ?? (object)DBNull.Value);
//                        icLab.Parameters.AddWithValue("@subject_code", t.SubjectCode ?? "---");
//                        icLab.Parameters.AddWithValue("@subject_name", t.SubjectName ?? "---");
//                        icLab.Parameters.AddWithValue("@staff_name", staffName ?? "---");
//                        icLab.Parameters.AddWithValue("@department", request.Department ?? "---");
//                        icLab.Parameters.AddWithValue("@year", request.Year ?? "---");
//                        icLab.Parameters.AddWithValue("@semester", request.Semester ?? "---");
//                        icLab.Parameters.AddWithValue("@section", request.Section ?? "---");
//                        icLab.Parameters.AddWithValue("@day", t.Day ?? "---");
//                        icLab.Parameters.AddWithValue("@hour", h);
//                        await icLab.ExecuteNonQueryAsync();
//                    }
//                }
//            }
//            await transaction.CommitAsync();

//            return Ok(new
//            {
//                message = "✅ Timetable generated successfully with deep perfect conflict resolution using GA.",
//                timetable = timetableGrid.Select(tg => new { Day = tg.Key, Slots = tg.Value }),
//                log = logDetails,
//                usedLabIds = tasks.Where(t => t.IsLab && !string.IsNullOrEmpty(t.LabId)).Select(t => t.LabId).Distinct(),
//                receivedPayload = request
//            });
//        }
//    }
//}









//second perfect backtrack
//using Microsoft.AspNetCore.Mvc;
//using Microsoft.Extensions.Configuration;
//using Npgsql;
//using System;
//using System.Collections.Generic;
//using System.Linq;
//using System.Threading.Tasks;

//namespace Timetablegenerator.Controllers
//{
//    [ApiController]
//    [Route("api/[controller]")]
//    public class TimetableController : ControllerBase
//    {
//        private readonly IConfiguration _configuration;
//        private static readonly Random rng = new Random();

//        public TimetableController(IConfiguration configuration)
//        {
//            _configuration = configuration;
//        }

//        // Collect all related tasks in conflict (sharing staff or lab with the current task) from the database
//        private async Task<List<TaskUnit>> CollectRelatedTasksAsync(
//            TaskUnit task,
//            NpgsqlConnection conn,
//            TimetableRequest request,
//            Dictionary<string, Dictionary<string, HashSet<int>>> staffOcc,
//            Dictionary<string, Dictionary<string, HashSet<int>>> labOcc)
//        {
//            var relatedTasks = new List<TaskUnit>();
//            var involvedStaffIds = new HashSet<string>();
//            var involvedLabIds = new HashSet<string>();
//            var (_, staffCode) = SplitStaff(task.StaffAssigned);
//            involvedStaffIds.Add(staffCode);
//            if (!string.IsNullOrEmpty(task.LabId)) involvedLabIds.Add(task.LabId);
//            string classSql = @"
//        SELECT staff_code, subject_code, subject_name, day, hour
//        FROM classtimetable
//        WHERE staff_code = ANY(@staffIds)
//          AND year = @year AND semester = @sem AND department_id = @dept AND section = @section
//        ORDER BY day, hour";
//            string labSql = @"
//        SELECT staff_code, subject_code, subject_name, day, hour, lab_id
//        FROM labtimetable
//        WHERE (lab_id = ANY(@labIds) OR staff_code = ANY(@staffIds))
//          AND year = @year AND semester = @sem AND department = @dept AND section = @section
//        ORDER BY day, hour";
//            var entries = new List<(string staff_code, string subject_code, string subject_name, string day, int hour, string lab_id)>();
//            using (var cmd = new NpgsqlCommand(classSql, conn))
//            {
//                cmd.Parameters.AddWithValue("staffIds", involvedStaffIds.ToArray());
//                cmd.Parameters.AddWithValue("year", request.Year);
//                cmd.Parameters.AddWithValue("sem", request.Semester);
//                cmd.Parameters.AddWithValue("dept", request.Department);
//                cmd.Parameters.AddWithValue("section", request.Section);
//                using var reader = await cmd.ExecuteReaderAsync();
//                while (await reader.ReadAsync())
//                {
//                    entries.Add((
//                        reader.GetString(0),
//                        reader.GetString(1),
//                        reader.GetString(2),
//                        reader.GetString(3),
//                        reader.GetInt32(4),
//                        null
//                    ));
//                }
//                reader.Close();
//            }
//            using (var cmd = new NpgsqlCommand(labSql, conn))
//            {
//                cmd.Parameters.AddWithValue("labIds", involvedLabIds.Count > 0 ? involvedLabIds.ToArray() : new string[] { "" });
//                cmd.Parameters.AddWithValue("staffIds", involvedStaffIds.ToArray());
//                cmd.Parameters.AddWithValue("year", request.Year);
//                cmd.Parameters.AddWithValue("sem", request.Semester);
//                cmd.Parameters.AddWithValue("dept", request.Department);
//                cmd.Parameters.AddWithValue("section", request.Section);
//                using var reader = await cmd.ExecuteReaderAsync();
//                while (await reader.ReadAsync())
//                {
//                    entries.Add((
//                        reader.GetString(0),
//                        reader.GetString(1),
//                        reader.GetString(2),
//                        reader.GetString(3),
//                        reader.GetInt32(4),
//                        reader.IsDBNull(5) ? null : reader.GetString(5)
//                    ));
//                }
//                reader.Close();
//            }
//            var grouped = entries.GroupBy(e => (e.subject_code, e.staff_code, e.lab_id, e.day));
//            foreach (var group in grouped)
//            {
//                var hours = group.Select(e => e.hour).OrderBy(h => h).ToList();
//                int start = hours.First();
//                int duration = hours.Count;
//                relatedTasks.Add(new TaskUnit
//                {
//                    SubjectCode = group.Key.subject_code,
//                    StaffAssigned = group.Key.staff_code,
//                    SubjectName = group.First().subject_name,
//                    LabId = group.Key.lab_id,
//                    IsLab = !string.IsNullOrEmpty(group.Key.lab_id),
//                    Duration = duration,
//                    Kind = !string.IsNullOrEmpty(group.Key.lab_id) ? "LAB" : "TH",
//                    Day = group.Key.day,
//                    StartHour = start,
//                    IsPlaced = true
//                });
//            }
//            return relatedTasks;
//        }

//        // DTO Classes
//        public class TimetableRequest
//        {
//            public string Department { get; set; }
//            public string Year { get; set; }
//            public string Semester { get; set; }
//            public string Section { get; set; }
//            public int TotalHoursPerDay { get; set; } = 7;
//            public List<SubjectDto> Subjects { get; set; }
//        }

//        public class SubjectDto
//        {
//            public string SubjectCode { get; set; }
//            public string SubjectName { get; set; }
//            public string SubjectType { get; set; }
//            public int Credit { get; set; }
//            public string StaffAssigned { get; set; }
//            public string LabId { get; set; }
//        }

//        public class TaskUnit
//        {
//            public string SubjectCode;
//            public string SubjectName;
//            public string StaffAssigned;
//            public string LabId;
//            public bool IsLab;
//            public int Duration;
//            public string Kind;
//            public string Day;
//            public int StartHour;
//            public bool IsPlaced = false;
//            public List<(string day, int start)> Domain = new();
//        }

//        // Shuffle helper
//        private void Shuffle<T>(IList<T> list)
//        {
//            int n = list.Count;
//            while (n > 1)
//            {
//                n--;
//                int k = rng.Next(n + 1);
//                (list[k], list[n]) = (list[n], list[k]);
//            }
//        }

//        // Staff assignment parser to get code
//        (string staffName, string staffCode) SplitStaff(string staffAssigned)
//        {
//            if (string.IsNullOrWhiteSpace(staffAssigned)) return ("---", "---");
//            var name = staffAssigned;
//            var code = staffAssigned;
//            if (staffAssigned.Contains("("))
//            {
//                var parts = staffAssigned.Split('(', StringSplitOptions.TrimEntries);
//                name = parts[0].Trim();
//                code = parts.Length > 1 ? parts[1].Replace(")", "").Trim() : "---";
//            }
//            return (name, code);
//        }

//        // Main API method
//        [HttpPost("generateCrossDepartmentTimetableBacktracking")]
//        public async Task<IActionResult> GenerateTimetableWithGARescheduling([FromBody] TimetableRequest request)
//        {
//            var cs = _configuration.GetConnectionString("DefaultConnection");
//            await using var conn = new NpgsqlConnection(cs);
//            await conn.OpenAsync();
//            string[] DAYS = new[] { "Mon", "Tue", "Wed", "Thu", "Fri" };
//            int HOURS = Math.Max(1, request.TotalHoursPerDay);
//            var timetableGrid = DAYS.ToDictionary(d => d, d => Enumerable.Range(1, HOURS).ToDictionary(h => h, _ => "---"));
//            var staffOcc = new Dictionary<string, Dictionary<string, HashSet<int>>>();
//            var labOcc = new Dictionary<string, Dictionary<string, HashSet<int>>>();

//            void EnsureDayMap<TKey>(Dictionary<TKey, Dictionary<string, HashSet<int>>> map, TKey key)
//            {
//                if (!map.ContainsKey(key))
//                    map[key] = DAYS.ToDictionary(d => d, _ => new HashSet<int>());
//            }

//            // Load existing staff occupancy
//            await using (var cmd = new NpgsqlCommand("SELECT staff_code, day, hour FROM classtimetable", conn))
//            await using (var rd = await cmd.ExecuteReaderAsync())
//            {
//                while (await rd.ReadAsync())
//                {
//                    var sc = rd["staff_code"] as string ?? "---";
//                    var day = rd["day"] as string ?? "Mon";
//                    var hr = (int)rd["hour"];
//                    EnsureDayMap(staffOcc, sc);
//                    staffOcc[sc][day].Add(hr);
//                }
//            }

//            // Load existing lab occupancy
//            await using (var cmd = new NpgsqlCommand("SELECT lab_id, day, hour FROM labtimetable", conn))
//            await using (var rd = await cmd.ExecuteReaderAsync())
//            {
//                while (await rd.ReadAsync())
//                {
//                    var lab = rd["lab_id"] as string ?? "---";
//                    var day = rd["day"] as string ?? "Mon";
//                    var hr = (int)rd["hour"];
//                    EnsureDayMap(labOcc, lab);
//                    labOcc[lab][day].Add(hr);
//                }
//            }

//            var subjects = request.Subjects?.Where(s => !string.IsNullOrWhiteSpace(s.StaffAssigned)).ToList();
//            if (subjects == null || subjects.Count == 0)
//                return BadRequest(new { message = "❌ No valid subjects with assigned staff found." });

//            var tasks = new List<TaskUnit>();
//            foreach (var s in subjects)
//            {
//                var type = (s.SubjectType ?? "theory").Trim().ToLower();
//                switch (type)
//                {
//                    case "lab":
//                        tasks.Add(new TaskUnit
//                        {
//                            SubjectCode = s.SubjectCode ?? "---",
//                            SubjectName = s.SubjectName ?? "---",
//                            StaffAssigned = s.StaffAssigned,
//                            LabId = s.LabId,
//                            IsLab = true,
//                            Duration = 4,
//                            Kind = "LAB4"
//                        });
//                        break;
//                    case "embedded":
//                        tasks.Add(new TaskUnit
//                        {
//                            SubjectCode = s.SubjectCode ?? "---",
//                            SubjectName = s.SubjectName ?? "---",
//                            StaffAssigned = s.StaffAssigned,
//                            LabId = s.LabId,
//                            IsLab = true,
//                            Duration = 2,
//                            Kind = "EMB_LAB2"
//                        });
//                        tasks.Add(new TaskUnit
//                        {
//                            SubjectCode = s.SubjectCode ?? "---",
//                            SubjectName = s.SubjectName ?? "---",
//                            StaffAssigned = s.StaffAssigned,
//                            IsLab = false,
//                            Duration = 1,
//                            Kind = "EMB_TH1"
//                        });
//                        tasks.Add(new TaskUnit
//                        {
//                            SubjectCode = s.SubjectCode ?? "---",
//                            SubjectName = s.SubjectName ?? "---",
//                            StaffAssigned = s.StaffAssigned,
//                            IsLab = false,
//                            Duration = 1,
//                            Kind = "EMB_TH1"
//                        });
//                        break;
//                    default:
//                        int count = Math.Max(0, s.Credit);
//                        for (int i = 0; i < count; i++)
//                        {
//                            tasks.Add(new TaskUnit
//                            {
//                                SubjectCode = s.SubjectCode ?? "---",
//                                SubjectName = s.SubjectName ?? "---",
//                                StaffAssigned = s.StaffAssigned,
//                                IsLab = false,
//                                Duration = 1,
//                                Kind = "TH1"
//                            });
//                        }
//                        break;
//                }
//            }

//            // Shuffle tasks for randomness
//            Shuffle(tasks);

//            // Initialize domain for each task
//            foreach (var t in tasks)
//            {
//                t.Domain.Clear();
//                foreach (var day in DAYS)
//                {
//                    for (int start = 1; start <= HOURS - t.Duration + 1; start++)
//                    {
//                        if (IsFreeAndNoConflict(t, day, start, staffOcc, labOcc, timetableGrid))
//                        {
//                            t.Domain.Add((day, start));
//                        }
//                    }
//                }
//                if (t.Domain.Count == 0)
//                {
//                    return Ok(new { message = $"No initial available slot for task {t.SubjectCode}.", receivedPayload = request });
//                }
//                Shuffle(t.Domain);
//            }

//            // Recursive backtracking with global conflict handling and GA fallback
//            async Task<bool> BacktrackWithGA(List<TaskUnit> taskList)
//            {
//                if (taskList.All(t => t.IsPlaced)) return true;
//                var currentTask = taskList.Where(t => !t.IsPlaced).OrderBy(t => t.Domain.Count).FirstOrDefault();
//                if (currentTask == null) return true;
//                Shuffle(currentTask.Domain);
//                foreach (var slot in currentTask.Domain)
//                {
//                    if (IsFreeAndNoConflict(currentTask, slot.day, slot.start, staffOcc, labOcc, timetableGrid))
//                    {
//                        AssignTask(currentTask, slot, staffOcc, labOcc, timetableGrid);
//                        if (PropagateConstraints(taskList, currentTask, slot))
//                        {
//                            if (await BacktrackWithGA(taskList)) return true;
//                        }
//                        // Conflict resolution with GA fallback
//                        var conflictTasks = await CollectRelatedTasksAsync(currentTask, conn, request, staffOcc, labOcc);
//                        var reassignmentTasks = new List<TaskUnit> { currentTask };
//                        foreach (var t in conflictTasks)
//                            if (!reassignmentTasks.Contains(t)) reassignmentTasks.Add(t);
//                        foreach (var t in reassignmentTasks)
//                            UnassignTask(t, staffOcc, labOcc, timetableGrid);
//                        var gaResult = await RunGeneticAlgorithmAsync(reassignmentTasks, DAYS, HOURS, staffOcc, labOcc);
//                        if (gaResult.Succeeded)
//                        {
//                            foreach (var t in reassignmentTasks)
//                            {
//                                t.Domain.Clear();
//                                t.Domain.Add((t.Day, t.StartHour));
//                                AssignTask(t, (t.Day, t.StartHour), staffOcc, labOcc, timetableGrid);
//                            }
//                            if (await BacktrackWithGA(taskList)) return true;
//                        }
//                        else
//                        {
//                            foreach (var t in reassignmentTasks)
//                                if (t.Day != null && !t.IsPlaced)
//                                    AssignTask(t, (t.Day, t.StartHour), staffOcc, labOcc, timetableGrid);
//                        }
//                        UnassignTask(currentTask, staffOcc, labOcc, timetableGrid);
//                    }
//                }
//                return false;
//            }

//            bool IsFreeAndNoConflict(TaskUnit t, string day, int start,
//                Dictionary<string, Dictionary<string, HashSet<int>>> staffOcc,
//                Dictionary<string, Dictionary<string, HashSet<int>>> labOcc,
//                Dictionary<string, Dictionary<int, string>> timetableGrid)
//            {
//                for (int h = start; h < start + t.Duration; h++)
//                {
//                    if (h < 1 || h > HOURS) return false;
//                    if (timetableGrid[day][h] != "---") return false;
//                }
//                var (_, staffCode) = SplitStaff(t.StaffAssigned);
//                for (int h = start; h < start + t.Duration; h++)
//                {
//                    if (staffOcc.TryGetValue(staffCode, out var dm) && dm.TryGetValue(day, out var set) && set.Contains(h))
//                        return false;
//                }
//                if (t.IsLab && !string.IsNullOrEmpty(t.LabId))
//                {
//                    for (int h = start; h < start + t.Duration; h++)
//                    {
//                        if (labOcc.TryGetValue(t.LabId, out var dm) && dm.TryGetValue(day, out var set) && set.Contains(h))
//                            return false;
//                    }
//                    if (t.Kind == "LAB4")
//                    {
//                        if (!(start == 1 || start == 4)) return false;
//                    }
//                }
//                return true;
//            }

//            void AssignTask(TaskUnit t, (string day, int start) slot,
//                Dictionary<string, Dictionary<string, HashSet<int>>> staffOcc,
//                Dictionary<string, Dictionary<string, HashSet<int>>> labOcc,
//                Dictionary<string, Dictionary<int, string>> timetableGrid)
//            {
//                var (day, start) = slot;
//                var (_, staffCode) = SplitStaff(t.StaffAssigned);
//                for (int h = start; h < start + t.Duration; h++)
//                {
//                    timetableGrid[day][h] = $"{t.SubjectCode} ({t.StaffAssigned})";
//                    if (!staffOcc.ContainsKey(staffCode)) staffOcc[staffCode] = new Dictionary<string, HashSet<int>>();
//                    if (!staffOcc[staffCode].ContainsKey(day)) staffOcc[staffCode][day] = new HashSet<int>();
//                    staffOcc[staffCode][day].Add(h);
//                    if (t.IsLab && !string.IsNullOrEmpty(t.LabId))
//                    {
//                        if (!labOcc.ContainsKey(t.LabId)) labOcc[t.LabId] = new Dictionary<string, HashSet<int>>();
//                        if (!labOcc[t.LabId].ContainsKey(day)) labOcc[t.LabId][day] = new HashSet<int>();
//                        labOcc[t.LabId][day].Add(h);
//                    }
//                }
//                t.Day = day;
//                t.StartHour = start;
//                t.IsPlaced = true;
//            }

//            void UnassignTask(TaskUnit t,
//                Dictionary<string, Dictionary<string, HashSet<int>>> staffOcc,
//                Dictionary<string, Dictionary<string, HashSet<int>>> labOcc,
//                Dictionary<string, Dictionary<int, string>> timetableGrid)
//            {
//                if (!t.IsPlaced) return;
//                var day = t.Day;
//                var start = t.StartHour;
//                var (_, staffCode) = SplitStaff(t.StaffAssigned);
//                for (int h = start; h < start + t.Duration; h++)
//                {
//                    timetableGrid[day][h] = "---";
//                    staffOcc[staffCode][day].Remove(h);
//                    if (t.IsLab && !string.IsNullOrEmpty(t.LabId))
//                        labOcc[t.LabId][day].Remove(h);
//                }
//                t.IsPlaced = false;
//                t.Day = null;
//                t.StartHour = 0;
//            }

//            bool PropagateConstraints(List<TaskUnit> tasksList, TaskUnit assignedTask, (string day, int start) assignedSlot)
//            {
//                var snapshotDomains = tasksList.ToDictionary(t => t, t => t.Domain.ToList());
//                assignedTask.Domain = new List<(string, int)> { assignedSlot };
//                foreach (var other in tasksList)
//                {
//                    if (other == assignedTask || other.IsPlaced) continue;
//                    var filtered = new List<(string day, int start)>();
//                    foreach (var pos in other.Domain)
//                    {
//                        bool conflict = false;
//                        if (pos.day == assignedSlot.day)
//                        {
//                            int start1 = pos.start;
//                            int end1 = pos.start + other.Duration - 1;
//                            int start2 = assignedSlot.start;
//                            int end2 = assignedSlot.start + assignedTask.Duration - 1;
//                            bool overlap = end1 >= start2 && end2 >= start1;
//                            if (overlap)
//                            {
//                                var (_, staff1) = SplitStaff(other.StaffAssigned);
//                                var (_, staff2) = SplitStaff(assignedTask.StaffAssigned);
//                                if (staff1 == staff2) conflict = true;
//                                if (!conflict && other.IsLab && assignedTask.IsLab &&
//                                    !string.IsNullOrEmpty(other.LabId) && !string.IsNullOrEmpty(assignedTask.LabId) && other.LabId == assignedTask.LabId)
//                                    conflict = true;
//                            }
//                        }
//                        if (!conflict) filtered.Add(pos);
//                    }
//                    other.Domain = filtered;
//                    if (other.Domain.Count == 0)
//                    {
//                        foreach (var kvp in snapshotDomains) kvp.Key.Domain = kvp.Value;
//                        return false;
//                    }
//                }
//                return true;
//            }

//            // RunGeneticAlgorithmAsync: implements GA to find conflict-free assignment of conflicting tasks
//            async Task<(bool Succeeded, List<TaskUnit> Result)> RunGeneticAlgorithmAsync(
//                List<TaskUnit> tasksToAssign,
//                string[] days,
//                int hours,
//                Dictionary<string, Dictionary<string, HashSet<int>>> staffOcc,
//                Dictionary<string, Dictionary<string, HashSet<int>>> labOcc)
//            {
//                const int populationSize = 30;
//                const int maxGenerations = 100;
//                const double mutationRate = 0.1;

//                bool CanPlace(TaskUnit t, string day, int start)
//                {
//                    if (start < 1 || start + t.Duration - 1 > hours)
//                        return false;

//                    var (_, staffCode) = SplitStaff(t.StaffAssigned);
//                    for (int h = start; h < start + t.Duration; h++)
//                    {
//                        if (staffOcc.TryGetValue(staffCode, out var dayMap) && dayMap.TryGetValue(day, out var staffHours) && staffHours.Contains(h))
//                            return false;
//                        if (t.IsLab && !string.IsNullOrEmpty(t.LabId))
//                        {
//                            if (labOcc.TryGetValue(t.LabId, out var labDayMap) && labDayMap.TryGetValue(day, out var labHours) && labHours.Contains(h))
//                                return false;
//                        }
//                    }
//                    // Lab continuous block constraint example (4-hour slot must start at 1 or 4)
//                    if (t.IsLab && t.Duration == 4 && !(start == 1 || start == 4))
//                        return false;

//                    return true;
//                }

//                List<TaskUnit> CreateRandomIndividual()
//                {
//                    var individual = new List<TaskUnit>();
//                    foreach (var t in tasksToAssign)
//                    {
//                        var validSlots = new List<(string day, int start)>();
//                        foreach (var day in days)
//                        {
//                            for (int start = 1; start <= hours - t.Duration + 1; start++)
//                            {
//                                if (CanPlace(t, day, start))
//                                    validSlots.Add((day, start));
//                            }
//                        }
//                        if (validSlots.Count == 0)
//                            return null; // no valid slot

//                        var chosen = validSlots[rng.Next(validSlots.Count)];
//                        var copy = new TaskUnit
//                        {
//                            SubjectCode = t.SubjectCode,
//                            StaffAssigned = t.StaffAssigned,
//                            LabId = t.LabId,
//                            IsLab = t.IsLab,
//                            Duration = t.Duration,
//                            Day = chosen.day,
//                            StartHour = chosen.start,
//                            IsPlaced = true
//                        };
//                        individual.Add(copy);
//                    }
//                    return individual;
//                }

//                int Fitness(List<TaskUnit> individual)
//                {
//                    int penalty = 0;

//                    var staffSchedule = new Dictionary<string, Dictionary<string, HashSet<int>>>();
//                    var labSchedule = new Dictionary<string, Dictionary<string, HashSet<int>>>();

//                    foreach (var t in tasksToAssign)
//                    {
//                        var (_, staffCode) = SplitStaff(t.StaffAssigned);
//                        if (!staffSchedule.ContainsKey(staffCode))
//                            staffSchedule[staffCode] = days.ToDictionary(d => d, _ => new HashSet<int>());
//                        if (t.IsLab && !string.IsNullOrEmpty(t.LabId) && !labSchedule.ContainsKey(t.LabId))
//                            labSchedule[t.LabId] = days.ToDictionary(d => d, _ => new HashSet<int>());
//                    }

//                    foreach (var t in individual)
//                    {
//                        var (_, staffCode) = SplitStaff(t.StaffAssigned);
//                        for (int h = t.StartHour; h < t.StartHour + t.Duration; h++)
//                        {
//                            if (staffOcc.TryGetValue(staffCode, out var dayMap) && dayMap.TryGetValue(t.Day, out var existingHours) && existingHours.Contains(h))
//                                penalty += 10;
//                            if (t.IsLab && !string.IsNullOrEmpty(t.LabId) && labOcc.TryGetValue(t.LabId, out var labDayMap) && labDayMap.TryGetValue(t.Day, out var labExisting) && labExisting.Contains(h))
//                                penalty += 10;

//                            if (staffSchedule[staffCode][t.Day].Contains(h))
//                                penalty += 5;
//                            else
//                                staffSchedule[staffCode][t.Day].Add(h);

//                            if (t.IsLab && !string.IsNullOrEmpty(t.LabId))
//                            {
//                                if (labSchedule[t.LabId][t.Day].Contains(h))
//                                    penalty += 5;
//                                else
//                                    labSchedule[t.LabId][t.Day].Add(h);
//                            }
//                        }
//                        if (t.IsLab && t.Duration == 4 && !(t.StartHour == 1 || t.StartHour == 4))
//                            penalty += 20;
//                    }
//                    return penalty;
//                }

//                List<TaskUnit> TournamentSelection(List<List<TaskUnit>> population)
//                {
//                    int k = 3;
//                    var selected = new List<List<TaskUnit>>();
//                    for (int i = 0; i < k; i++)
//                        selected.Add(population[rng.Next(population.Count)]);
//                    return selected.OrderBy(ind => Fitness(ind)).First();
//                }

//                (List<TaskUnit>, List<TaskUnit>) Crossover(List<TaskUnit> parent1, List<TaskUnit> parent2)
//                {
//                    int point = rng.Next(1, parent1.Count);
//                    var child1 = new List<TaskUnit>();
//                    var child2 = new List<TaskUnit>();
//                    for (int i = 0; i < parent1.Count; i++)
//                    {
//                        child1.Add(i < point ? parent1[i] : parent2[i]);
//                        child2.Add(i < point ? parent2[i] : parent1[i]);
//                    }
//                    return (child1, child2);
//                }

//                void Mutate(List<TaskUnit> individual)
//                {
//                    for (int i = 0; i < individual.Count; i++)
//                    {
//                        if (rng.NextDouble() < mutationRate)
//                        {
//                            var t = tasksToAssign[i];
//                            var validSlots = new List<(string day, int start)>();
//                            foreach (var day in days)
//                            {
//                                for (int start = 1; start <= hours - t.Duration + 1; start++)
//                                {
//                                    if (CanPlace(t, day, start))
//                                        validSlots.Add((day, start));
//                                }
//                            }
//                            if (validSlots.Count > 0)
//                            {
//                                var chosen = validSlots[rng.Next(validSlots.Count)];
//                                individual[i].Day = chosen.day;
//                                individual[i].StartHour = chosen.start;
//                            }
//                        }
//                    }
//                }

//                var population = new List<List<TaskUnit>>();
//                for (int i = 0; i < populationSize; i++)
//                {
//                    var individual = CreateRandomIndividual();
//                    if (individual != null)
//                        population.Add(individual);
//                }
//                if (population.Count == 0)
//                    return (false, null);

//                for (int gen = 0; gen < maxGenerations; gen++)
//                {
//                    population = population.OrderBy(ind => Fitness(ind)).ToList();

//                    var best = population[0];
//                    if (Fitness(best) == 0)
//                    {
//                        return (true, best);
//                    }

//                    var nextGen = new List<List<TaskUnit>>();
//                    nextGen.Add(population[0]);
//                    nextGen.Add(population[1]);

//                    while (nextGen.Count < populationSize)
//                    {
//                        var parent1 = TournamentSelection(population);
//                        var parent2 = TournamentSelection(population);

//                        var (child1, child2) = Crossover(parent1, parent2);

//                        Mutate(child1);
//                        Mutate(child2);

//                        nextGen.Add(child1);
//                        if (nextGen.Count < populationSize)
//                            nextGen.Add(child2);
//                    }
//                    population = nextGen;
//                }

//                population = population.OrderBy(ind => Fitness(ind)).ToList();
//                if (Fitness(population[0]) == 0)
//                    return (true, population[0]);

//                return (false, null);
//            }

//            bool solved = await BacktrackWithGA(tasks);

//            if (!solved)
//                return Ok(new { message = "❌ Could not generate a conflict-free timetable.", receivedPayload = request });

//            // Save to DB atomically
//            await using var transaction = await conn.BeginTransactionAsync();

//            await using (var delClass = new NpgsqlCommand(@"
//            DELETE FROM classtimetable WHERE department_id=@department AND year=@year AND semester=@sem AND section=@section;", conn, transaction))
//            {
//                delClass.Parameters.AddWithValue("department", request.Department ?? "---");
//                delClass.Parameters.AddWithValue("year", request.Year ?? "---");
//                delClass.Parameters.AddWithValue("sem", request.Semester ?? "---");
//                delClass.Parameters.AddWithValue("section", request.Section ?? "---");
//                await delClass.ExecuteNonQueryAsync();
//            }

//            await using (var delLab = new NpgsqlCommand(@"
//            DELETE FROM labtimetable WHERE department=@department AND year=@year AND semester=@sem AND section=@section;", conn, transaction))
//            {
//                delLab.Parameters.AddWithValue("department", request.Department ?? "---");
//                delLab.Parameters.AddWithValue("year", request.Year ?? "---");
//                delLab.Parameters.AddWithValue("sem", request.Semester ?? "---");
//                delLab.Parameters.AddWithValue("section", request.Section ?? "---");
//                await delLab.ExecuteNonQueryAsync();
//            }

//            foreach (var t in tasks)
//            {
//                var (staffName, staffCode) = SplitStaff(t.StaffAssigned);
//                for (int h = t.StartHour; h < t.StartHour + t.Duration; h++)
//                {
//                    await using var icClass = new NpgsqlCommand(@"
//                    INSERT INTO classtimetable
//                    (staff_name, staff_code, department_id, year, semester, section, day, hour, subject_code, subject_name)
//                    VALUES
//                    (@staff_name, @staff_code, @department, @year, @semester, @section, @day, @hour, @subject_code, @subject_name);", conn, transaction);
//                    icClass.Parameters.AddWithValue("@staff_name", staffName ?? "---");
//                    icClass.Parameters.AddWithValue("@staff_code", staffCode ?? "---");
//                    icClass.Parameters.AddWithValue("@department", request.Department ?? "---");
//                    icClass.Parameters.AddWithValue("@year", request.Year ?? "---");
//                    icClass.Parameters.AddWithValue("@semester", request.Semester ?? "---");
//                    icClass.Parameters.AddWithValue("@section", request.Section ?? "---");
//                    icClass.Parameters.AddWithValue("@day", t.Day ?? "---");
//                    icClass.Parameters.AddWithValue("@hour", h);
//                    icClass.Parameters.AddWithValue("@subject_code", t.SubjectCode ?? "---");
//                    icClass.Parameters.AddWithValue("@subject_name", t.SubjectName ?? "---");
//                    await icClass.ExecuteNonQueryAsync();
//                }
//                if (t.IsLab && !string.IsNullOrEmpty(t.LabId))
//                {
//                    int labStart = t.StartHour == 4 ? 5 : t.StartHour;
//                    for (int h = labStart; h < t.StartHour + t.Duration; h++)
//                    {
//                        await using var icLab = new NpgsqlCommand(@"
//                        INSERT INTO labtimetable
//                        (lab_id, subject_code, subject_name, staff_name, department, year, semester, section, day, hour)
//                        VALUES
//                        (@lab_id, @subject_code, @subject_name, @staff_name, @department, @year, @semester, @section, @day, @hour);", conn, transaction);
//                        icLab.Parameters.AddWithValue("@lab_id", t.LabId ?? (object)DBNull.Value);
//                        icLab.Parameters.AddWithValue("@subject_code", t.SubjectCode ?? "---");
//                        icLab.Parameters.AddWithValue("@subject_name", t.SubjectName ?? "---");
//                        icLab.Parameters.AddWithValue("@staff_name", staffName ?? "---");
//                        icLab.Parameters.AddWithValue("@department", request.Department ?? "---");
//                        icLab.Parameters.AddWithValue("@year", request.Year ?? "---");
//                        icLab.Parameters.AddWithValue("@semester", request.Semester ?? "---");
//                        icLab.Parameters.AddWithValue("@section", request.Section ?? "---");
//                        icLab.Parameters.AddWithValue("@day", t.Day ?? "---");
//                        icLab.Parameters.AddWithValue("@hour", h);
//                        await icLab.ExecuteNonQueryAsync();
//                    }
//                }
//            }

//            await transaction.CommitAsync();

//            return Ok(new
//            {
//                message = "✅ Timetable generated successfully with advanced global conflict resolution.",
//                timetable = timetableGrid.Select(t => new { Day = t.Key, Slots = t.Value }),
//                usedLabIds = tasks.Where(t => t.IsLab && !string.IsNullOrEmpty(t.LabId)).Select(t => t.LabId).Distinct(),
//                receivedPayload = request
//            });
//        }
//    }
//}










//1 step away from perfection
//using Microsoft.AspNetCore.Mvc;
//using Microsoft.Extensions.Configuration;
//using Npgsql;
//using System;
//using System.Collections.Generic;
//using System.Linq;
//using System.Threading.Tasks;

//namespace Timetablegenerator.Controllers
//{
//    [ApiController]
//    [Route("api/[controller]")]
//    public class TimetableController : ControllerBase
//    {
//        private readonly IConfiguration _configuration;
//        private static readonly Random rng = new Random();

//        public TimetableController(IConfiguration configuration)
//        {
//            _configuration = configuration;
//        }

//        #region DTOs
//        public class TimetableRequest
//        {
//            public string Department { get; set; }
//            public string Year { get; set; }
//            public string Semester { get; set; }
//            public string Section { get; set; }
//            public int TotalHoursPerDay { get; set; } = 7;
//            public List<SubjectDto> Subjects { get; set; }
//        }

//        public class SubjectDto
//        {
//            public string SubjectCode { get; set; }
//            public string SubjectName { get; set; }
//            public string SubjectType { get; set; }
//            public int Credit { get; set; }
//            public string StaffAssigned { get; set; }
//            public string LabId { get; set; }
//        }

//        public class TaskUnit
//        {
//            public string SubjectCode;
//            public string SubjectName;
//            public string StaffAssigned;
//            public string LabId;
//            public bool IsLab;
//            public int Duration;
//            public string Kind;
//            public string Day;
//            public int StartHour;
//            public bool IsPlaced = false;
//            public List<(string day, int start)> Domain = new();
//        }
//        #endregion

//        #region Helper Methods
//        private void Shuffle<T>(IList<T> list)
//        {
//            int n = list.Count;
//            while (n > 1)
//            {
//                n--;
//                int k = rng.Next(n + 1);
//                (list[k], list[n]) = (list[n], list[k]);
//            }
//        }

//        private (string staffName, string staffCode) SplitStaff(string staffAssigned)
//        {
//            if (string.IsNullOrWhiteSpace(staffAssigned)) return ("---", "---");
//            var name = staffAssigned;
//            var code = staffAssigned;
//            if (staffAssigned.Contains("("))
//            {
//                var parts = staffAssigned.Split('(', StringSplitOptions.TrimEntries);
//                name = parts[0].Trim();
//                code = parts.Length > 1 ? parts[1].Replace(")", "").Trim() : "---";
//            }
//            return (name, code);
//        }

//        private bool IsFreeAndNoConflict(TaskUnit t, string day, int start,
//            Dictionary<string, Dictionary<string, HashSet<int>>> staffOcc,
//            Dictionary<string, Dictionary<string, HashSet<int>>> labOcc,
//            Dictionary<string, Dictionary<int, string>> timetableGrid,
//            int totalHours)
//        {
//            for (int h = start; h < start + t.Duration; h++)
//            {
//                if (h < 1 || h > totalHours) return false;
//                if (timetableGrid[day][h] != "---") return false;
//            }
//            var (_, staffCode) = SplitStaff(t.StaffAssigned);
//            for (int h = start; h < start + t.Duration; h++)
//            {
//                if (staffOcc.TryGetValue(staffCode, out var dm) && dm.TryGetValue(day, out var set) && set.Contains(h))
//                    return false;
//            }
//            if (t.IsLab && !string.IsNullOrEmpty(t.LabId))
//            {
//                for (int h = start; h < start + t.Duration; h++)
//                {
//                    if (labOcc.TryGetValue(t.LabId, out var dm) && dm.TryGetValue(day, out var set) && set.Contains(h))
//                        return false;
//                }
//                // Specific lab constraint: 4-hour labs start only at 1 or 4
//                if (t.Kind == "LAB4" && !(start == 1 || start == 4))
//                    return false;
//            }
//            return true;
//        }

//        private void AssignTask(TaskUnit t, (string day, int start) slot,
//            Dictionary<string, Dictionary<string, HashSet<int>>> staffOcc,
//            Dictionary<string, Dictionary<string, HashSet<int>>> labOcc,
//            Dictionary<string, Dictionary<int, string>> timetableGrid)
//        {
//            var (day, start) = slot;
//            var (_, staffCode) = SplitStaff(t.StaffAssigned);
//            for (int h = start; h < start + t.Duration; h++)
//            {
//                timetableGrid[day][h] = $"{t.SubjectCode} ({t.StaffAssigned})";
//                if (!staffOcc.ContainsKey(staffCode)) staffOcc[staffCode] = new Dictionary<string, HashSet<int>>();
//                if (!staffOcc[staffCode].ContainsKey(day)) staffOcc[staffCode][day] = new HashSet<int>();
//                staffOcc[staffCode][day].Add(h);
//                if (t.IsLab && !string.IsNullOrEmpty(t.LabId))
//                {
//                    if (!labOcc.ContainsKey(t.LabId)) labOcc[t.LabId] = new Dictionary<string, HashSet<int>>();
//                    if (!labOcc[t.LabId].ContainsKey(day)) labOcc[t.LabId][day] = new HashSet<int>();
//                    labOcc[t.LabId][day].Add(h);
//                }
//            }
//            t.Day = day;
//            t.StartHour = start;
//            t.IsPlaced = true;
//        }

//        private void UnassignTask(TaskUnit t,
//            Dictionary<string, Dictionary<string, HashSet<int>>> staffOcc,
//            Dictionary<string, Dictionary<string, HashSet<int>>> labOcc,
//            Dictionary<string, Dictionary<int, string>> timetableGrid)
//        {
//            if (!t.IsPlaced) return;
//            var day = t.Day;
//            var start = t.StartHour;
//            var (_, staffCode) = SplitStaff(t.StaffAssigned);
//            for (int h = start; h < start + t.Duration; h++)
//            {
//                timetableGrid[day][h] = "---";
//                staffOcc[staffCode][day].Remove(h);
//                if (t.IsLab && !string.IsNullOrEmpty(t.LabId))
//                    labOcc[t.LabId][day].Remove(h);
//            }
//            t.IsPlaced = false;
//            t.Day = null;
//            t.StartHour = 0;
//        }

//        private bool PropagateConstraints(List<TaskUnit> tasksList, TaskUnit assignedTask, (string day, int start) assignedSlot)
//        {
//            // Stronger domain pruning with dependency checks
//            var snapshotDomains = tasksList.ToDictionary(t => t, t => t.Domain.ToList());
//            assignedTask.Domain = new List<(string, int)> { assignedSlot };

//            foreach (var other in tasksList)
//            {
//                if (other == assignedTask || other.IsPlaced) continue;
//                var filtered = new List<(string day, int start)>();
//                foreach (var pos in other.Domain)
//                {
//                    bool conflict = false;
//                    if (pos.day == assignedSlot.day)
//                    {
//                        int start1 = pos.start;
//                        int end1 = pos.start + other.Duration - 1;
//                        int start2 = assignedSlot.start;
//                        int end2 = assignedSlot.start + assignedTask.Duration - 1;
//                        bool overlap = end1 >= start2 && end2 >= start1;
//                        if (overlap)
//                        {
//                            var (_, staff1) = SplitStaff(other.StaffAssigned);
//                            var (_, staff2) = SplitStaff(assignedTask.StaffAssigned);
//                            if (staff1 == staff2) conflict = true;

//                            if (!conflict && other.IsLab && assignedTask.IsLab &&
//                                !string.IsNullOrEmpty(other.LabId) && !string.IsNullOrEmpty(assignedTask.LabId) && other.LabId == assignedTask.LabId)
//                                conflict = true;
//                        }
//                    }
//                    if (!conflict) filtered.Add(pos);
//                }
//                other.Domain = filtered;
//                if (other.Domain.Count == 0)
//                {
//                    foreach (var kvp in snapshotDomains) kvp.Key.Domain = kvp.Value;
//                    return false;
//                }
//            }

//            return true;
//        }

//        private async Task<List<TaskUnit>> CollectRelatedTasksAsync(
//            TaskUnit task,
//            NpgsqlConnection conn,
//            TimetableRequest request,
//            Dictionary<string, Dictionary<string, HashSet<int>>> staffOcc,
//            Dictionary<string, Dictionary<string, HashSet<int>>> labOcc)
//        {
//            var relatedTasks = new List<TaskUnit>();
//            var involvedStaffIds = new HashSet<string>();
//            var involvedLabIds = new HashSet<string>();

//            var (_, staffCode) = SplitStaff(task.StaffAssigned);
//            involvedStaffIds.Add(staffCode);
//            if (!string.IsNullOrEmpty(task.LabId)) involvedLabIds.Add(task.LabId);

//            string classSql = @"
//                SELECT staff_code, subject_code, subject_name, day, hour
//                FROM classtimetable
//                WHERE staff_code = ANY(@staffIds)
//                  AND year = @year AND semester = @sem AND department_id = @dept AND section = @section
//                ORDER BY day, hour";

//            string labSql = @"
//                SELECT staff_code, subject_code, subject_name, day, hour, lab_id
//                FROM labtimetable
//                WHERE (lab_id = ANY(@labIds) OR staff_code = ANY(@staffIds))
//                  AND year = @year AND semester = @sem AND department = @dept AND section = @section
//                ORDER BY day, hour";

//            var entries = new List<(string staff_code, string subject_code, string subject_name, string day, int hour, string lab_id)>();

//            using (var cmd = new NpgsqlCommand(classSql, conn))
//            {
//                cmd.Parameters.AddWithValue("staffIds", involvedStaffIds.ToArray());
//                cmd.Parameters.AddWithValue("year", request.Year);
//                cmd.Parameters.AddWithValue("sem", request.Semester);
//                cmd.Parameters.AddWithValue("dept", request.Department);
//                cmd.Parameters.AddWithValue("section", request.Section);

//                using var reader = await cmd.ExecuteReaderAsync();
//                while (await reader.ReadAsync())
//                {
//                    entries.Add((
//                        reader.GetString(0),
//                        reader.GetString(1),
//                        reader.GetString(2),
//                        reader.GetString(3),
//                        reader.GetInt32(4),
//                        null
//                    ));
//                }
//                reader.Close();
//            }

//            using (var cmd = new NpgsqlCommand(labSql, conn))
//            {
//                cmd.Parameters.AddWithValue("labIds", involvedLabIds.Count > 0 ? involvedLabIds.ToArray() : new string[] { "" });
//                cmd.Parameters.AddWithValue("staffIds", involvedStaffIds.ToArray());
//                cmd.Parameters.AddWithValue("year", request.Year);
//                cmd.Parameters.AddWithValue("sem", request.Semester);
//                cmd.Parameters.AddWithValue("dept", request.Department);
//                cmd.Parameters.AddWithValue("section", request.Section);

//                using var reader = await cmd.ExecuteReaderAsync();
//                while (await reader.ReadAsync())
//                {
//                    entries.Add((
//                        reader.GetString(0),
//                        reader.GetString(1),
//                        reader.GetString(2),
//                        reader.GetString(3),
//                        reader.GetInt32(4),
//                        reader.IsDBNull(5) ? null : reader.GetString(5)
//                    ));
//                }
//                reader.Close();
//            }

//            var grouped = entries.GroupBy(e => (e.subject_code, e.staff_code, e.lab_id, e.day));
//            foreach (var group in grouped)
//            {
//                var hours = group.Select(e => e.hour).OrderBy(h => h).ToList();
//                int start = hours.First();
//                int duration = hours.Count;
//                relatedTasks.Add(new TaskUnit
//                {
//                    SubjectCode = group.Key.subject_code,
//                    StaffAssigned = group.Key.staff_code,
//                    SubjectName = group.First().subject_name,
//                    LabId = group.Key.lab_id,
//                    IsLab = !string.IsNullOrEmpty(group.Key.lab_id),
//                    Duration = duration,
//                    Kind = !string.IsNullOrEmpty(group.Key.lab_id) ? "LAB" : "TH",
//                    Day = group.Key.day,
//                    StartHour = start,
//                    IsPlaced = true
//                });
//            }

//            return relatedTasks;
//        }
//        #endregion

//        #region GeneticAlgorithmRescheduling

//        private async Task<(bool Succeeded, List<TaskUnit> Result)> RunGeneticAlgorithmAsync(
//            List<TaskUnit> tasksToAssign,
//            string[] days,
//            int hours,
//            Dictionary<string, Dictionary<string, HashSet<int>>> staffOcc,
//            Dictionary<string, Dictionary<string, HashSet<int>>> labOcc)
//        {
//            const int populationSize = 50;
//            const int maxGenerations = 150;
//            const double mutationRate = 0.15;

//            bool CanPlace(TaskUnit t, string day, int start)
//            {
//                if (start < 1 || start + t.Duration - 1 > hours)
//                    return false;

//                var (_, staffCode) = SplitStaff(t.StaffAssigned);
//                for (int h = start; h < start + t.Duration; h++)
//                {
//                    if (staffOcc.TryGetValue(staffCode, out var dayMap) && dayMap.TryGetValue(day, out var staffHours) && staffHours.Contains(h))
//                        return false;
//                    if (t.IsLab && !string.IsNullOrEmpty(t.LabId))
//                    {
//                        if (labOcc.TryGetValue(t.LabId, out var labDayMap) && labDayMap.TryGetValue(day, out var labHours) && labHours.Contains(h))
//                            return false;
//                    }
//                }
//                if (t.IsLab && t.Duration == 4 && !(start == 1 || start == 4))
//                    return false;

//                return true;
//            }

//            List<TaskUnit> CreateRandomIndividual()
//            {
//                var individual = new List<TaskUnit>();
//                foreach (var t in tasksToAssign)
//                {
//                    var validSlots = new List<(string day, int start)>();
//                    foreach (var day in days)
//                    {
//                        for (int start = 1; start <= hours - t.Duration + 1; start++)
//                        {
//                            if (CanPlace(t, day, start))
//                                validSlots.Add((day, start));
//                        }
//                    }
//                    if (validSlots.Count == 0)
//                        return null; // no valid slot
//                    var chosen = validSlots[rng.Next(validSlots.Count)];
//                    var copy = new TaskUnit
//                    {
//                        SubjectCode = t.SubjectCode,
//                        StaffAssigned = t.StaffAssigned,
//                        LabId = t.LabId,
//                        IsLab = t.IsLab,
//                        Duration = t.Duration,
//                        Day = chosen.day,
//                        StartHour = chosen.start,
//                        IsPlaced = true
//                    };
//                    individual.Add(copy);
//                }
//                return individual;
//            }

//            int Fitness(List<TaskUnit> individual)
//            {
//                int penalty = 0;
//                var staffSchedule = new Dictionary<string, Dictionary<string, HashSet<int>>>();
//                var labSchedule = new Dictionary<string, Dictionary<string, HashSet<int>>>();

//                foreach (var t in tasksToAssign)
//                {
//                    var (_, staffCode) = SplitStaff(t.StaffAssigned);
//                    if (!staffSchedule.ContainsKey(staffCode))
//                        staffSchedule[staffCode] = days.ToDictionary(d => d, _ => new HashSet<int>());
//                    if (t.IsLab && !string.IsNullOrEmpty(t.LabId) && !labSchedule.ContainsKey(t.LabId))
//                        labSchedule[t.LabId] = days.ToDictionary(d => d, _ => new HashSet<int>());
//                }

//                foreach (var t in individual)
//                {
//                    var (_, staffCode) = SplitStaff(t.StaffAssigned);
//                    for (int h = t.StartHour; h < t.StartHour + t.Duration; h++)
//                    {
//                        if (staffOcc.TryGetValue(staffCode, out var dayMap) && dayMap.TryGetValue(t.Day, out var existingHours) && existingHours.Contains(h))
//                            penalty += 10;

//                        if (t.IsLab && !string.IsNullOrEmpty(t.LabId) && labOcc.TryGetValue(t.LabId, out var labDayMap) && labDayMap.TryGetValue(t.Day, out var labExisting) && labExisting.Contains(h))
//                            penalty += 10;

//                        if (staffSchedule[staffCode][t.Day].Contains(h))
//                            penalty += 5;
//                        else
//                            staffSchedule[staffCode][t.Day].Add(h);

//                        if (t.IsLab && !string.IsNullOrEmpty(t.LabId))
//                        {
//                            if (labSchedule[t.LabId][t.Day].Contains(h))
//                                penalty += 5;
//                            else
//                                labSchedule[t.LabId][t.Day].Add(h);
//                        }
//                    }

//                    if (t.IsLab && t.Duration == 4 && !(t.StartHour == 1 || t.StartHour == 4))
//                        penalty += 20;
//                }

//                return penalty;
//            }

//            List<TaskUnit> TournamentSelection(List<List<TaskUnit>> population)
//            {
//                int k = 3;
//                var selected = new List<List<TaskUnit>>();
//                for (int i = 0; i < k; i++)
//                    selected.Add(population[rng.Next(population.Count)]);
//                return selected.OrderBy(ind => Fitness(ind)).First();
//            }

//            (List<TaskUnit>, List<TaskUnit>) Crossover(List<TaskUnit> parent1, List<TaskUnit> parent2)
//            {
//                int point = rng.Next(1, parent1.Count);
//                var child1 = new List<TaskUnit>();
//                var child2 = new List<TaskUnit>();
//                for (int i = 0; i < parent1.Count; i++)
//                {
//                    child1.Add(i < point ? parent1[i] : parent2[i]);
//                    child2.Add(i < point ? parent2[i] : parent1[i]);
//                }
//                return (child1, child2);
//            }

//            void Mutate(List<TaskUnit> individual)
//            {
//                for (int i = 0; i < individual.Count; i++)
//                {
//                    if (rng.NextDouble() < mutationRate)
//                    {
//                        var t = tasksToAssign[i];
//                        var validSlots = new List<(string day, int start)>();
//                        foreach (var day in days)
//                        {
//                            for (int start = 1; start <= hours - t.Duration + 1; start++)
//                            {
//                                if (CanPlace(t, day, start))
//                                    validSlots.Add((day, start));
//                            }
//                        }
//                        if (validSlots.Count > 0)
//                        {
//                            var chosen = validSlots[rng.Next(validSlots.Count)];
//                            individual[i].Day = chosen.day;
//                            individual[i].StartHour = chosen.start;
//                        }
//                    }
//                }
//            }

//            var population = new List<List<TaskUnit>>();
//            for (int i = 0; i < populationSize; i++)
//            {
//                var individual = CreateRandomIndividual();
//                if (individual != null)
//                    population.Add(individual);
//            }
//            if (population.Count == 0)
//                return (false, null);

//            for (int gen = 0; gen < maxGenerations; gen++)
//            {
//                population = population.OrderBy(ind => Fitness(ind)).ToList();
//                var best = population[0];
//                if (Fitness(best) == 0)
//                {
//                    return (true, best);
//                }
//                var nextGen = new List<List<TaskUnit>>
//                {
//                    population[0], population[1]
//                };
//                while (nextGen.Count < populationSize)
//                {
//                    var parent1 = TournamentSelection(population);
//                    var parent2 = TournamentSelection(population);
//                    var (child1, child2) = Crossover(parent1, parent2);
//                    Mutate(child1);
//                    Mutate(child2);
//                    nextGen.Add(child1);
//                    if (nextGen.Count < populationSize)
//                        nextGen.Add(child2);
//                }
//                population = nextGen;
//            }
//            population = population.OrderBy(ind => Fitness(ind)).ToList();
//            if (Fitness(population[0]) == 0)
//                return (true, population[0]);
//            return (false, null);
//        }
//        #endregion

//        [HttpPost("generateCrossDepartmentTimetableBacktracking")]
//        public async Task<IActionResult> GenerateTimetableWithGARescheduling([FromBody] TimetableRequest request)
//        {
//            var cs = _configuration.GetConnectionString("DefaultConnection");
//            await using var conn = new NpgsqlConnection(cs);
//            await conn.OpenAsync();

//            string[] DAYS = new[] { "Mon", "Tue", "Wed", "Thu", "Fri" };
//            int HOURS = Math.Max(1, request.TotalHoursPerDay);

//            // Initialize timetable grid with empty slots
//            var timetableGrid = DAYS.ToDictionary(d => d, d => Enumerable.Range(1, HOURS).ToDictionary(h => h, _ => "---"));

//            var staffOcc = new Dictionary<string, Dictionary<string, HashSet<int>>>();
//            var labOcc = new Dictionary<string, Dictionary<string, HashSet<int>>>();

//            void EnsureDayMap<TKey>(Dictionary<TKey, Dictionary<string, HashSet<int>>> map, TKey key)
//            {
//                if (!map.ContainsKey(key))
//                    map[key] = DAYS.ToDictionary(d => d, _ => new HashSet<int>());
//            }

//            // Load existing staff occupancy from DB
//            await using (var cmd = new NpgsqlCommand("SELECT staff_code, day, hour FROM classtimetable", conn))
//            await using (var rd = await cmd.ExecuteReaderAsync())
//            {
//                while (await rd.ReadAsync())
//                {
//                    var sc = rd["staff_code"] as string ?? "---";
//                    var day = rd["day"] as string ?? "Mon";
//                    var hr = (int)rd["hour"];
//                    EnsureDayMap(staffOcc, sc);
//                    staffOcc[sc][day].Add(hr);
//                }
//            }

//            // Load existing lab occupancy from DB
//            await using (var cmd = new NpgsqlCommand("SELECT lab_id, day, hour FROM labtimetable", conn))
//            await using (var rd = await cmd.ExecuteReaderAsync())
//            {
//                while (await rd.ReadAsync())
//                {
//                    var lab = rd["lab_id"] as string ?? "---";
//                    var day = rd["day"] as string ?? "Mon";
//                    var hr = (int)rd["hour"];
//                    EnsureDayMap(labOcc, lab);
//                    labOcc[lab][day].Add(hr);
//                }
//            }

//            var subjects = request.Subjects?.Where(s => !string.IsNullOrWhiteSpace(s.StaffAssigned)).ToList();
//            if (subjects == null || subjects.Count == 0)
//                return BadRequest(new { message = "❌ No valid subjects with assigned staff found." });

//            // Create Tasks for scheduling
//            var tasks = new List<TaskUnit>();
//            foreach (var s in subjects)
//            {
//                var type = (s.SubjectType ?? "theory").Trim().ToLower();
//                switch (type)
//                {
//                    case "lab":
//                        tasks.Add(new TaskUnit
//                        {
//                            SubjectCode = s.SubjectCode ?? "---",
//                            SubjectName = s.SubjectName ?? "---",
//                            StaffAssigned = s.StaffAssigned,
//                            LabId = s.LabId,
//                            IsLab = true,
//                            Duration = 4,
//                            Kind = "LAB4"
//                        });
//                        break;
//                    case "embedded":
//                        tasks.Add(new TaskUnit
//                        {
//                            SubjectCode = s.SubjectCode ?? "---",
//                            SubjectName = s.SubjectName ?? "---",
//                            StaffAssigned = s.StaffAssigned,
//                            LabId = s.LabId,
//                            IsLab = true,
//                            Duration = 2,
//                            Kind = "EMB_LAB2"
//                        });
//                        tasks.Add(new TaskUnit
//                        {
//                            SubjectCode = s.SubjectCode ?? "---",
//                            SubjectName = s.SubjectName ?? "---",
//                            StaffAssigned = s.StaffAssigned,
//                            IsLab = false,
//                            Duration = 1,
//                            Kind = "EMB_TH1"
//                        });
//                        tasks.Add(new TaskUnit
//                        {
//                            SubjectCode = s.SubjectCode ?? "---",
//                            SubjectName = s.SubjectName ?? "---",
//                            StaffAssigned = s.StaffAssigned,
//                            IsLab = false,
//                            Duration = 1,
//                            Kind = "EMB_TH1"
//                        });
//                        break;
//                    default:
//                        int count = Math.Max(0, s.Credit);
//                        for (int i = 0; i < count; i++)
//                        {
//                            tasks.Add(new TaskUnit
//                            {
//                                SubjectCode = s.SubjectCode ?? "---",
//                                SubjectName = s.SubjectName ?? "---",
//                                StaffAssigned = s.StaffAssigned,
//                                IsLab = false,
//                                Duration = 1,
//                                Kind = "TH1"
//                            });
//                        }
//                        break;
//                }
//            }

//            Shuffle(tasks);

//            // Initialize each task's domain with all feasible slots
//            foreach (var t in tasks)
//            {
//                t.Domain.Clear();
//                foreach (var day in DAYS)
//                {
//                    for (int start = 1; start <= HOURS - t.Duration + 1; start++)
//                    {
//                        if (IsFreeAndNoConflict(t, day, start, staffOcc, labOcc, timetableGrid, HOURS))
//                        {
//                            t.Domain.Add((day, start));
//                        }
//                    }
//                }
//                if (t.Domain.Count == 0)
//                    return Ok(new { message = $"No initial available slot for task {t.SubjectCode}.", receivedPayload = request });
//                Shuffle(t.Domain);
//            }

//            // Main backtracking with GA fallback
//            async Task<bool> BacktrackWithGA(List<TaskUnit> taskList)
//            {
//                if (taskList.All(t => t.IsPlaced)) return true;

//                var currentTask = taskList.Where(t => !t.IsPlaced).OrderBy(t => t.Domain.Count).FirstOrDefault();
//                if (currentTask == null) return true;

//                Shuffle(currentTask.Domain);

//                foreach (var slot in currentTask.Domain)
//                {
//                    if (IsFreeAndNoConflict(currentTask, slot.day, slot.start, staffOcc, labOcc, timetableGrid, HOURS))
//                    {
//                        AssignTask(currentTask, slot, staffOcc, labOcc, timetableGrid);
//                        if (PropagateConstraints(taskList, currentTask, slot))
//                        {
//                            if (await BacktrackWithGA(taskList)) return true;
//                        }

//                        // On conflict, rollback related tasks and use GA
//                        var conflictTasks = await CollectRelatedTasksAsync(currentTask, conn, request, staffOcc, labOcc);
//                        var reassignmentTasks = new List<TaskUnit> { currentTask };
//                        foreach (var t in conflictTasks)
//                            if (!reassignmentTasks.Contains(t)) reassignmentTasks.Add(t);

//                        foreach (var t in reassignmentTasks)
//                            UnassignTask(t, staffOcc, labOcc, timetableGrid);

//                        var gaResult = await RunGeneticAlgorithmAsync(reassignmentTasks, DAYS, HOURS, staffOcc, labOcc);

//                        if (gaResult.Succeeded)
//                        {
//                            foreach (var t in reassignmentTasks)
//                            {
//                                t.Domain.Clear();
//                                t.Domain.Add((t.Day, t.StartHour));
//                                AssignTask(t, (t.Day, t.StartHour), staffOcc, labOcc, timetableGrid);
//                            }

//                            if (await BacktrackWithGA(taskList))
//                                return true;
//                        }
//                        else
//                        {
//                            foreach (var t in reassignmentTasks)
//                                if (t.Day != null && !t.IsPlaced)
//                                    AssignTask(t, (t.Day, t.StartHour), staffOcc, labOcc, timetableGrid);
//                        }
//                        UnassignTask(currentTask, staffOcc, labOcc, timetableGrid);
//                    }
//                }
//                return false;
//            }

//            bool solved = await BacktrackWithGA(tasks);

//            if (!solved)
//                return Ok(new { message = "❌ Could not generate a conflict-free timetable.", receivedPayload = request });

//            // Validate final timetable here for any runtime conflicts before commit (Extra safety)
//            if (!ValidateFinalTimetable(tasks, HOURS))
//            {
//                return Ok(new { message = "❌ Timetable validation failed after generation.", receivedPayload = request });
//            }

//            // Atomic DB save transaction
//            await using var transaction = await conn.BeginTransactionAsync();

//            // Clear old timetable entries
//            await using (var delClass = new NpgsqlCommand(@"
//                DELETE FROM classtimetable WHERE department_id=@department AND year=@year AND semester=@sem AND section=@section;", conn, transaction))
//            {
//                delClass.Parameters.AddWithValue("department", request.Department ?? "---");
//                delClass.Parameters.AddWithValue("year", request.Year ?? "---");
//                delClass.Parameters.AddWithValue("sem", request.Semester ?? "---");
//                delClass.Parameters.AddWithValue("section", request.Section ?? "---");
//                await delClass.ExecuteNonQueryAsync();
//            }

//            await using (var delLab = new NpgsqlCommand(@"
//                DELETE FROM labtimetable WHERE department=@department AND year=@year AND semester=@sem AND section=@section;", conn, transaction))
//            {
//                delLab.Parameters.AddWithValue("department", request.Department ?? "---");
//                delLab.Parameters.AddWithValue("year", request.Year ?? "---");
//                delLab.Parameters.AddWithValue("sem", request.Semester ?? "---");
//                delLab.Parameters.AddWithValue("section", request.Section ?? "---");
//                await delLab.ExecuteNonQueryAsync();
//            }

//            // Insert new timetable data
//            foreach (var t in tasks)
//            {
//                var (staffName, staffCode) = SplitStaff(t.StaffAssigned);
//                for (int h = t.StartHour; h < t.StartHour + t.Duration; h++)
//                {
//                    await using var icClass = new NpgsqlCommand(@"
//                        INSERT INTO classtimetable
//                        (staff_name, staff_code, department_id, year, semester, section, day, hour, subject_code, subject_name)
//                        VALUES
//                        (@staff_name, @staff_code, @department, @year, @semester, @section, @day, @hour, @subject_code, @subject_name);", conn, transaction);
//                    icClass.Parameters.AddWithValue("@staff_name", staffName ?? "---");
//                    icClass.Parameters.AddWithValue("@staff_code", staffCode ?? "---");
//                    icClass.Parameters.AddWithValue("@department", request.Department ?? "---");
//                    icClass.Parameters.AddWithValue("@year", request.Year ?? "---");
//                    icClass.Parameters.AddWithValue("@semester", request.Semester ?? "---");
//                    icClass.Parameters.AddWithValue("@section", request.Section ?? "---");
//                    icClass.Parameters.AddWithValue("@day", t.Day ?? "---");
//                    icClass.Parameters.AddWithValue("@hour", h);
//                    icClass.Parameters.AddWithValue("@subject_code", t.SubjectCode ?? "---");
//                    icClass.Parameters.AddWithValue("@subject_name", t.SubjectName ?? "---");
//                    await icClass.ExecuteNonQueryAsync();
//                }

//                if (t.IsLab && !string.IsNullOrEmpty(t.LabId))
//                {
//                    int labStart = t.StartHour == 4 ? 5 : t.StartHour;
//                    for (int h = labStart; h < t.StartHour + t.Duration; h++)
//                    {
//                        await using var icLab = new NpgsqlCommand(@"
//                            INSERT INTO labtimetable
//                            (lab_id, subject_code, subject_name, staff_name, department, year, semester, section, day, hour)
//                            VALUES
//                            (@lab_id, @subject_code, @subject_name, @staff_name, @department, @year, @semester, @section, @day, @hour);", conn, transaction);
//                        icLab.Parameters.AddWithValue("@lab_id", t.LabId ?? (object)DBNull.Value);
//                        icLab.Parameters.AddWithValue("@subject_code", t.SubjectCode ?? "---");
//                        icLab.Parameters.AddWithValue("@subject_name", t.SubjectName ?? "---");
//                        icLab.Parameters.AddWithValue("@staff_name", staffName ?? "---");
//                        icLab.Parameters.AddWithValue("@department", request.Department ?? "---");
//                        icLab.Parameters.AddWithValue("@year", request.Year ?? "---");
//                        icLab.Parameters.AddWithValue("@semester", request.Semester ?? "---");
//                        icLab.Parameters.AddWithValue("@section", request.Section ?? "---");
//                        icLab.Parameters.AddWithValue("@day", t.Day ?? "---");
//                        icLab.Parameters.AddWithValue("@hour", h);
//                        await icLab.ExecuteNonQueryAsync();
//                    }
//                }
//            }

//            await transaction.CommitAsync();

//            return Ok(new
//            {
//                message = "✅ Timetable generated successfully with enhanced global conflict resolution.",
//                timetable = timetableGrid.Select(t => new { Day = t.Key, Slots = t.Value }),
//                usedLabIds = tasks.Where(t => t.IsLab && !string.IsNullOrEmpty(t.LabId)).Select(t => t.LabId).Distinct(),
//                receivedPayload = request
//            });
//        }

//        private bool ValidateFinalTimetable(List<TaskUnit> tasks, int totalHours)
//        {
//            var staffSchedule = new Dictionary<string, Dictionary<string, HashSet<int>>>();
//            var labSchedule = new Dictionary<string, Dictionary<string, HashSet<int>>>();

//            foreach (var t in tasks)
//            {
//                var (_, staffCode) = SplitStaff(t.StaffAssigned);
//                if (!staffSchedule.ContainsKey(staffCode))
//                    staffSchedule[staffCode] = new Dictionary<string, HashSet<int>>();
//                if (!staffSchedule[staffCode].ContainsKey(t.Day))
//                    staffSchedule[staffCode][t.Day] = new HashSet<int>();

//                if (t.IsLab && !string.IsNullOrEmpty(t.LabId))
//                {
//                    if (!labSchedule.ContainsKey(t.LabId))
//                        labSchedule[t.LabId] = new Dictionary<string, HashSet<int>>();
//                    if (!labSchedule[t.LabId].ContainsKey(t.Day))
//                        labSchedule[t.LabId][t.Day] = new HashSet<int>();
//                }

//                for (int h = t.StartHour; h < t.StartHour + t.Duration; h++)
//                {
//                    if (h < 1 || h > totalHours)
//                        return false;

//                    if (staffSchedule[staffCode][t.Day].Contains(h))
//                        return false;
//                    else
//                        staffSchedule[staffCode][t.Day].Add(h);

//                    if (t.IsLab && !string.IsNullOrEmpty(t.LabId))
//                    {
//                        if (labSchedule[t.LabId][t.Day].Contains(h))
//                            return false;
//                        else
//                            labSchedule[t.LabId][t.Day].Add(h);
//                    }

//                    // Lab block constraints
//                    if (t.IsLab && t.Duration == 4 && !(t.StartHour == 1 || t.StartHour == 4))
//                        return false;
//                }
//            }
//            return true;
//        }
//    }
//}











//flop google ortools
//using Google.OrTools.Sat;
//using Microsoft.AspNetCore.Mvc;
//using Microsoft.Extensions.Configuration;
//using Npgsql;
//using System;
//using System.Collections.Generic;
//using System.Linq;
//using System.Threading.Tasks;
//using static System.Runtime.InteropServices.JavaScript.JSType;

//namespace Timetablegenerator.Controllers
//{
//    [ApiController]
//    [Route("api/[controller]")]
//    public class TimetableController : ControllerBase
//    {
//        private readonly IConfiguration _configuration;
//        private static readonly Random rng = new Random();

//        public TimetableController(IConfiguration configuration)
//        {
//            _configuration = configuration;
//        }

//        #region DTOs
//        public class TimetableRequest
//        {
//            public string Department { get; set; }
//            public string Year { get; set; }
//            public string Semester { get; set; }
//            public string Section { get; set; }
//            public int TotalHoursPerDay { get; set; } = 7;
//            public List<SubjectDto> Subjects { get; set; }
//        }

//        public class SubjectDto
//        {
//            public string SubjectCode { get; set; }
//            public string SubjectName { get; set; }
//            public string SubjectType { get; set; }
//            public int Credit { get; set; }
//            public string StaffAssigned { get; set; }
//            public string LabId { get; set; }
//        }

//        public class TaskUnit
//        {
//            public string SubjectCode;
//            public string SubjectName;
//            public string StaffAssigned;
//            public string LabId;
//            public bool IsLab;
//            public int Duration;
//            public string Kind;
//            public string Day;
//            public int StartHour;
//            public bool IsPlaced = false;
//            public List<(string day, int start)> Domain = new();
//        }
//        #endregion

//        #region Helper Methods

//        private void Shuffle<T>(IList<T> list)
//        {
//            int n = list.Count;
//            while (n > 1)
//            {
//                n--;
//                int k = rng.Next(n + 1);
//                (list[k], list[n]) = (list[n], list[k]);
//            }
//        }

//        private (string staffName, string staffCode) SplitStaff(string staffAssigned)
//        {
//            if (string.IsNullOrWhiteSpace(staffAssigned)) return ("---", "---");
//            var name = staffAssigned;
//            var code = staffAssigned;
//            if (staffAssigned.Contains("("))
//            {
//                var parts = staffAssigned.Split('(', StringSplitOptions.TrimEntries);
//                name = parts[0].Trim();
//                code = parts.Length > 1 ? parts[1].Replace(")", "").Trim() : "---";
//            }
//            return (name, code);
//        }

//        private bool IsFreeAndNoConflict(TaskUnit t, string day, int start,
//            Dictionary<string, Dictionary<string, HashSet<int>>> staffOcc,
//            Dictionary<string, Dictionary<string, HashSet<int>>> labOcc,
//            Dictionary<string, Dictionary<int, string>> timetableGrid,
//            int totalHours)
//        {
//            for (int h = start; h < start + t.Duration; h++)
//            {
//                if (h < 1 || h > totalHours) return false;
//                if (timetableGrid[day][h] != "---") return false;
//            }
//            var (_, staffCode) = SplitStaff(t.StaffAssigned);
//            for (int h = start; h < start + t.Duration; h++)
//            {
//                if (staffOcc.TryGetValue(staffCode, out var dm) && dm.TryGetValue(day, out var set) && set.Contains(h))
//                    return false;
//            }
//            if (t.IsLab && !string.IsNullOrEmpty(t.LabId))
//            {
//                for (int h = start; h < start + t.Duration; h++)
//                {
//                    if (labOcc.TryGetValue(t.LabId, out var dm) && dm.TryGetValue(day, out var set) && set.Contains(h))
//                        return false;
//                }
//                if (t.Kind == "LAB4" && !(start == 1 || start == 4))
//                    return false;
//            }
//            return true;
//        }

//        private void AssignTask(TaskUnit t, (string day, int start) slot,
//            Dictionary<string, Dictionary<string, HashSet<int>>> staffOcc,
//            Dictionary<string, Dictionary<string, HashSet<int>>> labOcc,
//            Dictionary<string, Dictionary<int, string>> timetableGrid)
//        {
//            var (day, start) = slot;
//            var (_, staffCode) = SplitStaff(t.StaffAssigned);
//            for (int h = start; h < start + t.Duration; h++)
//            {
//                timetableGrid[day][h] = $"{t.SubjectCode} ({t.StaffAssigned})";
//                if (!staffOcc.ContainsKey(staffCode)) staffOcc[staffCode] = new Dictionary<string, HashSet<int>>();
//                if (!staffOcc[staffCode].ContainsKey(day)) staffOcc[staffCode][day] = new HashSet<int>();
//                staffOcc[staffCode][day].Add(h);
//                if (t.IsLab && !string.IsNullOrEmpty(t.LabId))
//                {
//                    if (!labOcc.ContainsKey(t.LabId)) labOcc[t.LabId] = new Dictionary<string, HashSet<int>>();
//                    if (!labOcc[t.LabId].ContainsKey(day)) labOcc[t.LabId][day] = new HashSet<int>();
//                    labOcc[t.LabId][day].Add(h);
//                }
//            }
//            t.Day = day;
//            t.StartHour = start;
//            t.IsPlaced = true;
//        }

//        private void UnassignTask(TaskUnit t,
//            Dictionary<string, Dictionary<string, HashSet<int>>> staffOcc,
//            Dictionary<string, Dictionary<string, HashSet<int>>> labOcc,
//            Dictionary<string, Dictionary<int, string>> timetableGrid)
//        {
//            if (!t.IsPlaced) return;
//            var day = t.Day;
//            var start = t.StartHour;
//            var (_, staffCode) = SplitStaff(t.StaffAssigned);
//            for (int h = start; h < start + t.Duration; h++)
//            {
//                timetableGrid[day][h] = "---";
//                staffOcc[staffCode][day].Remove(h);
//                if (t.IsLab && !string.IsNullOrEmpty(t.LabId))
//                    labOcc[t.LabId][day].Remove(h);
//            }
//            t.IsPlaced = false;
//            t.Day = null;
//            t.StartHour = 0;
//        }

//        private bool PropagateConstraints(List<TaskUnit> tasksList, TaskUnit assignedTask, (string day, int start) assignedSlot)
//        {
//            var snapshotDomains = tasksList.ToDictionary(t => t, t => t.Domain.ToList());
//            assignedTask.Domain = new List<(string, int)> { assignedSlot };
//            foreach (var other in tasksList)
//            {
//                if (other == assignedTask || other.IsPlaced) continue;
//                var filtered = new List<(string day, int start)>();
//                foreach (var pos in other.Domain)
//                {
//                    bool conflict = false;
//                    if (pos.day == assignedSlot.day)
//                    {
//                        int start1 = pos.start;
//                        int end1 = pos.start + other.Duration - 1;
//                        int start2 = assignedSlot.start;
//                        int end2 = assignedSlot.start + assignedTask.Duration - 1;
//                        bool overlap = end1 >= start2 && end2 >= start1;
//                        if (overlap)
//                        {
//                            var (_, staff1) = SplitStaff(other.StaffAssigned);
//                            var (_, staff2) = SplitStaff(assignedTask.StaffAssigned);
//                            if (staff1 == staff2) conflict = true;
//                            if (!conflict && other.IsLab && assignedTask.IsLab &&
//                                !string.IsNullOrEmpty(other.LabId) && !string.IsNullOrEmpty(assignedTask.LabId) && other.LabId == assignedTask.LabId)
//                                conflict = true;
//                        }
//                    }
//                    if (!conflict) filtered.Add(pos);
//                }
//                other.Domain = filtered;
//                if (other.Domain.Count == 0)
//                {
//                    foreach (var kvp in snapshotDomains) kvp.Key.Domain = kvp.Value;
//                    return false;
//                }
//            }
//            return true;
//        }

//        // Transitive closure of related tasks (staff/lab conflicts)
//        private async Task<List<TaskUnit>> CollectTransitiveRelatedTasksAsync(
//       TaskUnit task,
//       NpgsqlConnection conn,
//       TimetableRequest request)
//        {
//            var queue = new Queue<string>(); // For staff and lab IDs to explore
//            var seenStaff = new HashSet<string>();
//            var seenLabs = new HashSet<string>();
//            var relatedTasks = new List<TaskUnit>();
//            var (_, staffCode) = SplitStaff(task.StaffAssigned);

//            if (!string.IsNullOrEmpty(staffCode) && staffCode != "---")
//            {
//                queue.Enqueue("S:" + staffCode);
//                seenStaff.Add(staffCode);
//            }
//            if (!string.IsNullOrEmpty(task.LabId))
//            {
//                queue.Enqueue("L:" + task.LabId);
//                seenLabs.Add(task.LabId);
//            }

//            while (queue.Count > 0)
//            {
//                string item = queue.Dequeue();
//                bool isStaff = item.StartsWith("S:");
//                string code = item.Substring(2);
//                string sql;
//                NpgsqlCommand cmd;

//                if (isStaff)
//                {
//                    sql = @"
//                SELECT staff_code, subject_code, subject_name, day, hour, lab_id
//                FROM (
//                    SELECT staff_code, subject_code, subject_name, day, hour, NULL as lab_id, year, semester, department_id AS department, section
//                    FROM classtimetable
//                    UNION ALL
//                    SELECT staff_code, subject_code, subject_name, day, hour, lab_id, year, semester, department, section
//                    FROM labtimetable
//                ) AS combined
//                WHERE staff_code = ANY(@staffIds)
//                  AND year = @year
//                  AND semester = @semester
//                  AND department = @department
//                  AND section = @section
//                ORDER BY day, hour";

//                    cmd = new NpgsqlCommand(sql, conn);
//                    // Bind @staffIds as string[] array, even if single value
//                    cmd.Parameters.AddWithValue("staffIds", new string[] { code });
//                }
//                else
//                {
//                    sql = @"
//                SELECT staff_code, subject_code, subject_name, day, hour, lab_id
//                FROM labtimetable
//                WHERE lab_id = @code
//                  AND year = @year
//                  AND semester = @semester
//                  AND department = @department
//                  AND section = @section
//                ORDER BY day, hour";

//                    cmd = new NpgsqlCommand(sql, conn);
//                    cmd.Parameters.AddWithValue("code", code);
//                }

//                // Add other parameters
//                cmd.Parameters.AddWithValue("year", request.Year);
//                cmd.Parameters.AddWithValue("semester", request.Semester);
//                cmd.Parameters.AddWithValue("department", request.Department);
//                cmd.Parameters.AddWithValue("section", request.Section);

//                using var reader = await cmd.ExecuteReaderAsync();

//                while (await reader.ReadAsync())
//                {
//                    string sCode = reader.GetString(0);
//                    string subCode = reader.GetString(1);
//                    string subName = reader.GetString(2);
//                    string day = reader.GetString(3);
//                    int hour = reader.GetInt32(4);
//                    string labId = reader.IsDBNull(5) ? null : reader.GetString(5);
//                    var kind = string.IsNullOrEmpty(labId) ? "TH" : "LAB";

//                    bool exists = relatedTasks.Any(t =>
//                        t.SubjectCode == subCode && t.StaffAssigned == sCode && t.LabId == labId && t.Day == day);
//                    if (!exists)
//                    {
//                        relatedTasks.Add(new TaskUnit
//                        {
//                            SubjectCode = subCode,
//                            StaffAssigned = sCode,
//                            SubjectName = subName,
//                            LabId = labId,
//                            IsLab = !string.IsNullOrEmpty(labId),
//                            Duration = 1, // conservative; could improve by grouping hours
//                            Kind = kind,
//                            Day = day,
//                            StartHour = hour,
//                            IsPlaced = true
//                        });

//                        if (!string.IsNullOrEmpty(sCode) && sCode != "---" && !seenStaff.Contains(sCode))
//                        {
//                            queue.Enqueue("S:" + sCode);
//                            seenStaff.Add(sCode);
//                        }
//                        if (!string.IsNullOrEmpty(labId) && !seenLabs.Contains(labId))
//                        {
//                            queue.Enqueue("L:" + labId);
//                            seenLabs.Add(labId);
//                        }
//                    }
//                }
//                reader.Close();
//            }

//            return relatedTasks;
//        }


//        #endregion
//        #region ConstraintProgrammingRescheduling
//        private bool SolveConflictGroupWithCP(
//            List<TaskUnit> conflictTasks,
//            string[] days,
//            int totalHours,
//            Dictionary<string, Dictionary<string, HashSet<int>>> staffOccGlobal,
//            Dictionary<string, Dictionary<string, HashSet<int>>> labOccGlobal,
//            out Dictionary<TaskUnit, (string day, int start)> solution)
//        {
//            solution = null;
//            var dayIndex = new Dictionary<string, int>();
//            for (int i = 0; i < days.Length; i++) dayIndex[days[i]] = i;

//            var model = new CpModel();
//            int horizon = days.Length * totalHours; // total slots in the week

//            var taskVarSlots = new Dictionary<TaskUnit, IntVar>();

//            // Create variables and domain constraints
//            foreach (var task in conflictTasks)
//            {
//                var possibleSlots = new List<int>();
//                if (task.Domain != null && task.Domain.Count > 0)
//                {
//                    foreach (var (d, start) in task.Domain)
//                    {
//                        int idx = dayIndex[d] * totalHours + (start - 1);
//                        possibleSlots.Add(idx);
//                    }
//                }
//                else
//                {
//                    for (int d = 0; d < days.Length; d++)
//                        for (int start = 0; start <= totalHours - task.Duration; start++)
//                            possibleSlots.Add(d * totalHours + start);
//                }

//                if (possibleSlots.Count == 0)
//                    return false; // no available slots for this task, hence unsat

//                int min = possibleSlots.Min();
//                int max = possibleSlots.Max();

//                taskVarSlots[task] = model.NewIntVar(min, max, $"{task.SubjectCode}_{task.StaffAssigned}_slot");

//                var table = model.AddAllowedAssignments(new IntVar[] { taskVarSlots[task] });

//                // Prepare allowed slots as a 2D array for AddTuples
//                var allowedSlots = new long[possibleSlots.Count, 1];
//                for (int i = 0; i < possibleSlots.Count; i++)
//                    allowedSlots[i, 0] = possibleSlots[i];

//                table.AddTuples(allowedSlots);
//            }

//            // Create occupancy bool vars for each task-time slot
//            var taskOccupancy = new Dictionary<(TaskUnit, int), BoolVar>();
//            foreach (var task in conflictTasks)
//            {
//                for (int offset = 0; offset < task.Duration; offset++)
//                {
//                    for (int slot = 0; slot < horizon; slot++)
//                    {
//                        var b = model.NewBoolVar($"{task.SubjectCode}_covers_{slot}");
//                        taskOccupancy[(task, slot)] = b;

//                        int validSlot = slot - offset;
//                        if (validSlot >= 0)
//                        {
//                            model.Add(taskVarSlots[task] == validSlot).OnlyEnforceIf(b);
//                            model.Add(taskVarSlots[task] != validSlot).OnlyEnforceIf(b.Not());
//                        }
//                        else
//                        {
//                            model.Add(b == 0);
//                        }
//                    }
//                }
//            }

//            // Enforce no overlaps for common staff/lab
//            for (int i = 0; i < conflictTasks.Count; i++)
//            {
//                var t1 = conflictTasks[i];
//                var (_, staff1) = SplitStaff(t1.StaffAssigned);
//                var lab1 = t1.LabId;

//                for (int j = i + 1; j < conflictTasks.Count; j++)
//                {
//                    var t2 = conflictTasks[j];
//                    var (_, staff2) = SplitStaff(t2.StaffAssigned);
//                    var lab2 = t2.LabId;

//                    bool shareStaff = staff1 == staff2;
//                    bool shareLab = !string.IsNullOrEmpty(lab1) && lab1 == lab2;

//                    if (shareStaff || shareLab)
//                    {
//                        for (int slot = 0; slot < horizon; slot++)
//                            model.AddBoolOr(new[] { taskOccupancy[(t1, slot)].Not(), taskOccupancy[(t2, slot)].Not() });
//                    }
//                }
//            }

//            // Prevent overlaps with already reserved slots in global occupancy
//            foreach (var task in conflictTasks)
//            {
//                var (_, staff) = SplitStaff(task.StaffAssigned);
//                string lab = task.LabId;

//                for (int d = 0; d < days.Length; d++)
//                {
//                    string day = days[d];

//                    if (staffOccGlobal.TryGetValue(staff, out var staffDayMap) &&
//                        staffDayMap.TryGetValue(day, out var staffHours))
//                    {
//                        foreach (var hr in staffHours)
//                        {
//                            for (int offset = 0; offset < task.Duration; offset++)
//                            {
//                                int slotIdx = d * totalHours + hr - 1 - offset;
//                                if (slotIdx >= 0 && slotIdx < horizon)
//                                    model.AddBoolOr(new[] { taskOccupancy[(task, slotIdx)].Not() });
//                            }
//                        }
//                    }

//                    if (!string.IsNullOrEmpty(lab) &&
//                        labOccGlobal.TryGetValue(lab, out var labDayMap) &&
//                        labDayMap.TryGetValue(day, out var labHours))
//                    {
//                        foreach (var hr in labHours)
//                        {
//                            for (int offset = 0; offset < task.Duration; offset++)
//                            {
//                                int slotIdx = d * totalHours + hr - 1 - offset;
//                                if (slotIdx >= 0 && slotIdx < horizon)
//                                    model.AddBoolOr(new[] { taskOccupancy[(task, slotIdx)].Not() });
//                            }
//                        }
//                    }
//                }
//            }

//            // Enforce lab start time constraints (4 hours only at 1 or 4)
//            foreach (var task in conflictTasks)
//            {
//                if (task.IsLab && task.Duration == 4)
//                {
//                    var allowedOffsets = new List<int>();
//                    for (int d = 0; d < days.Length; d++)
//                    {
//                        allowedOffsets.Add(d * totalHours + 0);
//                        allowedOffsets.Add(d * totalHours + 3);
//                    }
//                    var table = model.AddAllowedAssignments(new IntVar[] { taskVarSlots[task] });
//                    var allowedSlots = new long[allowedOffsets.Count, 1];
//                    for (int i = 0; i < allowedOffsets.Count; i++)
//                        allowedSlots[i, 0] = allowedOffsets[i];
//                    table.AddTuples(allowedSlots);
//                }
//            }

//            // Embedded subject no-overlap constraints
//            var embeddedGroups = new Dictionary<string, List<TaskUnit>>();
//            foreach (var task in conflictTasks)
//            {
//                if (task.Kind.StartsWith("EMB"))
//                {
//                    if (!embeddedGroups.ContainsKey(task.SubjectCode))
//                        embeddedGroups[task.SubjectCode] = new List<TaskUnit>();
//                    embeddedGroups[task.SubjectCode].Add(task);
//                }
//            }

//            foreach (var group in embeddedGroups.Values)
//            {
//                for (int i = 0; i < group.Count; i++)
//                {
//                    for (int j = i + 1; j < group.Count; j++)
//                    {
//                        var t1 = group[i];
//                        var t2 = group[j];
//                        for (int slot = 0; slot < horizon; slot++)
//                        {
//                            model.AddBoolOr(new[] { taskOccupancy[(t1, slot)].Not(), taskOccupancy[(t2, slot)].Not() });
//                        }
//                    }
//                }
//            }

//            // Solve
//            var solver = new CpSolver
//            {
//                StringParameters = "max_time_in_seconds:10"
//            };
//            var status = solver.Solve(model);

//            if (status == CpSolverStatus.Optimal || status == CpSolverStatus.Feasible)
//            {
//                solution = new Dictionary<TaskUnit, (string, int)>();
//                foreach (var task in conflictTasks)
//                {
//                    int slot = (int)solver.Value(taskVarSlots[task]);
//                    int dayIdx = slot / totalHours;
//                    int startHour = (slot % totalHours) + 1;
//                    solution[task] = (days[dayIdx], startHour);
//                }
//                return true;
//            }
//            else
//            {
//                return false;
//            }
//        }
//        #endregion


//        [HttpPost("generateCrossDepartmentTimetableBacktracking")]
//        public async Task<IActionResult> GenerateTimetableWithCPRescheduling([FromBody] TimetableRequest request)
//        {
//            var cs = _configuration.GetConnectionString("DefaultConnection");
//            await using var conn = new NpgsqlConnection(cs);
//            await conn.OpenAsync();

//            string[] DAYS = new[] { "Mon", "Tue", "Wed", "Thu", "Fri" };
//            int HOURS = Math.Max(1, request.TotalHoursPerDay);

//            // timetable grid initialization
//            var timetableGrid = DAYS.ToDictionary(d => d, d => Enumerable.Range(1, HOURS).ToDictionary(h => h, _ => "---"));
//            var staffOcc = new Dictionary<string, Dictionary<string, HashSet<int>>>();
//            var labOcc = new Dictionary<string, Dictionary<string, HashSet<int>>>();

//            void EnsureDayMap<TKey>(Dictionary<TKey, Dictionary<string, HashSet<int>>> map, TKey key)
//            {
//                if (!map.ContainsKey(key))
//                    map[key] = DAYS.ToDictionary(d => d, _ => new HashSet<int>());
//            }

//            // Load existing staff occupancy
//            await using (var cmd = new NpgsqlCommand("SELECT staff_code, day, hour FROM classtimetable", conn))
//            await using (var rd = await cmd.ExecuteReaderAsync())
//            {
//                while (await rd.ReadAsync())
//                {
//                    var sc = rd["staff_code"] as string ?? "---";
//                    var day = rd["day"] as string ?? "Mon";
//                    var hr = (int)rd["hour"];
//                    EnsureDayMap(staffOcc, sc);
//                    staffOcc[sc][day].Add(hr);
//                }
//            }

//            // Load existing lab occupancy
//            await using (var cmd = new NpgsqlCommand("SELECT lab_id, day, hour FROM labtimetable", conn))
//            await using (var rd = await cmd.ExecuteReaderAsync())
//            {
//                while (await rd.ReadAsync())
//                {
//                    var lab = rd["lab_id"] as string ?? "---";
//                    var day = rd["day"] as string ?? "Mon";
//                    var hr = (int)rd["hour"];
//                    EnsureDayMap(labOcc, lab);
//                    labOcc[lab][day].Add(hr);
//                }
//            }

//            var subjects = request.Subjects?.Where(s => !string.IsNullOrWhiteSpace(s.StaffAssigned)).ToList();
//            if (subjects == null || subjects.Count == 0)
//                return BadRequest(new { message = "❌ No valid subjects with assigned staff found." });

//            var tasks = new List<TaskUnit>();

//            // Generate tasks from subjects
//            foreach (var s in subjects)
//            {
//                var type = (s.SubjectType ?? "theory").Trim().ToLower();
//                switch (type)
//                {
//                    case "lab":
//                        tasks.Add(new TaskUnit
//                        {
//                            SubjectCode = s.SubjectCode ?? "---",
//                            SubjectName = s.SubjectName ?? "---",
//                            StaffAssigned = s.StaffAssigned,
//                            LabId = s.LabId,
//                            IsLab = true,
//                            Duration = 4,
//                            Kind = "LAB4"
//                        });
//                        break;
//                    case "embedded":
//                        tasks.Add(new TaskUnit
//                        {
//                            SubjectCode = s.SubjectCode ?? "---",
//                            SubjectName = s.SubjectName ?? "---",
//                            StaffAssigned = s.StaffAssigned,
//                            LabId = s.LabId,
//                            IsLab = true,
//                            Duration = 2,
//                            Kind = "EMB_LAB2"
//                        });
//                        tasks.Add(new TaskUnit
//                        {
//                            SubjectCode = s.SubjectCode ?? "---",
//                            SubjectName = s.SubjectName ?? "---",
//                            StaffAssigned = s.StaffAssigned,
//                            IsLab = false,
//                            Duration = 1,
//                            Kind = "EMB_TH1"
//                        });
//                        tasks.Add(new TaskUnit
//                        {
//                            SubjectCode = s.SubjectCode ?? "---",
//                            SubjectName = s.SubjectName ?? "---",
//                            StaffAssigned = s.StaffAssigned,
//                            IsLab = false,
//                            Duration = 1,
//                            Kind = "EMB_TH1"
//                        });
//                        break;
//                    default:
//                        int count = Math.Max(0, s.Credit);
//                        for (int i = 0; i < count; i++)
//                        {
//                            tasks.Add(new TaskUnit
//                            {
//                                SubjectCode = s.SubjectCode ?? "---",
//                                SubjectName = s.SubjectName ?? "---",
//                                StaffAssigned = s.StaffAssigned,
//                                IsLab = false,
//                                Duration = 1,
//                                Kind = "TH1"
//                            });
//                        }
//                        break;
//                }
//            }

//            Shuffle(tasks);

//            // Initialize domains
//            foreach (var t in tasks)
//            {
//                t.Domain.Clear();
//                foreach (var day in DAYS)
//                {
//                    for (int start = 1; start <= HOURS - t.Duration + 1; start++)
//                    {
//                        if (IsFreeAndNoConflict(t, day, start, staffOcc, labOcc, timetableGrid, HOURS))
//                        {
//                            t.Domain.Add((day, start));
//                        }
//                    }
//                }
//                if (t.Domain.Count == 0)
//                    return Ok(new { message = $"No initial available slot for task {t.SubjectCode}.", receivedPayload = request });
//                Shuffle(t.Domain);
//            }

//            // Main backtracking with CP fallback for conflict groups
//            async Task<bool> BacktrackWithCP(List<TaskUnit> taskList)
//            {
//                if (taskList.All(t => t.IsPlaced))
//                    return true;

//                var currentTask = taskList.Where(t => !t.IsPlaced).OrderBy(t => t.Domain.Count).FirstOrDefault();
//                if (currentTask == null) return true;

//                Shuffle(currentTask.Domain);

//                foreach (var slot in currentTask.Domain)
//                {
//                    if (IsFreeAndNoConflict(currentTask, slot.day, slot.start, staffOcc, labOcc, timetableGrid, HOURS))
//                    {
//                        AssignTask(currentTask, slot, staffOcc, labOcc, timetableGrid);
//                        if (PropagateConstraints(taskList, currentTask, slot))
//                        {
//                            if (await BacktrackWithCP(taskList)) return true;
//                        }

//                        // On conflict, collect transitive related tasks and solve with CP
//                        var conflictTasks = await CollectTransitiveRelatedTasksAsync(currentTask, conn, request);

//                        // Find Tasks in current list matching these conflict tasks by primary keys (SubjectCode+Staff+Lab+Day)
//                        var conflictedTaskUnits = taskList.Where(t =>
//                            conflictTasks.Any(ct => ct.SubjectCode == t.SubjectCode && ct.StaffAssigned == t.StaffAssigned && ct.LabId == t.LabId && ct.Day == t.Day))
//                            .Where(t => t.IsPlaced).ToList();

//                        foreach (var t in conflictedTaskUnits)
//                            UnassignTask(t, staffOcc, labOcc, timetableGrid);

//                        if (conflictedTaskUnits.Count > 0)
//                        {
//                            if (SolveConflictGroupWithCP(conflictedTaskUnits, DAYS, HOURS, staffOcc, labOcc, out var cpSolution))
//                            {
//                                foreach (var (t, (d, s)) in cpSolution)
//                                {
//                                    t.Domain.Clear();
//                                    t.Domain.Add((d, s));
//                                    AssignTask(t, (d, s), staffOcc, labOcc, timetableGrid);
//                                }
//                                if (await BacktrackWithCP(taskList)) return true;
//                            }
//                            else
//                            {
//                                // No solution from CP, revert assignments
//                                foreach (var t in conflictedTaskUnits)
//                                {
//                                    AssignTask(t, (t.Day, t.StartHour), staffOcc, labOcc, timetableGrid);
//                                }
//                                UnassignTask(currentTask, staffOcc, labOcc, timetableGrid);
//                            }
//                        }
//                        else
//                        {
//                            UnassignTask(currentTask, staffOcc, labOcc, timetableGrid);
//                        }
//                    }
//                }

//                return false;
//            }

//            bool solved = await BacktrackWithCP(tasks);

//            if (!solved)
//                return Ok(new { message = "❌ Could not generate a conflict-free timetable.", receivedPayload = request });

//            // Final validation before commit
//            if (!ValidateFinalTimetable(tasks, HOURS))
//            {
//                return Ok(new { message = "❌ Timetable validation failed after generation.", receivedPayload = request });
//            }

//            // Atomic save transaction
//            await using var transaction = await conn.BeginTransactionAsync();

//            await using (var delClass = new NpgsqlCommand(@"
//                DELETE FROM classtimetable WHERE department_id=@department AND year=@year AND semester=@sem AND section=@section;", conn, transaction))
//            {
//                delClass.Parameters.AddWithValue("department", request.Department ?? "---");
//                delClass.Parameters.AddWithValue("year", request.Year ?? "---");
//                delClass.Parameters.AddWithValue("sem", request.Semester ?? "---");
//                delClass.Parameters.AddWithValue("section", request.Section ?? "---");
//                await delClass.ExecuteNonQueryAsync();
//            }

//            await using (var delLab = new NpgsqlCommand(@"
//                DELETE FROM labtimetable WHERE department=@department AND year=@year AND semester=@sem AND section=@section;", conn, transaction))
//            {
//                delLab.Parameters.AddWithValue("department", request.Department ?? "---");
//                delLab.Parameters.AddWithValue("year", request.Year ?? "---");
//                delLab.Parameters.AddWithValue("sem", request.Semester ?? "---");
//                delLab.Parameters.AddWithValue("section", request.Section ?? "---");
//                await delLab.ExecuteNonQueryAsync();
//            }

//            foreach (var t in tasks)
//            {
//                var (staffName, staffCode) = SplitStaff(t.StaffAssigned);
//                for (int h = t.StartHour; h < t.StartHour + t.Duration; h++)
//                {
//                    await using var icClass = new NpgsqlCommand(@"
//                        INSERT INTO classtimetable
//                        (staff_name, staff_code, department_id, year, semester, section, day, hour, subject_code, subject_name)
//                        VALUES
//                        (@staff_name, @staff_code, @department, @year, @semester, @section, @day, @hour, @subject_code, @subject_name);", conn, transaction);
//                    icClass.Parameters.AddWithValue("@staff_name", staffName ?? "---");
//                    icClass.Parameters.AddWithValue("@staff_code", staffCode ?? "---");
//                    icClass.Parameters.AddWithValue("@department", request.Department ?? "---");
//                    icClass.Parameters.AddWithValue("@year", request.Year ?? "---");
//                    icClass.Parameters.AddWithValue("@semester", request.Semester ?? "---");
//                    icClass.Parameters.AddWithValue("@section", request.Section ?? "---");
//                    icClass.Parameters.AddWithValue("@day", t.Day ?? "---");
//                    icClass.Parameters.AddWithValue("@hour", h);
//                    icClass.Parameters.AddWithValue("@subject_code", t.SubjectCode ?? "---");
//                    icClass.Parameters.AddWithValue("@subject_name", t.SubjectName ?? "---");
//                    await icClass.ExecuteNonQueryAsync();
//                }
//                if (t.IsLab && !string.IsNullOrEmpty(t.LabId))
//                {
//                    int labStart = t.StartHour == 4 ? 5 : t.StartHour;
//                    for (int h = labStart; h < t.StartHour + t.Duration; h++)
//                    {
//                        await using var icLab = new NpgsqlCommand(@"
//                            INSERT INTO labtimetable
//                            (lab_id, subject_code, subject_name, staff_name, department, year, semester, section, day, hour)
//                            VALUES
//                            (@lab_id, @subject_code, @subject_name, @staff_name, @department, @year, @semester, @section, @day, @hour);", conn, transaction);
//                        icLab.Parameters.AddWithValue("@lab_id", t.LabId ?? (object)DBNull.Value);
//                        icLab.Parameters.AddWithValue("@subject_code", t.SubjectCode ?? "---");
//                        icLab.Parameters.AddWithValue("@subject_name", t.SubjectName ?? "---");
//                        icLab.Parameters.AddWithValue("@staff_name", staffName ?? "---");
//                        icLab.Parameters.AddWithValue("@department", request.Department ?? "---");
//                        icLab.Parameters.AddWithValue("@year", request.Year ?? "---");
//                        icLab.Parameters.AddWithValue("@semester", request.Semester ?? "---");
//                        icLab.Parameters.AddWithValue("@section", request.Section ?? "---");
//                        icLab.Parameters.AddWithValue("@day", t.Day ?? "---");
//                        icLab.Parameters.AddWithValue("@hour", h);
//                        await icLab.ExecuteNonQueryAsync();
//                    }
//                }
//            }

//            await transaction.CommitAsync();

//            return Ok(new
//            {
//                message = "✅ Timetable generated successfully with CP-based global conflict resolution.",
//                timetable = timetableGrid.Select(t => new { Day = t.Key, Slots = t.Value }),
//                usedLabIds = tasks.Where(t => t.IsLab && !string.IsNullOrEmpty(t.LabId)).Select(t => t.LabId).Distinct(),
//                receivedPayload = request
//            });
//        }

//        private bool ValidateFinalTimetable(List<TaskUnit> tasks, int totalHours)
//        {
//            var staffSchedule = new Dictionary<string, Dictionary<string, HashSet<int>>>();
//            var labSchedule = new Dictionary<string, Dictionary<string, HashSet<int>>>();
//            foreach (var t in tasks)
//            {
//                var (_, staffCode) = SplitStaff(t.StaffAssigned);
//                if (!staffSchedule.ContainsKey(staffCode))
//                    staffSchedule[staffCode] = new Dictionary<string, HashSet<int>>();
//                if (!staffSchedule[staffCode].ContainsKey(t.Day))
//                    staffSchedule[staffCode][t.Day] = new HashSet<int>();
//                if (t.IsLab && !string.IsNullOrEmpty(t.LabId))
//                {
//                    if (!labSchedule.ContainsKey(t.LabId))
//                        labSchedule[t.LabId] = new Dictionary<string, HashSet<int>>();
//                    if (!labSchedule[t.LabId].ContainsKey(t.Day))
//                        labSchedule[t.LabId][t.Day] = new HashSet<int>();
//                }
//                for (int h = t.StartHour; h < t.StartHour + t.Duration; h++)
//                {
//                    if (h < 1 || h > totalHours)
//                        return false;
//                    if (staffSchedule[staffCode][t.Day].Contains(h))
//                        return false;
//                    else
//                        staffSchedule[staffCode][t.Day].Add(h);
//                    if (t.IsLab && !string.IsNullOrEmpty(t.LabId))
//                    {
//                        if (labSchedule[t.LabId][t.Day].Contains(h))
//                            return false;
//                        else
//                            labSchedule[t.LabId][t.Day].Add(h);
//                    }
//                    if (t.IsLab && t.Duration == 4 && !(t.StartHour == 1 || t.StartHour == 4))
//                        return false;
//                }
//            }
//            return true;
//        }
//    }
//}






using Google.OrTools.Sat;
using Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.Configuration;
using Npgsql;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;

namespace Timetablegenerator.Controllers
{
    [ApiController]
    [Route("api/[controller]")]
    public class TimetableController : ControllerBase
    {
        private readonly IConfiguration configuration;
        private static readonly Random rng = new Random();
        public TimetableController(IConfiguration configuration) { this.configuration = configuration; }

        #region DTOs
        public class TimetableRequest
        {
            public string Department { get; set; }
            public string Year { get; set; }
            public string Semester { get; set; }
            public string Section { get; set; }
            public int TotalHoursPerDay { get; set; } = 7;
            public List<SubjectDto> Subjects { get; set; }
        }
        public class SubjectDto
        {
            public string SubjectCode { get; set; }
            public string SubjectName { get; set; }
            public string SubjectType { get; set; }
            public int Credit { get; set; }
            public string StaffAssigned { get; set; }
            public string LabId { get; set; }
        }
        public class TaskUnit
        {
            public string SubjectCode, SubjectName, StaffAssigned, LabId, Kind, Day;
            public bool IsLab, IsPlaced;
            public int Duration, StartHour;
            public List<(string day, int start)> Domain = new();
            public override string ToString() => $"{SubjectCode} {StaffAssigned} {Day} {StartHour}";
        }
        #endregion

        #region Helpers
        void Shuffle<T>(List<T> list)
        {
            int n = list.Count;
            while (n > 1)
            {
                n--;
                int k = rng.Next(n + 1);
                (list[k], list[n]) = (list[n], list[k]);
            }
        }

        (string name, string code) SplitStaff(string staffAssigned)
        {
            if (string.IsNullOrWhiteSpace(staffAssigned)) return ("---", "---");
            if (staffAssigned.Contains('|'))
            {
                var parts = staffAssigned.Split('|', StringSplitOptions.TrimEntries);
                string name = parts[0].Trim();
                string code = parts.Length > 1 ? parts[1].Replace(".", "").Trim() : "---";
                return (name, code);
            }
            return (staffAssigned, staffAssigned);
        }

        bool IsFreeAndNoConflict(TaskUnit t, string day, int start, Dictionary<string, Dictionary<string, HashSet<int>>> staffOcc,
            Dictionary<string, Dictionary<string, HashSet<int>>> labOcc, Dictionary<string, Dictionary<int, string>> timetableGrid, int totalHours)
        {
            for (int h = start; h < start + t.Duration; h++)
            {
                if (h < 1 || h > totalHours) return false;
                if (timetableGrid[day][h] != "---") return false;
                var (_, staffCode) = SplitStaff(t.StaffAssigned);
                if (staffOcc.TryGetValue(staffCode, out var dm))
                    if (dm.TryGetValue(day, out var set) && set.Contains(h)) return false;
                if (t.IsLab && !string.IsNullOrEmpty(t.LabId))
                {
                    if (labOcc.TryGetValue(t.LabId, out var dmLab))
                        if (dmLab.TryGetValue(day, out var setLab) && setLab.Contains(h)) return false;
                }
            }
            if (t.Kind == "LAB4" && !(start == 1 || start == 4)) return false;
            return true;
        }

        void AssignTask(TaskUnit t, string day, int start,
            Dictionary<string, Dictionary<string, HashSet<int>>> staffOcc,
            Dictionary<string, Dictionary<string, HashSet<int>>> labOcc,
            Dictionary<string, Dictionary<int, string>> timetableGrid)
        {
            var (_, staffCode) = SplitStaff(t.StaffAssigned);
            for (int h = start; h < start + t.Duration; h++)
            {
                timetableGrid[day][h] = t.SubjectCode + "|" + t.StaffAssigned;
                if (!staffOcc.ContainsKey(staffCode))
                    staffOcc[staffCode] = new Dictionary<string, HashSet<int>>();
                if (!staffOcc[staffCode].ContainsKey(day))
                    staffOcc[staffCode][day] = new HashSet<int>();
                staffOcc[staffCode][day].Add(h);
                if (t.IsLab && !string.IsNullOrEmpty(t.LabId))
                {
                    if (!labOcc.ContainsKey(t.LabId))
                        labOcc[t.LabId] = new Dictionary<string, HashSet<int>>();
                    if (!labOcc[t.LabId].ContainsKey(day))
                        labOcc[t.LabId][day] = new HashSet<int>();
                    labOcc[t.LabId][day].Add(h);
                }
            }
            t.Day = day; t.StartHour = start; t.IsPlaced = true;
        }
        #endregion

        #region CP Conflict Solver
        private bool SolveConflictGroupWithCP(List<TaskUnit> conflictTasks, string[] days, int totalHours,
            Dictionary<string, Dictionary<string, HashSet<int>>> staffOccGlobal,
            Dictionary<string, Dictionary<string, HashSet<int>>> labOccGlobal,
            out Dictionary<TaskUnit, (string day, int start)> solution)
        {
            solution = null;
            var dayIndex = days.Select((d, i) => (d, i)).ToDictionary(x => x.d, x => x.i);
            var model = new CpModel();
            int horizon = days.Length * totalHours;
            var taskStartVars = new Dictionary<TaskUnit, IntVar>();
            var startBools = new Dictionary<TaskUnit, List<BoolVar>>();
            var slotTaskBools = new Dictionary<(TaskUnit, int), BoolVar>();
            // allowed start indices per task
            foreach (var t in conflictTasks)
            {
                var allowedStarts = new List<int>();
                if (t.Domain != null && t.Domain.Count > 0)
                {
                    foreach (var (d, start) in t.Domain)
                    {
                        int idx = dayIndex[d] * totalHours + (start - 1);
                        allowedStarts.Add(idx);
                    }
                }
                else
                {
                    for (int d = 0; d < days.Length; d++)
                        for (int s = 0; s <= totalHours - t.Duration; s++)
                            allowedStarts.Add(d * totalHours + s);
                }
                if (allowedStarts.Count == 0) return false;
                var startVar = model.NewIntVarFromDomain(
                    Domain.FromValues(allowedStarts.Select(x => (long)x)), $"{t.SubjectCode}_start");
                taskStartVars[t] = startVar;
                // For each allowed start, create a BoolVar for exactly one start
                var bools = new List<BoolVar>();
                foreach (var idx in allowedStarts)
                {
                    var b = model.NewBoolVar($"{t.SubjectCode}_startAt_{idx}");
                    model.Add(startVar == idx).OnlyEnforceIf(b);
                    bools.Add(b);
                }
                model.AddExactlyOne(bools);
                startBools[t] = bools;
            }
            // Covering: for each task and slot, true if this task covers the slot
            foreach (var t in conflictTasks)
            {
                foreach (var startIdx in startBools[t].Select((b, i) => (b, i)))
                {
                    var b = startIdx.b;
                    int begin = startBools[t].Count > 0 ? ((int)Domain.FromValues(startBools[t].Count).Values[startIdx.i]) : 0;
                    int actualIdx = begin;
                    for (int offset = 0; offset < t.Duration; offset++)
                    {
                        int slotIdx = actualIdx + offset;
                        if (slotIdx < horizon)
                        {
                            var key = (t, slotIdx);
                            if (!slotTaskBools.ContainsKey(key))
                                slotTaskBools[key] = model.NewBoolVar($"{t.SubjectCode}_covers_{slotIdx}");
                            model.AddBoolOr(new[] { b.Not(), slotTaskBools[key] });
                        }
                    }
                }
            }
       // Overlap constraint among tasks sharing staff/lab
for (int i = 0; i < conflictTasks.Count; i++)
{
    var t1 = conflictTasks[i];
    var (_, staff1) = SplitStaff(t1.StaffAssigned); 
    var lab1 = t1.LabId;
    for (int j = i + 1; j < conflictTasks.Count; j++)
    {
        var t2 = conflictTasks[j];
        var (_, staff2) = SplitStaff(t2.StaffAssigned); 
        var lab2 = t2.LabId;
        bool overlapStaff = staff1 == staff2 && staff1 != "---";
        bool overlapLab = !string.IsNullOrEmpty(lab1) && lab1 == lab2;
        if (overlapStaff || overlapLab)
        {
            for (int slot = 0; slot < horizon; slot++)
            {
                if (slotTaskBools.TryGetValue((t1, slot), out var b1) &&
                    slotTaskBools.TryGetValue((t2, slot), out var b2))
                {
                    model.AddBoolOr(new ILiteral[] { b1.Not(), b2.Not() });
                }
            }
        }
    }
}

            // Prevent overlap with staff/lab global occupancy
            foreach (var t in conflictTasks)
            {
                var (_, staff) = SplitStaff(t.StaffAssigned);
                for (int d = 0; d < days.Length; d++)
                {
                    var day = days[d];
                    if (staffOccGlobal.TryGetValue(staff, out var staffDayMap) && staffDayMap.TryGetValue(day, out var staffHours))
                    {
                        foreach (var hr in staffHours)
                        {
                            for (int o = 0; o < t.Duration; o++)
                            {
                                int slotIdx = d * totalHours + (hr - 1 - o);
                                var b = slotTaskBools.GetValueOrDefault((t, slotIdx));
                                if (b != null)
                                    model.Add(b == 0);
                            }
                        }
                    }
                    if (t.IsLab && !string.IsNullOrEmpty(t.LabId) && labOccGlobal.TryGetValue(t.LabId, out var labDayMap) && labDayMap.TryGetValue(day, out var labHours))
                    {
                        foreach (var hr in labHours)
                        {
                            for (int o = 0; o < t.Duration; o++)
                            {
                                int slotIdx = d * totalHours + (hr - 1 - o);
                                var b = slotTaskBools.GetValueOrDefault((t, slotIdx));
                                if (b != null)
                                    model.Add(b == 0);
                            }
                        }
                    }
                }
            }
            // Special: for lab durations, enforce allowed start hours
            foreach (var t in conflictTasks)
            {
                if (t.IsLab && t.Duration == 4)
                {
                    var allowedStartIdxs = new HashSet<int>();
                    foreach (var (d, s) in t.Domain)
                    {
                        if (s == 1 || s == 4)
                            allowedStartIdxs.Add(dayIndex[d] * totalHours + (s - 1));
                    }
                    model.AddAllowedAssignments(new[] { taskStartVars[t] },
                        allowedStartIdxs.Select(idx => new long[] { idx }).ToList());
                }
            }
            var solver = new CpSolver();
            solver.StringParameters = "maxtimeinseconds:10";
            var status = solver.Solve(model);
            if (status == CpSolverStatus.Optimal || status == CpSolverStatus.Feasible)
            {
                solution = new Dictionary<TaskUnit, (string day, int start)>();
                foreach (var t in conflictTasks)
                {
                    int slot = (int)solver.Value(taskStartVars[t]);
                    int dayIdx = slot / totalHours;
                    int startHour = slot % totalHours + 1;
                    solution[t] = (days[dayIdx], startHour);
                }
                return true;
            }
            return false;
        }
        #endregion

        #region GA+CP Hybrid Timetable Generator
        private List<TaskUnit> GeneticAlgorithmGenerate(List<TaskUnit> tasks, string[] days, int totalHours,
            Dictionary<string, Dictionary<string, HashSet<int>>> staffOcc, Dictionary<string, Dictionary<string, HashSet<int>>> labOcc,
            Dictionary<string, Dictionary<int, string>> timetableGrid, int maxGenerations = 500, int populationSize = 20)
        {
            // Simple GA for initial assignment, fallback to CP for conflicts
            List<Dictionary<TaskUnit, (string day, int start)>> population = new();
            for (int i = 0; i < populationSize; i++)
            {
                var indiv = new Dictionary<TaskUnit, (string day, int start)>();
                foreach (var t in tasks)
                {
                    var domain = t.Domain.ToList();
                    Shuffle(domain);
                    (string day, int start)? chosen = null;
                    foreach (var slot in domain)
                        if (IsFreeAndNoConflict(t, slot.day, slot.start, staffOcc, labOcc, timetableGrid, totalHours)) { chosen = slot; break; }
                    indiv[t] = chosen ?? (null, 0);
                }
                population.Add(indiv);
            }
            int Fitness(Dictionary<TaskUnit, (string day, int start)> indiv)
            {
                var staffMap = new Dictionary<string, Dictionary<string, HashSet<int>>>();
                var labMap = new Dictionary<string, Dictionary<string, HashSet<int>>>();
                int conflicts = 0;
                foreach (var kvp in indiv)
                {
                    var t = kvp.Key;
                    var assignment = kvp.Value;
                    if (assignment.day == null) { conflicts += 10; continue; }
                    var (_, staffCode) = SplitStaff(t.StaffAssigned);
                    if (!staffMap.ContainsKey(staffCode))
                        staffMap[staffCode] = new Dictionary<string, HashSet<int>>();
                    if (!staffMap[staffCode].ContainsKey(assignment.day))
                        staffMap[staffCode][assignment.day] = new HashSet<int>();
                    if (t.IsLab && !string.IsNullOrEmpty(t.LabId))
                    {
                        if (!labMap.ContainsKey(t.LabId))
                            labMap[t.LabId] = new Dictionary<string, HashSet<int>>();
                        if (!labMap[t.LabId].ContainsKey(assignment.day))
                            labMap[t.LabId][assignment.day] = new HashSet<int>();
                    }
                    for (int h = assignment.start; h < assignment.start + t.Duration; h++)
                    {
                        if (staffMap[staffCode][assignment.day].Contains(h)) conflicts++;
                        staffMap[staffCode][assignment.day].Add(h);
                        if (t.IsLab && !string.IsNullOrEmpty(t.LabId))
                        {
                            if (labMap[t.LabId][assignment.day].Contains(h)) conflicts++;
                            labMap[t.LabId][assignment.day].Add(h);
                        }
                    }
                }
                return conflicts;
            }
            for (int gen = 0; gen < maxGenerations; gen++)
            {
                population = population.OrderBy(Fitness).ToList();
                if (Fitness(population[0]) == 0) break;
                var newPop = new List<Dictionary<TaskUnit, (string day, int start)>>() { population[0] };
                while (newPop.Count < populationSize)
                {
                    var p1 = population[rng.Next(populationSize / 2)];
                    var p2 = population[rng.Next(populationSize / 2)];
                    var child = new Dictionary<TaskUnit, (string day, int start)>();
                    foreach (var t in tasks)
                        child[t] = rng.NextDouble() < 0.5 ? p1[t] : p2[t];
                    for (int k = 0; k < 2; k++)
                    {
                        var t = tasks[rng.Next(tasks.Count)];
                        var d = t.Domain.ToList();
                        if (d.Count > 0)
                            child[t] = d[rng.Next(d.Count)];
                    }
                    newPop.Add(child);
                }
                population = newPop;
            }
            var best = population.OrderBy(Fitness).First();
            // Fix conflicts by CP if any remain
            var conflictedTasks = tasks.Where(t => best[t].day == null).ToList();
            if (conflictedTasks.Count > 0)
            {
                Dictionary<TaskUnit, (string day, int start)> cpSolution;
                if (SolveConflictGroupWithCP(conflictedTasks, days, totalHours, staffOcc, labOcc, out cpSolution))
                {
                    foreach (var t in conflictedTasks)
                        best[t] = cpSolution[t];
                }
            }
            foreach (var t in tasks)
            {
                var a = best[t];
                if (a.day != null)
                    AssignTask(t, a.day, a.start, staffOcc, labOcc, timetableGrid);
            }
            return tasks;
        }
        #endregion

        #region Timetable Validation
        private bool ValidateFinalTimetable(List<TaskUnit> tasks, int totalHours)
        {
            var staffSchedule = new Dictionary<string, Dictionary<string, HashSet<int>>>();
            var labSchedule = new Dictionary<string, Dictionary<string, HashSet<int>>>();
            foreach (var t in tasks)
            {
                var (_, staffCode) = SplitStaff(t.StaffAssigned);
                if (!staffSchedule.ContainsKey(staffCode))
                    staffSchedule[staffCode] = new Dictionary<string, HashSet<int>>();
                if (!staffSchedule[staffCode].ContainsKey(t.Day))
                    staffSchedule[staffCode][t.Day] = new HashSet<int>();
                if (t.IsLab && !string.IsNullOrEmpty(t.LabId))
                {
                    if (!labSchedule.ContainsKey(t.LabId))
                        labSchedule[t.LabId] = new Dictionary<string, HashSet<int>>();
                    if (!labSchedule[t.LabId].ContainsKey(t.Day))
                        labSchedule[t.LabId][t.Day] = new HashSet<int>();
                }
                for (int h = t.StartHour; h < t.StartHour + t.Duration; h++)
                {
                    if (h < 1 || h > totalHours) return false;
                    if (staffSchedule[staffCode][t.Day].Contains(h)) return false;
                    staffSchedule[staffCode][t.Day].Add(h);
                    if (t.IsLab && !string.IsNullOrEmpty(t.LabId))
                    {
                        if (labSchedule[t.LabId][t.Day].Contains(h)) return false;
                        labSchedule[t.LabId][t.Day].Add(h);
                    }
                }
                if (t.IsLab && t.Duration == 4 && !(t.StartHour == 1 || t.StartHour == 4)) return false;
            }
            return true;
        }
        #endregion

        [HttpPost]
        [Route("generateCrossDepartmentTimetableBacktracking")]
        public async Task<IActionResult> GenerateHybridTimetableFromBody([FromBody] TimetableRequest request)
        {
            var cs = configuration.GetConnectionString("DefaultConnection");
            await using var conn = new NpgsqlConnection(cs);
            await conn.OpenAsync();

            string[] DAYS = new[] { "Mon", "Tue", "Wed", "Thu", "Fri" };
            int HOURS = Math.Max(1, request.TotalHoursPerDay);

            var timetableGrid = DAYS.ToDictionary(d => d, d => Enumerable.Range(1, HOURS).ToDictionary(h => h, h => "---"));
            var staffOcc = new Dictionary<string, Dictionary<string, HashSet<int>>>();
            var labOcc = new Dictionary<string, Dictionary<string, HashSet<int>>>();

            // Occupancy loading for staff
            await using (var cmd = new NpgsqlCommand("SELECT staffcode, day, hour FROM classtimetable", conn))
            await using (var rd = await cmd.ExecuteReaderAsync())
                while (await rd.ReadAsync())
                {
                    var sc = rd["staffcode"] as string ?? "---";
                    var day = rd["day"] as string ?? "Mon";
                    var hr = Convert.ToInt32(rd["hour"]);
                    if (!staffOcc.ContainsKey(sc))
                        staffOcc[sc] = DAYS.ToDictionary(d => d, _ => new HashSet<int>());
                    staffOcc[sc][day].Add(hr);
                }
            // Occupancy loading for lab
            await using (var cmd = new NpgsqlCommand("SELECT labid, day, hour FROM labtimetable", conn))
            await using (var rd = await cmd.ExecuteReaderAsync())
                while (await rd.ReadAsync())
                {
                    var lab = rd["labid"] as string ?? "---";
                    var day = rd["day"] as string ?? "Mon";
                    var hr = Convert.ToInt32(rd["hour"]);
                    if (!labOcc.ContainsKey(lab))
                        labOcc[lab] = DAYS.ToDictionary(d => d, _ => new HashSet<int>());
                    labOcc[lab][day].Add(hr);
                }

            var subjects = request.Subjects?.Where(s => !string.IsNullOrWhiteSpace(s.StaffAssigned)).ToList();
            if (subjects == null || subjects.Count == 0)
                return BadRequest(new { message = "No valid subjects with assigned staff found." });

            var tasks = new List<TaskUnit>();
            foreach (var s in subjects)
            {
                string type = (s.SubjectType ?? "theory").Trim().ToLower();
                if (type == "lab")
                    tasks.Add(new TaskUnit
                    {
                        SubjectCode = s.SubjectCode ?? "---",
                        SubjectName = s.SubjectName ?? "---",
                        StaffAssigned = s.StaffAssigned,
                        LabId = s.LabId,
                        IsLab = true,
                        Duration = 4,
                        Kind = "LAB4"
                    });
                else if (type == "embedded")
                {
                    tasks.Add(new TaskUnit
                    {
                        SubjectCode = s.SubjectCode ?? "---",
                        SubjectName = s.SubjectName ?? "---",
                        StaffAssigned = s.StaffAssigned,
                        LabId = s.LabId,
                        IsLab = true,
                        Duration = 2,
                        Kind = "EMBLAB2"
                    });
                    tasks.Add(new TaskUnit
                    {
                        SubjectCode = s.SubjectCode ?? "---",
                        SubjectName = s.SubjectName ?? "---",
                        StaffAssigned = s.StaffAssigned,
                        IsLab = false,
                        Duration = 1,
                        Kind = "EMBTH1"
                    });
                    tasks.Add(new TaskUnit
                    {
                        SubjectCode = s.SubjectCode ?? "---",
                        SubjectName = s.SubjectName ?? "---",
                        StaffAssigned = s.StaffAssigned,
                        IsLab = false,
                        Duration = 1,
                        Kind = "EMBTH1"
                    });
                }
                else
                {
                    int count = Math.Max(0, s.Credit);
                    for (int i = 0; i < count; i++)
                    {
                        tasks.Add(new TaskUnit
                        {
                            SubjectCode = s.SubjectCode ?? "---",
                            SubjectName = s.SubjectName ?? "---",
                            StaffAssigned = s.StaffAssigned,
                            IsLab = false,
                            Duration = 1,
                            Kind = "TH1"
                        });
                    }
                }
            }

            Shuffle(tasks);

            // Domain initialization
            foreach (var t in tasks)
            {
                t.Domain.Clear();
                foreach (var day in DAYS)
                    for (int start = 1; start <= HOURS - t.Duration + 1; start++)
                        if (IsFreeAndNoConflict(t, day, start, staffOcc, labOcc, timetableGrid, HOURS))
                            t.Domain.Add((day, start));
            }

            Shuffle(tasks);

            var finalTasks = GeneticAlgorithmGenerate(tasks, DAYS, HOURS, staffOcc, labOcc, timetableGrid);

            if (!ValidateFinalTimetable(finalTasks, HOURS))
                return Ok(new { message = "Timetable validation failed after generation.", receivedPayload = request });

            await using var transaction = await conn.BeginTransactionAsync();

            await using (var delClass = new NpgsqlCommand(
                "DELETE FROM classtimetable WHERE departmentid=@department AND year=@year AND semester=@sem AND section=@section", conn, transaction))
            {
                delClass.Parameters.AddWithValue("department", request.Department ?? "---");
                delClass.Parameters.AddWithValue("year", request.Year ?? "---");
                delClass.Parameters.AddWithValue("sem", request.Semester ?? "---");
                delClass.Parameters.AddWithValue("section", request.Section ?? "---");
                await delClass.ExecuteNonQueryAsync();
            }

            await using (var delLab = new NpgsqlCommand(
                "DELETE FROM labtimetable WHERE department=@department AND year=@year AND semester=@sem AND section=@section", conn, transaction))
            {
                delLab.Parameters.AddWithValue("department", request.Department ?? "---");
                delLab.Parameters.AddWithValue("year", request.Year ?? "---");
                delLab.Parameters.AddWithValue("sem", request.Semester ?? "---");
                delLab.Parameters.AddWithValue("section", request.Section ?? "---");
                await delLab.ExecuteNonQueryAsync();
            }

            foreach (var t in finalTasks)
            {
                var (staffName, staffCode) = SplitStaff(t.StaffAssigned);
                for (int h = t.StartHour; h < t.StartHour + t.Duration; h++)
                {
                    await using var icClass = new NpgsqlCommand(
                        "INSERT INTO classtimetable(staffname, staffcode, departmentid, year, semester, section, day, hour, subjectcode, subjectname) VALUES " +
                        "(@staffname, @staffcode, @department, @year, @semester, @section, @day, @hour, @subjectcode, @subjectname)", conn, transaction);
                    icClass.Parameters.AddWithValue("staffname", staffName ?? "---");
                    icClass.Parameters.AddWithValue("staffcode", staffCode ?? "---");
                    icClass.Parameters.AddWithValue("department", request.Department ?? "---");
                    icClass.Parameters.AddWithValue("year", request.Year ?? "---");
                    icClass.Parameters.AddWithValue("semester", request.Semester ?? "---");
                    icClass.Parameters.AddWithValue("section", request.Section ?? "---");
                    icClass.Parameters.AddWithValue("day", t.Day ?? "---");
                    icClass.Parameters.AddWithValue("hour", h);
                    icClass.Parameters.AddWithValue("subjectcode", t.SubjectCode ?? "---");
                    icClass.Parameters.AddWithValue("subjectname", t.SubjectName ?? "---");
                    await icClass.ExecuteNonQueryAsync();
                }
                if (t.IsLab && !string.IsNullOrEmpty(t.LabId))
                {
                    int labStart = t.StartHour;
                    for (int h = labStart; h < t.StartHour + t.Duration; h++)
                    {
                        await using var icLab = new NpgsqlCommand(
                            "INSERT INTO labtimetable(labid, subjectcode, subjectname, staffname, department, year, semester, section, day, hour) VALUES " +
                            "(@labid, @subjectcode, @subjectname, @staffname, @department, @year, @semester, @section, @day, @hour)", conn, transaction);
                        icLab.Parameters.AddWithValue("labid", t.LabId ?? (object)DBNull.Value);
                        icLab.Parameters.AddWithValue("subjectcode", t.SubjectCode ?? "---");
                        icLab.Parameters.AddWithValue("subjectname", t.SubjectName ?? "---");
                        icLab.Parameters.AddWithValue("staffname", staffName ?? "---");
                        icLab.Parameters.AddWithValue("department", request.Department ?? "---");
                        icLab.Parameters.AddWithValue("year", request.Year ?? "---");
                        icLab.Parameters.AddWithValue("semester", request.Semester ?? "---");
                        icLab.Parameters.AddWithValue("section", request.Section ?? "---");
                        icLab.Parameters.AddWithValue("day", t.Day ?? "---");
                        icLab.Parameters.AddWithValue("hour", h);
                        await icLab.ExecuteNonQueryAsync();
                    }
                }
            }

            await transaction.CommitAsync();

            return Ok(new
            {
                message = "Timetable generated successfully with hybrid genetic algorithm and deterministic conflict resolution.",
                timetable = timetableGrid.Select(t => new { Day = t.Key, Slots = t.Value }),
                receivedPayload = request
            });
        }
    }
}
